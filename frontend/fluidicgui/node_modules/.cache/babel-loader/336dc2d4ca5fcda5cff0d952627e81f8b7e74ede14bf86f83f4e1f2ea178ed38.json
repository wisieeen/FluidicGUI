{"ast":null,"code":"var _jsxFileName = \"E:\\\\flow chemistry\\\\fluidicGUI\\\\frontend\\\\fluidicgui\\\\src\\\\components\\\\Simulation\\\\SpectrometerMQTT\\\\MQTTGraphComponent.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useRef, useEffect, useImperativeHandle } from 'react';\nimport { useButtonStyles } from '../../../styles/ButtonStyleProvider';\nimport spectralConfig from './spectral_config.json';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst GraphComponent = /*#__PURE__*/_s(/*#__PURE__*/React.forwardRef(_c = _s((props, ref) => {\n  _s();\n  const {\n    onResize,\n    lineData,\n    onFrameAccumCountChange,\n    onAccumulationToggle\n  } = props;\n  const buttonVariants = useButtonStyles();\n  const [graphSize, setGraphSize] = useState({\n    width: '100%',\n    height: 200\n  });\n  const [isResizing, setIsResizing] = useState(false);\n  const [showResizeInfo, setShowResizeInfo] = useState(false);\n  const [displayChannels, setDisplayChannels] = useState({\n    red: false,\n    green: false,\n    blue: false,\n    intensity: true\n  });\n  const [graphData, setGraphData] = useState(null);\n\n  // Memory for storing graph data\n  const [memorizedData, setMemorizedData] = useState([]);\n\n  // Cursor tracking state\n  const [cursorPosition, setCursorPosition] = useState(null);\n  const [showCrosshair, setShowCrosshair] = useState(false);\n\n  // Frame accumulation state - internally managed but synced with parent\n  const [frameAccumCount, setFrameAccumCount] = useState(10); // Default to 10 frames\n  const [accumulatedFrames, setAccumulatedFrames] = useState([]);\n  const [accumulatedData, setAccumulatedData] = useState(null);\n  const [isAccumulating, setIsAccumulating] = useState(false);\n\n  // Export file name prefix\n  const [filePrefix, setFilePrefix] = useState('spectrum');\n  const [includeDateInFilename, setIncludeDateInFilename] = useState(true);\n\n  // Status message for operations\n  const [saveMessage, setSaveMessage] = useState('');\n\n  // Peak detection state\n  const [showPeakMarkers, setShowPeakMarkers] = useState(true);\n  const [peakCount, setPeakCount] = useState(3); // Default to showing top 3 peaks\n\n  // Calibration state\n  const [showCalibration, setShowCalibration] = useState(false);\n  const [calibrationPoints, setCalibrationPoints] = useState([{\n    position: 0.25000,\n    wavelength: 450.0\n  }, {\n    position: 0.75000,\n    wavelength: 650.0\n  }]);\n  const [useCalibration, setUseCalibration] = useState(false);\n  const [flipXAxis, setFlipXAxis] = useState(false);\n  const graphContainerRef = useRef(null);\n  const canvasRef = useRef(null);\n\n  // Expose methods to parent component via ref\n  useImperativeHandle(ref, () => ({\n    getCalibrationSettings: () => ({\n      calibrationPoints: [...calibrationPoints],\n      useCalibration,\n      flipXAxis\n    }),\n    applyCalibrationSettings: settings => {\n      if (!settings) return false;\n      try {\n        if (settings.calibrationPoints && Array.isArray(settings.calibrationPoints)) {\n          setCalibrationPoints(settings.calibrationPoints);\n        }\n        if (typeof settings.useCalibration === 'boolean') {\n          setUseCalibration(settings.useCalibration);\n          if (settings.useCalibration) {\n            setShowCalibration(true);\n          }\n        }\n        if (typeof settings.flipXAxis === 'boolean') {\n          setFlipXAxis(settings.flipXAxis);\n        }\n        return true;\n      } catch (error) {\n        console.error('Error applying calibration settings:', error);\n        return false;\n      }\n    },\n    getPeakSettings: () => ({\n      count: peakCount,\n      showMarkers: showPeakMarkers\n    }),\n    applyPeakSettings: settings => {\n      if (!settings) return false;\n      try {\n        if (typeof settings.count === 'number') {\n          setPeakCount(settings.count);\n        }\n        if (typeof settings.showMarkers === 'boolean') {\n          setShowPeakMarkers(settings.showMarkers);\n        }\n        return true;\n      } catch (error) {\n        console.error('Error applying peak settings:', error);\n        return false;\n      }\n    }\n  }));\n\n  // Process raw spectral data\n  const processRawSpectralData = rawData => {\n    if (!rawData) return null;\n    try {\n      // Extract the necessary data from the raw data\n      const {\n        timestamp,\n        wavelengths\n      } = rawData;\n\n      // Default structure for processed data\n      const processedData = {\n        timestamp: timestamp || Date.now(),\n        positions: wavelengths || [],\n        red: [],\n        green: [],\n        blue: [],\n        intensity: [],\n        lineLength: (wavelengths === null || wavelengths === void 0 ? void 0 : wavelengths.length) || 0,\n        isRawData: true,\n        bitDepth: rawData.bit_depth || 12,\n        dataType: rawData.data_type || 'raw'\n      };\n\n      // Process based on data type (RGB or monochrome)\n      if (rawData.red && rawData.green && rawData.blue) {\n        // RGB data\n        processedData.red = [...rawData.red];\n        processedData.green = [...rawData.green];\n        processedData.blue = [...rawData.blue];\n      } else {\n        console.error(\"Unknown raw data format:\", rawData);\n        return null;\n      }\n\n      // Calculate intensity using wavelength ranges and sensitivity factors\n      processedData.intensity = calculateIntensityWithCorrections(processedData.red, processedData.green, processedData.blue, processedData.positions);\n      return processedData;\n    } catch (error) {\n      console.error(\"Error processing raw spectral data:\", error);\n      return null;\n    }\n  };\n\n  // Calculate intensity with wavelength ranges and sensitivity corrections\n  const calculateIntensityWithCorrections = (redData, greenData, blueData, wavelengths) => {\n    if (!wavelengths || !wavelengths.length) return [];\n\n    // Get channel ranges from config\n    const {\n      CHANNEL_RANGES,\n      SENSITIVITY_FACTORS\n    } = spectralConfig;\n    const redRange = CHANNEL_RANGES.r;\n    const greenRange = CHANNEL_RANGES.g;\n    const blueRange = CHANNEL_RANGES.b;\n\n    // Convert sensitivity factors object to array for easier lookup\n    const sensitivityWavelengths = Object.keys(SENSITIVITY_FACTORS).map(Number);\n\n    // Initialize intensity array\n    const intensity = new Array(wavelengths.length).fill(0);\n\n    // For each wavelength position\n    for (let i = 0; i < wavelengths.length; i++) {\n      const wavelength = wavelengths[i];\n      let sum = 0;\n      let count = 0;\n\n      // Add red channel contribution if wavelength is in red range\n      if (wavelength >= redRange[0] && wavelength <= redRange[1]) {\n        // Find closest sensitivity factor\n        const closestWavelength = findClosestWavelength(wavelength, sensitivityWavelengths);\n        const sensitivityFactor = SENSITIVITY_FACTORS[closestWavelength.toString()];\n\n        // Apply correction factor\n        sum += redData[i] / sensitivityFactor;\n        count++;\n      }\n\n      // Add green channel contribution if wavelength is in green range\n      if (wavelength >= greenRange[0] && wavelength <= greenRange[1]) {\n        // Find closest sensitivity factor\n        const closestWavelength = findClosestWavelength(wavelength, sensitivityWavelengths);\n        const sensitivityFactor = SENSITIVITY_FACTORS[closestWavelength.toString()];\n\n        // Apply correction factor\n        sum += greenData[i] / sensitivityFactor;\n        count++;\n      }\n\n      // Add blue channel contribution if wavelength is in blue range\n      if (wavelength >= blueRange[0] && wavelength <= blueRange[1]) {\n        // Find closest sensitivity factor\n        const closestWavelength = findClosestWavelength(wavelength, sensitivityWavelengths);\n        const sensitivityFactor = SENSITIVITY_FACTORS[closestWavelength.toString()];\n\n        // Apply correction factor\n        sum += blueData[i] / sensitivityFactor;\n        count++;\n      }\n\n      // Calculate average if any channels contributed\n      intensity[i] = count > 0 ? sum / count : 0;\n    }\n    return intensity;\n  };\n\n  // Find the closest wavelength value in the sensitivity factors\n  const findClosestWavelength = (targetWavelength, wavelengths) => {\n    if (!wavelengths.length) return targetWavelength;\n    let closest = wavelengths[0];\n    let minDiff = Math.abs(targetWavelength - closest);\n    for (let i = 1; i < wavelengths.length; i++) {\n      const diff = Math.abs(targetWavelength - wavelengths[i]);\n      if (diff < minDiff) {\n        minDiff = diff;\n        closest = wavelengths[i];\n      }\n    }\n    return closest;\n  };\n\n  // Update graph when line data changes\n  useEffect(() => {\n    if (lineData) {\n      // Process the data differently based on what we receive\n      let pixelData;\n      if (lineData.pixelData) {\n        // Legacy format - already processed data\n        pixelData = lineData.pixelData;\n      } else if (lineData.graph_data) {\n        // New format - contains raw graph data from spectrometer\n        pixelData = processRawSpectralData(lineData.graph_data);\n      } else {\n        // Direct raw data format\n        pixelData = processRawSpectralData(lineData);\n      }\n      if (pixelData) {\n        // Always keep the latest raw frame data for display when not accumulating\n        setGraphData(pixelData);\n        if (isAccumulating) {\n          // Add new frame to accumulation buffer\n          setAccumulatedFrames(prev => {\n            const newFrames = [...prev, pixelData];\n\n            // If we've reached our target frame count, process the accumulated data\n            if (newFrames.length >= frameAccumCount) {\n              // Sum the color data across all frames\n              const summedData = sumFrameData(newFrames);\n\n              // Update accumulated data state\n              setAccumulatedData(summedData);\n\n              // Draw the accumulated data\n              drawGraph(summedData);\n\n              // Reset the accumulation buffer\n              return [];\n            }\n            return newFrames;\n          });\n        } else {\n          // If not accumulating, just display the raw frame\n          drawGraph(pixelData);\n        }\n      }\n    }\n  }, [lineData, isAccumulating, frameAccumCount, useCalibration, calibrationPoints, flipXAxis]);\n\n  // When accumulated data changes, draw it\n  useEffect(() => {\n    if (accumulatedData && isAccumulating) {\n      drawGraph(accumulatedData);\n    }\n  }, [accumulatedData, useCalibration, calibrationPoints, flipXAxis]);\n\n  // Function to add current data to memory\n  const addToMemory = () => {\n    const dataToMemorize = isAccumulating ? accumulatedData : graphData;\n    if (!dataToMemorize) {\n      setSaveMessage('No data to memorize');\n      setTimeout(() => setSaveMessage(''), 3000);\n      return;\n    }\n\n    // Create a copy of the data with a timestamp\n    const memorizedItem = {\n      ...dataToMemorize,\n      memoryTimestamp: new Date().toISOString()\n    };\n\n    // Add to memory array\n    setMemorizedData(prev => [...prev, memorizedItem]);\n    setSaveMessage(`Data added to memory (${memorizedData.length + 1} items)`);\n    setTimeout(() => setSaveMessage(''), 3000);\n  };\n\n  // Function to clear memory\n  const clearMemory = () => {\n    setMemorizedData([]);\n    setSaveMessage('Memory cleared');\n    setTimeout(() => setSaveMessage(''), 3000);\n  };\n\n  // Sum pixel data across multiple frames\n  const sumFrameData = frames => {\n    if (!frames.length) return null;\n\n    // Use the first frame as a template for structure\n    const template = frames[0];\n\n    // Initialize arrays for summed values\n    const summedRed = Array(template.red.length).fill(0);\n    const summedGreen = Array(template.green.length).fill(0);\n    const summedBlue = Array(template.blue.length).fill(0);\n    const summedIntensity = Array(template.intensity.length).fill(0);\n\n    // Sum values across all frames\n    frames.forEach(frame => {\n      frame.red.forEach((val, i) => summedRed[i] += val);\n      frame.green.forEach((val, i) => summedGreen[i] += val);\n      frame.blue.forEach((val, i) => summedBlue[i] += val);\n      frame.intensity.forEach((val, i) => summedIntensity[i] += val);\n    });\n\n    // Return the summed data structure\n    return {\n      timestamp: Date.now(),\n      positions: template.positions,\n      // Positions remain the same\n      red: summedRed,\n      green: summedGreen,\n      blue: summedBlue,\n      intensity: summedIntensity,\n      lineLength: template.lineLength,\n      frameCount: frames.length,\n      // Add count of frames that were summed\n\n      // Preserve raw data metadata if present in template\n      isRawData: template.isRawData || false,\n      bitDepth: template.bitDepth || null,\n      dataType: template.dataType || null\n    };\n  };\n\n  // Convert position to wavelength using calibration points\n  const positionToWavelength = position => {\n    if (!useCalibration || calibrationPoints.length < 2) {\n      return position;\n    }\n\n    // Sort calibration points by position\n    const sortedPoints = [...calibrationPoints].sort((a, b) => a.position - b.position);\n\n    // Find the two calibration points that surround the given position\n    let p1, p2;\n    for (let i = 0; i < sortedPoints.length - 1; i++) {\n      if (position >= sortedPoints[i].position && position <= sortedPoints[i + 1].position) {\n        p1 = sortedPoints[i];\n        p2 = sortedPoints[i + 1];\n        break;\n      }\n    }\n\n    // If position is outside the calibration range, use extrapolation\n    if (!p1 || !p2) {\n      if (position < sortedPoints[0].position) {\n        // Extrapolate below the first point\n        // Use the first two points for the slope calculation\n        p1 = sortedPoints[0];\n        p2 = sortedPoints[1];\n        // Calculate the slope between first two calibration points\n        const slope = (p2.wavelength - p1.wavelength) / (p2.position - p1.position);\n        // Extrapolate using y = mx + b formula\n        return p1.wavelength + slope * (position - p1.position);\n      } else {\n        // Extrapolate above the last point\n        // Use the last two points for the slope calculation\n        p1 = sortedPoints[sortedPoints.length - 2];\n        p2 = sortedPoints[sortedPoints.length - 1];\n        // Calculate the slope between last two calibration points\n        const slope = (p2.wavelength - p1.wavelength) / (p2.position - p1.position);\n        // Extrapolate using y = mx + b formula\n        return p2.wavelength + slope * (position - p2.position);\n      }\n    }\n\n    // Linear interpolation between the two calibration points\n    const t = (position - p1.position) / (p2.position - p1.position);\n    return p1.wavelength + t * (p2.wavelength - p1.wavelength);\n  };\n\n  // Handle changing the frame accumulation count\n  const handleFrameCountChange = e => {\n    const count = parseInt(e.target.value);\n    if (!isNaN(count) && count > 0) {\n      setFrameAccumCount(count);\n      // Reset accumulation when count changes\n      setAccumulatedFrames([]);\n      setAccumulatedData(null);\n\n      // Notify parent of change\n      if (onFrameAccumCountChange) {\n        onFrameAccumCountChange(count);\n      }\n    }\n  };\n\n  // Toggle accumulation mode\n  const toggleAccumulation = () => {\n    const newValue = !isAccumulating;\n    setIsAccumulating(newValue);\n    // Reset accumulated data when toggling\n    setAccumulatedFrames([]);\n    setAccumulatedData(null);\n\n    // Notify parent of change\n    if (onAccumulationToggle) {\n      onAccumulationToggle(newValue);\n    }\n  };\n\n  // Toggle calibration controls\n  const toggleCalibration = () => {\n    setShowCalibration(!showCalibration);\n  };\n\n  // Toggle using calibration\n  const toggleUseCalibration = () => {\n    setUseCalibration(!useCalibration);\n  };\n\n  // Toggle flip X axis\n  const toggleFlipXAxis = () => {\n    setFlipXAxis(!flipXAxis);\n  };\n\n  // Update calibration point\n  const updateCalibrationPoint = (index, field, value) => {\n    const numValue = parseFloat(value);\n    if (isNaN(numValue)) return;\n\n    // Format position values to 3 decimal places\n    const formattedValue = field === 'position' ? parseFloat(numValue.toFixed(3)) : numValue;\n    setCalibrationPoints(points => {\n      const newPoints = [...points];\n      newPoints[index] = {\n        ...newPoints[index],\n        [field]: formattedValue\n      };\n      return newPoints;\n    });\n  };\n\n  // Initialize and resize the canvas when graph size changes\n  useEffect(() => {\n    if (canvasRef.current) {\n      const canvas = canvasRef.current;\n      const container = graphContainerRef.current;\n      if (container) {\n        // Set canvas size to match container\n        canvas.width = container.clientWidth;\n        canvas.height = container.clientHeight;\n\n        // Redraw graph with new size\n        if (isAccumulating && accumulatedData) {\n          drawGraph(accumulatedData);\n        } else if (graphData) {\n          drawGraph(graphData);\n        }\n      }\n    }\n  }, [graphSize, graphData, accumulatedData, isAccumulating, useCalibration, calibrationPoints, flipXAxis]);\n\n  // Find peaks in data array\n  const findPeaks = (values, positions, count = 3) => {\n    if (!values || values.length < 3) return [];\n\n    // Find local maxima (points higher than both neighbors)\n    const peaks = [];\n    for (let i = 1; i < values.length - 1; i++) {\n      if (values[i] > values[i - 1] && values[i] > values[i + 1]) {\n        // This is a local maximum\n        const peak = {\n          index: i,\n          position: positions[i],\n          value: values[i]\n        };\n\n        // Refine position using quadratic interpolation for better accuracy\n        try {\n          // Based on three points around the peak\n          const x1 = positions[i - 1];\n          const x2 = positions[i];\n          const x3 = positions[i + 1];\n          const y1 = values[i - 1];\n          const y2 = values[i];\n          const y3 = values[i + 1];\n\n          // Only apply refinement if we have valid neighboring points\n          const denom = (x1 - x2) * (x1 - x3) * (x2 - x3);\n          if (denom !== 0) {\n            // Quadratic interpolation formula\n            const A = (x3 * (y2 - y1) + x2 * (y1 - y3) + x1 * (y3 - y2)) / denom;\n            const B = (x3 * x3 * (y1 - y2) + x2 * x2 * (y3 - y1) + x1 * x1 * (y2 - y3)) / denom;\n\n            // Calculate refined x position at the peak of the parabola\n            if (A !== 0) {\n              const refinedPos = -B / (2 * A);\n\n              // Only use refined position if it's within a reasonable range\n              if (refinedPos >= x1 && refinedPos <= x3) {\n                peak.refinedPosition = refinedPos;\n              }\n            }\n          }\n        } catch (e) {\n          console.warn('Error during peak refinement', e);\n          // If refinement fails, use the original position\n        }\n        peaks.push(peak);\n      }\n    }\n\n    // Sort peaks by value (descending)\n    peaks.sort((a, b) => b.value - a.value);\n\n    // Filter peaks to ensure they're at least 10nm apart (or equivalent in position space)\n    const filteredPeaks = [];\n\n    // Default position-based distance (approximately 5% of the position range)\n    const minPositionDistance = 0.05;\n    for (const peak of peaks) {\n      // Check if this peak is too close to any already-selected stronger peak\n      let tooClose = false;\n      for (const selectedPeak of filteredPeaks) {\n        // Use position-based distance (wavelength conversion will happen in the drawing code)\n        const distance = Math.abs(peak.position - selectedPeak.position);\n        if (distance < minPositionDistance) {\n          tooClose = true;\n          break;\n        }\n      }\n\n      // Add the peak if it's not too close to any stronger peak\n      if (!tooClose) {\n        filteredPeaks.push(peak);\n\n        // Stop if we have enough peaks\n        if (filteredPeaks.length >= count) {\n          break;\n        }\n      }\n    }\n    return filteredPeaks;\n  };\n\n  // Draw the graph based on pixel data\n  const drawGraph = data => {\n    if (!canvasRef.current || !data) return;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n\n    // Clear the canvas\n    ctx.clearRect(0, 0, width, height);\n\n    // Draw background\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';\n    ctx.fillRect(0, 0, width, height);\n\n    // Draw grid lines\n    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';\n    ctx.lineWidth = 1;\n\n    // Horizontal grid lines (at 25%, 50%, 75%)\n    for (let i = 1; i < 4; i++) {\n      const y = height * (i / 4);\n      ctx.beginPath();\n      ctx.moveTo(0, y);\n      ctx.lineTo(width, y);\n      ctx.stroke();\n    }\n\n    // Vertical grid lines (at 25%, 50%, 75%)\n    for (let i = 1; i < 4; i++) {\n      const x = width * (i / 4);\n      ctx.beginPath();\n      ctx.moveTo(x, 0);\n      ctx.lineTo(x, height);\n      ctx.stroke();\n    }\n\n    // Calculate min and max wavelength values for calibration upfront\n    let minWavelength, maxWavelength;\n    if (useCalibration && calibrationPoints.length >= 2) {\n      const wavelengths = calibrationPoints.map(p => p.wavelength);\n      minWavelength = Math.min(...wavelengths);\n      maxWavelength = Math.max(...wavelengths);\n    }\n\n    // Set line styles for different channels\n    const styles = {\n      red: {\n        color: 'rgba(255, 0, 0, 0.8)',\n        width: 1.5\n      },\n      green: {\n        color: 'rgba(0, 255, 0, 0.8)',\n        width: 1.5\n      },\n      blue: {\n        color: 'rgba(0, 0, 255, 0.8)',\n        width: 1.5\n      },\n      intensity: {\n        color: 'rgba(255, 255, 255, 0.8)',\n        width: 2\n      }\n    };\n\n    // Find max values for scaling\n    const maxRed = Math.max(...data.red, 1);\n    const maxGreen = Math.max(...data.green, 1);\n    const maxBlue = Math.max(...data.blue, 1);\n    const maxIntensity = Math.max(...data.intensity, 1);\n\n    // Store the peak data for each displayed channel\n    const channelPeaks = {};\n\n    // Plot each enabled channel\n    Object.entries(displayChannels).forEach(([channel, isEnabled]) => {\n      if (!isEnabled) return;\n      const values = data[channel];\n      const maxValue = channel === 'red' ? maxRed : channel === 'green' ? maxGreen : channel === 'blue' ? maxBlue : maxIntensity;\n\n      // Set line style\n      ctx.strokeStyle = styles[channel].color;\n      ctx.lineWidth = styles[channel].width;\n\n      // Begin the path\n      ctx.beginPath();\n\n      // Draw the line\n      for (let i = 0; i < values.length; i++) {\n        // Calculate x position, applying flip if enabled\n        let xPos = data.positions[i];\n        if (flipXAxis) {\n          xPos = 1 - xPos; // Invert position (0 becomes 1, 1 becomes 0)\n        }\n\n        // Convert to pixel coordinates\n        const x = xPos * width;\n\n        // Invert Y since canvas 0,0 is top-left\n        const y = height - values[i] / maxValue * height;\n        if (i === 0) {\n          ctx.moveTo(x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n      }\n\n      // Draw the path\n      ctx.stroke();\n    });\n\n    // Detect peaks for intensity channel only if enabled\n    if (showPeakMarkers && displayChannels.intensity) {\n      const intensityValues = data.intensity;\n      // Use original positions for peak detection\n      const peaks = findPeaks(intensityValues, data.positions, peakCount);\n\n      // If calibration is enabled, perform additional wavelength-based filtering\n      if (useCalibration) {\n        // Convert positions to wavelengths and filter to ensure 10nm minimum distance\n        const wavelengthPeaks = [];\n\n        // Process peaks in order of intensity (already sorted by findPeaks)\n        for (const peak of peaks) {\n          const peakWavelength = positionToWavelength(peak.position);\n          let tooClose = false;\n\n          // Check if this peak is too close to any already selected peak\n          for (const selectedPeak of wavelengthPeaks) {\n            const selectedWavelength = positionToWavelength(selectedPeak.position);\n            const distance = Math.abs(peakWavelength - selectedWavelength);\n            if (distance < 10) {\n              // 10nm minimum distance\n              tooClose = true;\n              break;\n            }\n          }\n\n          // Add the peak if it's not too close to any already selected peak\n          if (!tooClose) {\n            wavelengthPeaks.push(peak);\n          }\n        }\n        channelPeaks['intensity'] = wavelengthPeaks;\n      } else {\n        channelPeaks['intensity'] = peaks;\n      }\n    }\n\n    // Draw timestamp and status information\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n    ctx.font = '10px monospace';\n    ctx.textAlign = 'left';\n\n    // Show time and accumulation status\n    const timeText = `Time: ${new Date(data.timestamp).toLocaleTimeString()}`;\n    const statusText = isAccumulating ? `Accumulating: ${accumulatedFrames.length}/${frameAccumCount} frames` : 'Live data';\n    ctx.fillText(timeText, 5, 15);\n    ctx.fillText(statusText, width - 150, 15);\n\n    // Draw calibration status if enabled\n    if (useCalibration) {\n      ctx.fillText('Calibrated', width - 150, 45);\n    }\n\n    // Draw spectral correction status\n    const {\n      CHANNEL_RANGES\n    } = spectralConfig;\n    ctx.fillStyle = 'rgba(255, 200, 100, 0.9)';\n    ctx.fillText(`Spectral corrections applied`, 5, 75);\n\n    // Draw specific range info with colors matching the channels\n    ctx.fillStyle = styles.red.color;\n    ctx.fillText(`R: ${CHANNEL_RANGES.r[0].toFixed(1)}-${CHANNEL_RANGES.r[1].toFixed(1)}nm`, 5, 90);\n    ctx.fillStyle = styles.green.color;\n    ctx.fillText(`G: ${CHANNEL_RANGES.g[0].toFixed(1)}-${CHANNEL_RANGES.g[1].toFixed(1)}nm`, 5, 105);\n    ctx.fillStyle = styles.blue.color;\n    ctx.fillText(`B: ${CHANNEL_RANGES.b[0].toFixed(1)}-${CHANNEL_RANGES.b[1].toFixed(1)}nm`, 5, 120);\n\n    // Draw frame count if this is accumulated data\n    if (data.frameCount) {\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n      ctx.fillText(`Summed ${data.frameCount} frames`, width - 150, 30);\n    }\n\n    // Draw raw data and bit depth information if available\n    if (data.isRawData) {\n      const bitDepth = data.bitDepth || 12;\n      const dataType = data.dataType || 'raw';\n      ctx.fillStyle = 'rgba(255, 200, 100, 0.9)';\n      ctx.fillText(`RAW ${bitDepth}-bit | ${dataType}`, 5, 60);\n    }\n\n    // Draw channel legend\n    const legendStartY = 30;\n    const legendSpacing = 15;\n    if (displayChannels.red) {\n      ctx.fillStyle = styles.red.color;\n      // For raw data, show max value as well\n      if (data.isRawData) {\n        ctx.fillText(`Red: ${Math.round(data.red.reduce((a, b) => a + b, 0) / data.red.length)} (max: ${Math.round(maxRed)})`, 5, legendStartY);\n      } else {\n        ctx.fillText(`Red: ${Math.round(data.red.reduce((a, b) => a + b, 0) / data.red.length)}`, 5, legendStartY);\n      }\n    }\n    if (displayChannels.green) {\n      ctx.fillStyle = styles.green.color;\n      // For raw data, show max value as well\n      if (data.isRawData) {\n        ctx.fillText(`Green: ${Math.round(data.green.reduce((a, b) => a + b, 0) / data.green.length)} (max: ${Math.round(maxGreen)})`, 5, legendStartY + legendSpacing);\n      } else {\n        ctx.fillText(`Green: ${Math.round(data.green.reduce((a, b) => a + b, 0) / data.green.length)}`, 5, legendStartY + legendSpacing);\n      }\n    }\n    if (displayChannels.blue) {\n      ctx.fillStyle = styles.blue.color;\n      // For raw data, show max value as well\n      if (data.isRawData) {\n        ctx.fillText(`Blue: ${Math.round(data.blue.reduce((a, b) => a + b, 0) / data.blue.length)} (max: ${Math.round(maxBlue)})`, 5, legendStartY + legendSpacing * 2);\n      } else {\n        ctx.fillText(`Blue: ${Math.round(data.blue.reduce((a, b) => a + b, 0) / data.blue.length)}`, 5, legendStartY + legendSpacing * 2);\n      }\n    }\n    if (displayChannels.intensity) {\n      ctx.fillStyle = styles.intensity.color;\n      // For raw data, show max value as well\n      if (data.isRawData) {\n        ctx.fillText(`Intensity: ${(data.intensity.reduce((a, b) => a + b, 0) / data.intensity.length).toFixed(2)} (max: ${Math.round(maxIntensity)})`, 5, legendStartY + legendSpacing * 3);\n      } else {\n        ctx.fillText(`Intensity: ${(data.intensity.reduce((a, b) => a + b, 0) / data.intensity.length).toFixed(2)}`, 5, legendStartY + legendSpacing * 3);\n      }\n    }\n\n    // Draw wavelength axis labels if calibration is enabled (unified section)\n    if (useCalibration && minWavelength !== undefined && maxWavelength !== undefined) {\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';\n      ctx.font = '10px monospace';\n      ctx.textAlign = 'center';\n\n      // Clear the bottom area where labels will go\n      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; // Match background color\n      ctx.fillRect(0, height - 20, width, 20);\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'; // Reset text color\n\n      // Draw axis labels at regular position intervals (0%, 25%, 50%, 75%, 100%)\n      // but show the corresponding wavelength values\n      for (let i = 0; i <= 4; i++) {\n        const position = i / 4; // Regular positions (0, 0.25, 0.5, 0.75, 1)\n\n        // Apply flip if enabled\n        const displayPosition = flipXAxis ? 1 - position : position;\n        const x = displayPosition * width;\n\n        // Convert position to wavelength using calibration\n        const wavelength = positionToWavelength(position);\n        ctx.fillText(`${Math.round(wavelength)}nm`, x, height - 5);\n      }\n    }\n\n    // Draw calibration points if enabled\n    if (useCalibration) {\n      calibrationPoints.forEach(point => {\n        // Apply flip if enabled\n        const displayPosition = flipXAxis ? 1 - point.position : point.position;\n        // Draw vertical line at calibration point position\n        const x = displayPosition * width;\n        ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n        ctx.moveTo(x, 0);\n        ctx.lineTo(x, height);\n        ctx.stroke();\n\n        // Draw wavelength label at the calibration point\n        ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';\n        ctx.font = '10px monospace';\n        ctx.textAlign = 'center';\n        ctx.fillText(`${point.wavelength}nm`, x, height - 20); // Higher position to avoid overlap\n      });\n    }\n\n    // Draw peak markers if enabled\n    if (showPeakMarkers) {\n      // Draw peaks for each enabled channel\n      Object.entries(channelPeaks).forEach(([channel, peaks]) => {\n        // Use the same color as the channel with increased opacity\n        const baseColor = styles[channel].color;\n        const markerColor = baseColor.replace('rgba', 'rgb').replace(/,\\s*[\\d.]+\\)/, ')');\n\n        // Get max value for this channel for y-coordinate calculation\n        const maxValue = channel === 'red' ? maxRed : channel === 'green' ? maxGreen : channel === 'blue' ? maxBlue : maxIntensity;\n        peaks.forEach(peak => {\n          // Get the original position\n          let xPos = peak.position;\n\n          // Use refined position if available (within reasonable bounds)\n          if (peak.refinedPosition !== undefined) {\n            xPos = peak.refinedPosition;\n          }\n\n          // Apply flip if enabled\n          if (flipXAxis) {\n            xPos = 1 - xPos;\n          }\n\n          // Convert to pixel coordinates\n          const x = xPos * width;\n          const y = height - peak.value / maxValue * height;\n\n          // Check if peak is near the top of the graph (below a minimum distance from top)\n          const isNearTop = y < 60; // 60px from top\n\n          // Draw a vertical line first (always visible)\n          ctx.strokeStyle = markerColor;\n          ctx.setLineDash([2, 2]);\n          ctx.beginPath();\n          ctx.moveTo(x, y);\n          ctx.lineTo(x, height);\n          ctx.stroke();\n          ctx.setLineDash([]);\n\n          // Draw marker at peak position (triangle pointing down or up based on position)\n          ctx.fillStyle = markerColor;\n          ctx.beginPath();\n          if (isNearTop) {\n            // If near top, draw triangle pointing up from a position slightly below the peak\n            const markerY = y + 15;\n            ctx.moveTo(x, markerY);\n            ctx.lineTo(x - 5, markerY + 10);\n            ctx.lineTo(x + 5, markerY + 10);\n          } else {\n            // Normal case - draw triangle pointing down\n            ctx.moveTo(x, y);\n            ctx.lineTo(x - 5, y - 10);\n            ctx.lineTo(x + 5, y - 10);\n          }\n          ctx.closePath();\n          ctx.fill();\n\n          // Prepare label text\n          let label;\n          if (useCalibration) {\n            const wavelength = positionToWavelength(peak.position);\n            label = `${wavelength.toFixed(1)}nm`;\n          } else {\n            label = `Pos: ${peak.position.toFixed(3)}`;\n          }\n          const valueLabel = `I: ${peak.value.toFixed(1)}`;\n\n          // Setup text rendering\n          ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n          ctx.font = '10px monospace';\n          ctx.textAlign = 'center';\n\n          // Measure text dimensions for backgrounds\n          const textWidth = ctx.measureText(label).width + 6;\n          const valueWidth = ctx.measureText(valueLabel).width + 6;\n          if (isNearTop) {\n            // Draw position/wavelength label below the marker\n            const labelY = y + 30;\n\n            // Draw text background\n            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';\n            ctx.fillRect(x - textWidth / 2, labelY - 10, textWidth, 16);\n\n            // Draw label text\n            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n            ctx.fillText(label, x, labelY);\n\n            // Draw value label below that\n            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';\n            ctx.fillRect(x - valueWidth / 2, labelY + 7, valueWidth, 16);\n            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n            ctx.fillText(valueLabel, x, labelY + 17);\n          } else {\n            // Standard label position above marker\n            // Draw text background for better readability\n            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';\n            ctx.fillRect(x - textWidth / 2, y - 25, textWidth, 16);\n\n            // Draw label above marker\n            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n            ctx.fillText(label, x, y - 14);\n\n            // Draw peak value\n            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';\n            ctx.fillRect(x - valueWidth / 2, y - 42, valueWidth, 16);\n            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n            ctx.fillText(valueLabel, x, y - 31);\n          }\n        });\n      });\n    }\n\n    // Draw crosshair at cursor position\n    if (showCrosshair && cursorPosition) {\n      const {\n        x,\n        y\n      } = cursorPosition;\n      if (x >= 0 && x <= width && y >= 0 && y <= height) {\n        // Draw vertical line\n        ctx.beginPath();\n        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';\n        ctx.lineWidth = 1;\n        ctx.setLineDash([3, 3]); // Dashed line\n        ctx.moveTo(x, 0);\n        ctx.lineTo(x, height);\n        ctx.stroke();\n\n        // Draw horizontal line\n        ctx.beginPath();\n        ctx.moveTo(0, y);\n        ctx.lineTo(width, y);\n        ctx.stroke();\n        ctx.setLineDash([]); // Reset line style\n\n        // Calculate and display wavelength at cursor position\n        const position = x / width; // Normalize cursor position (0-1)\n\n        // Apply flip if needed to get the actual data position\n        const dataPosition = flipXAxis ? 1 - position : position;\n\n        // Determine wavelength based on cursor position\n        let wavelength;\n        if (useCalibration) {\n          wavelength = positionToWavelength(dataPosition);\n        } else {\n          wavelength = dataPosition; // Just show the position value when not calibrated\n        }\n\n        // Calculate y-values at the cursor position\n        let valueText = '';\n        if (data && data.positions && data.positions.length > 0) {\n          // Find the nearest data point to the cursor\n          const positionIndex = findNearestPositionIndex(data.positions, dataPosition);\n\n          // Build value text based on active channels\n          const channelTexts = [];\n          if (displayChannels.red) {\n            channelTexts.push(`R:${Math.round(data.red[positionIndex])}`);\n          }\n          if (displayChannels.green) {\n            channelTexts.push(`G:${Math.round(data.green[positionIndex])}`);\n          }\n          if (displayChannels.blue) {\n            channelTexts.push(`B:${Math.round(data.blue[positionIndex])}`);\n          }\n          if (displayChannels.intensity) {\n            channelTexts.push(`I:${data.intensity[positionIndex].toFixed(1)}`);\n          }\n          valueText = channelTexts.join(', ');\n        }\n\n        // Create a background for the text for better readability\n        const wavelengthText = useCalibration ? `${wavelength.toFixed(1)}nm` : `Pos: ${wavelength.toFixed(3)}`;\n\n        // Draw text background\n        const textWidth = ctx.measureText(wavelengthText).width + 10;\n        const valueTextWidth = ctx.measureText(valueText).width + 10;\n        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n        ctx.fillRect(x - textWidth / 2, height - 45, textWidth, 20);\n        if (valueText) {\n          ctx.fillRect(x - valueTextWidth / 2, 5, valueTextWidth, 20);\n        }\n\n        // Draw wavelength text below cursor\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n        ctx.textAlign = 'center';\n        ctx.fillText(wavelengthText, x, height - 30);\n\n        // Draw value text above cursor\n        if (valueText) {\n          ctx.fillText(valueText, x, 20);\n        }\n      }\n    }\n  };\n\n  // Helper to find the index of the nearest position value to a given position\n  const findNearestPositionIndex = (positions, targetPosition) => {\n    if (!positions || positions.length === 0) return -1;\n    let nearestIndex = 0;\n    let minDistance = Math.abs(positions[0] - targetPosition);\n    for (let i = 1; i < positions.length; i++) {\n      const distance = Math.abs(positions[i] - targetPosition);\n      if (distance < minDistance) {\n        minDistance = distance;\n        nearestIndex = i;\n      }\n    }\n    return nearestIndex;\n  };\n\n  // Toggle display of a specific channel\n  const toggleChannel = channel => {\n    setDisplayChannels(prev => ({\n      ...prev,\n      [channel]: !prev[channel]\n    }));\n  };\n\n  // Handle mouse movement over the graph\n  const handleMouseMove = e => {\n    if (!graphContainerRef.current) return;\n\n    // Get canvas bounds\n    const rect = graphContainerRef.current.getBoundingClientRect();\n\n    // Calculate cursor position relative to canvas\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n\n    // Update cursor position state\n    setCursorPosition({\n      x,\n      y\n    });\n\n    // Redraw the graph with crosshair\n    if (isAccumulating && accumulatedData) {\n      drawGraph(accumulatedData);\n    } else if (graphData) {\n      drawGraph(graphData);\n    }\n  };\n\n  // Handle mouse enter/leave events\n  const handleMouseEnter = () => {\n    setShowCrosshair(true);\n  };\n  const handleMouseLeave = () => {\n    setShowCrosshair(false);\n    setCursorPosition(null);\n\n    // Redraw the graph without crosshair\n    if (isAccumulating && accumulatedData) {\n      drawGraph(accumulatedData);\n    } else if (graphData) {\n      drawGraph(graphData);\n    }\n  };\n\n  // Similar resize functionality as before\n  const handleResizeStart = e => {\n    var _graphContainerRef$cu, _graphContainerRef$cu2;\n    e.preventDefault();\n    e.stopPropagation();\n\n    // Get initial coordinates and size\n    const startX = e.clientX;\n    const startY = e.clientY;\n    const startWidth = ((_graphContainerRef$cu = graphContainerRef.current) === null || _graphContainerRef$cu === void 0 ? void 0 : _graphContainerRef$cu.clientWidth) || 400;\n    const startHeight = ((_graphContainerRef$cu2 = graphContainerRef.current) === null || _graphContainerRef$cu2 === void 0 ? void 0 : _graphContainerRef$cu2.clientHeight) || graphSize.height;\n\n    // Show resize feedback\n    setIsResizing(true);\n    setShowResizeInfo(true);\n\n    // Define move handler\n    function handleMouseMove(moveEvent) {\n      const deltaY = moveEvent.clientY - startY;\n\n      // Only adjust height, keep width as 100%\n      const newHeight = Math.max(100, startHeight + deltaY);\n\n      // Update graph size\n      const newSize = {\n        width: '100%',\n        // Keep width as 100% for responsive behavior\n        height: Math.round(newHeight)\n      };\n      setGraphSize(newSize);\n\n      // Notify parent if needed\n      if (onResize) {\n        onResize(newSize);\n      }\n\n      // Prevent default to avoid text selection during resize\n      moveEvent.preventDefault();\n    }\n\n    // Define up handler\n    function handleMouseUp() {\n      // Clean up\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n      setIsResizing(false);\n      setTimeout(() => setShowResizeInfo(false), 800);\n    }\n\n    // Attach handlers to document to capture events outside component\n    document.addEventListener('mousemove', handleMouseMove);\n    document.addEventListener('mouseup', handleMouseUp);\n  };\n\n  // Export settings to JSON file\n  const exportSettings = () => {\n    try {\n      // fill this gap\n    } catch (error) {\n      console.error('Failed to export settings:', error);\n      setSaveMessage('Error exporting settings');\n      setTimeout(() => setSaveMessage(''), 3000);\n    }\n  };\n\n  // Export graph data as text file\n  const exportGraphData = () => {\n    // Make sure we have data to export\n    const dataToExport = isAccumulating ? accumulatedData : graphData;\n    if (!dataToExport) {\n      console.warn('No data to export');\n      if (props.onMessage) {\n        props.onMessage('No data to export');\n      }\n      return;\n    }\n    try {\n      const lines = [];\n      // Create a timestamp string with units separated by semicolons: YYYY;MM;DD;hh;mm;ss\n      const now = new Date();\n      const timestamp = now.getFullYear() + ';' + String(now.getMonth() + 1).padStart(2, '0') + ';' + String(now.getDate()).padStart(2, '0') + ';' + String(now.getHours()).padStart(2, '0') + ';' + String(now.getMinutes()).padStart(2, '0') + ';' + String(now.getSeconds()).padStart(2, '0');\n      lines.push(timestamp);\n\n      // Add raw data metadata if available\n      if (dataToExport.isRawData) {\n        const bitDepth = dataToExport.bitDepth || 12;\n        const dataType = dataToExport.dataType || 'raw';\n        lines.push(`# RAW DATA: ${bitDepth}-bit, type: ${dataType}`);\n      }\n\n      // Add information about frame accumulation\n      if (dataToExport.frameCount) {\n        lines.push(`# Accumulated frames: ${dataToExport.frameCount}`);\n      }\n\n      // Add information about memorized data if available\n      if (memorizedData.length > 0) {\n        lines.push(`# Memory entries: ${memorizedData.length}`);\n      }\n\n      // Add column headers with memory columns if available\n      let headers = useCalibration ? \"Wavelength (nm);Intensity;Red;Green;Blue\" : \"Position;Intensity;Red;Green;Blue\";\n\n      // Add headers for memorized data\n      if (memorizedData.length > 0) {\n        memorizedData.forEach((_, index) => {\n          headers += `;Memory${index + 1}_Intensity;Memory${index + 1}_Red;Memory${index + 1}_Green;Memory${index + 1}_Blue`;\n        });\n      }\n      lines.push(headers);\n\n      // Loop through data points\n      for (let i = 0; i < dataToExport.positions.length; i++) {\n        let position = dataToExport.positions[i];\n        // Convert position to wavelength if calibration is enabled\n        let wavelength = position;\n        if (useCalibration) {\n          wavelength = positionToWavelength(position);\n        }\n\n        // Get all channel values for current data\n        const intensity = dataToExport.intensity[i];\n        const red = dataToExport.red[i];\n        const green = dataToExport.green[i];\n        const blue = dataToExport.blue[i];\n\n        // Start the line with current data\n        let line = `${wavelength.toFixed(3)};${intensity.toFixed(2)};${red.toFixed(2)};${green.toFixed(2)};${blue.toFixed(2)}`;\n\n        // Add memorized data if available\n        if (memorizedData.length > 0) {\n          memorizedData.forEach(memData => {\n            // Find the closest position in the memorized data\n            const memIndex = findNearestPositionIndex(memData.positions, position);\n            if (memIndex >= 0) {\n              const memIntensity = memData.intensity[memIndex];\n              const memRed = memData.red[memIndex];\n              const memGreen = memData.green[memIndex];\n              const memBlue = memData.blue[memIndex];\n\n              // Add to the line\n              line += `;${memIntensity.toFixed(2)};${memRed.toFixed(2)};${memGreen.toFixed(2)};${memBlue.toFixed(2)}`;\n            } else {\n              // If no matching position found, add empty values\n              line += `;0;0;0;0`;\n            }\n          });\n        }\n\n        // Add line with all values\n        lines.push(line);\n      }\n\n      // Join lines with newlines\n      const content = lines.join('\\n');\n\n      // Create filename with prefix and optional timestamp\n      // For raw data, add raw indicator to filename\n      let fileName = '';\n      if (dataToExport.isRawData) {\n        fileName = includeDateInFilename ? `${filePrefix}_RAW${dataToExport.bitDepth || 12}bit_${timestamp}.txt` : `${filePrefix}_RAW${dataToExport.bitDepth || 12}bit.txt`;\n      } else {\n        fileName = includeDateInFilename ? `${filePrefix}_${timestamp}.txt` : `${filePrefix}.txt`;\n      }\n\n      // Create Blob with content\n      const blob = new Blob([content], {\n        type: 'text/plain'\n      });\n\n      // Create download link\n      const url = URL.createObjectURL(blob);\n      const link = document.createElement('a');\n      link.href = url;\n      link.download = fileName;\n\n      // Append to document, click, and remove\n      document.body.appendChild(link);\n      link.click();\n\n      // Clean up\n      setTimeout(() => {\n        document.body.removeChild(link);\n        URL.revokeObjectURL(url);\n      }, 100);\n\n      // Show success message\n      if (props.onMessage) {\n        props.onMessage(`Data exported as ${fileName}`);\n      } else {\n        // If no message handler provided, show alert\n        console.log(`Data exported as ${fileName}`);\n        setSaveMessage && setSaveMessage(`Data exported as ${fileName}`);\n        setTimeout(() => setSaveMessage && setSaveMessage(''), 3000);\n      }\n    } catch (error) {\n      console.error('Failed to export graph data:', error);\n      if (props.onMessage) {\n        props.onMessage('Error exporting data');\n      } else {\n        setSaveMessage && setSaveMessage('Error exporting data');\n        setTimeout(() => setSaveMessage && setSaveMessage(''), 3000);\n      }\n    }\n  };\n\n  // Load saved camera and calibration settings\n  const loadSettings = () => {\n    // fill this gap\n  };\n\n  // Handle peak count change\n  const handlePeakCountChange = e => {\n    const count = parseInt(e.target.value);\n    if (!isNaN(count) && count >= 0 && count <= 10) {\n      setPeakCount(count);\n    }\n  };\n\n  // Toggle peak markers\n  const togglePeakMarkers = () => {\n    setShowPeakMarkers(!showPeakMarkers);\n  };\n  const styles = {\n    container: {\n      backgroundColor: 'rgba(0, 0, 0, 0.2)',\n      padding: '10px',\n      borderRadius: '4px',\n      position: 'relative',\n      border: isResizing ? '1px dashed #4CAF50' : 'none'\n    },\n    title: {\n      margin: '0 0 10px 0',\n      fontSize: '14px',\n      display: 'flex',\n      justifyContent: 'space-between',\n      alignItems: 'center'\n    },\n    controls: {\n      display: 'flex',\n      gap: '5px',\n      alignItems: 'center'\n    },\n    frameCountControl: {\n      display: 'flex',\n      alignItems: 'center',\n      marginBottom: '10px',\n      gap: '8px'\n    },\n    frameCountLabel: {\n      fontSize: '12px',\n      color: 'rgba(255, 255, 255, 0.8)'\n    },\n    frameCountInput: {\n      width: '50px',\n      padding: '2px 4px',\n      backgroundColor: 'rgba(30, 30, 30, 0.8)',\n      color: 'white',\n      border: '1px solid rgba(80, 80, 80, 0.5)',\n      borderRadius: '3px',\n      fontSize: '12px'\n    },\n    calibrationContainer: {\n      marginBottom: '10px',\n      padding: '8px',\n      backgroundColor: 'rgba(0, 0, 0, 0.3)',\n      borderRadius: '4px'\n    },\n    calibrationHeader: {\n      display: 'flex',\n      justifyContent: 'space-between',\n      alignItems: 'center',\n      marginBottom: '8px'\n    },\n    calibrationTitle: {\n      fontSize: '12px',\n      color: 'rgba(255, 255, 255, 0.9)',\n      margin: 0\n    },\n    calibrationCheckbox: {\n      marginLeft: '8px'\n    },\n    calibrationPoints: {\n      display: 'flex',\n      flexDirection: 'row',\n      flexWrap: 'wrap',\n      gap: '10px'\n    },\n    calibrationPointsColumn: {\n      display: 'flex',\n      flexDirection: 'column',\n      gap: '6px'\n    },\n    calibrationPointsRow: {\n      display: 'flex',\n      alignItems: 'center',\n      gap: '6px'\n    },\n    calibrationLabel: {\n      fontSize: '11px',\n      color: 'rgba(255, 255, 255, 0.7)',\n      width: '40px'\n    },\n    calibrationInput: {\n      width: '60px',\n      padding: '2px 4px',\n      backgroundColor: 'rgba(30, 30, 30, 0.8)',\n      color: 'white',\n      border: '1px solid rgba(80, 80, 80, 0.5)',\n      borderRadius: '3px',\n      fontSize: '11px'\n    },\n    graphView: {\n      width: graphSize.width,\n      height: `${graphSize.height}px`,\n      backgroundColor: 'rgba(0, 0, 0, 0.5)',\n      position: 'relative',\n      overflow: 'hidden'\n    },\n    canvas: {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%'\n    },\n    resizeHandle: {\n      position: 'absolute',\n      bottom: '0',\n      right: '0',\n      width: '20px',\n      height: '20px',\n      cursor: 'ns-resize',\n      // Only allow vertical resizing\n      zIndex: 100,\n      display: 'flex',\n      justifyContent: 'center',\n      alignItems: 'center',\n      backgroundColor: 'rgba(60, 60, 60, 0.8)',\n      borderTop: '1px solid rgba(180, 180, 180, 0.7)',\n      borderLeft: '1px solid rgba(180, 180, 180, 0.7)',\n      borderTopLeftRadius: '4px'\n    },\n    resizeInfo: {\n      position: 'absolute',\n      right: '25px',\n      bottom: '25px',\n      padding: '2px 6px',\n      background: 'rgba(0, 0, 0, 0.7)',\n      color: 'white',\n      borderRadius: '3px',\n      fontSize: '11px',\n      zIndex: 100\n    },\n    channelToggles: {\n      display: 'flex',\n      gap: '5px'\n    },\n    channelButton: {\n      fontSize: '10px',\n      padding: '2px 5px',\n      borderRadius: '3px',\n      cursor: 'pointer',\n      border: '1px solid rgba(255, 255, 255, 0.3)',\n      backgroundColor: 'rgba(30, 30, 30, 0.7)'\n    },\n    noData: {\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'center',\n      height: '100%',\n      color: 'rgba(255, 255, 255, 0.5)',\n      fontSize: '12px'\n    },\n    memoryButton: {\n      ...buttonVariants.smallIconButton,\n      backgroundColor: 'rgba(100, 160, 100, 0.7)',\n      marginRight: '5px',\n      fontSize: '11px',\n      padding: '3px 6px'\n    },\n    memoryButtons: {\n      display: 'flex',\n      alignItems: 'center',\n      marginRight: '5px',\n      borderRight: '1px solid rgba(255, 255, 255, 0.2)',\n      paddingRight: '5px'\n    },\n    memoryCount: {\n      fontSize: '10px',\n      backgroundColor: 'rgba(80, 120, 80, 0.5)',\n      padding: '1px 5px',\n      borderRadius: '10px',\n      marginLeft: '5px'\n    }\n  };\n\n  // Return the component JSX\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: styles.container,\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      style: styles.title,\n      children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n        style: {\n          margin: 0\n        },\n        children: \"Intensity Graph\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1563,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: styles.channelToggles,\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          style: {\n            ...styles.channelButton,\n            color: displayChannels.red ? 'rgb(255, 100, 100)' : 'rgba(255, 100, 100, 0.4)',\n            borderColor: displayChannels.red ? 'rgb(255, 100, 100)' : 'rgba(255, 100, 100, 0.2)'\n          },\n          onClick: () => toggleChannel('red'),\n          children: \"R\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1565,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          style: {\n            ...styles.channelButton,\n            color: displayChannels.green ? 'rgb(100, 255, 100)' : 'rgba(100, 255, 100, 0.4)',\n            borderColor: displayChannels.green ? 'rgb(100, 255, 100)' : 'rgba(100, 255, 100, 0.2)'\n          },\n          onClick: () => toggleChannel('green'),\n          children: \"G\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1575,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          style: {\n            ...styles.channelButton,\n            color: displayChannels.blue ? 'rgb(100, 100, 255)' : 'rgba(100, 100, 255, 0.4)',\n            borderColor: displayChannels.blue ? 'rgb(100, 100, 255)' : 'rgba(100, 100, 255, 0.2)'\n          },\n          onClick: () => toggleChannel('blue'),\n          children: \"B\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1585,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          style: {\n            ...styles.channelButton,\n            color: displayChannels.intensity ? 'rgb(220, 220, 220)' : 'rgba(220, 220, 220, 0.4)',\n            borderColor: displayChannels.intensity ? 'rgb(220, 220, 220)' : 'rgba(220, 220, 220, 0.2)'\n          },\n          onClick: () => toggleChannel('intensity'),\n          children: \"I\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1595,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          style: {\n            ...styles.channelButton,\n            color: 'rgb(255, 255, 100)',\n            borderColor: showCalibration ? 'rgb(255, 255, 100)' : 'rgba(255, 255, 100, 0.2)',\n            backgroundColor: showCalibration ? 'rgba(60, 60, 0, 0.6)' : 'rgba(30, 30, 30, 0.7)'\n          },\n          onClick: toggleCalibration,\n          title: \"Toggle calibration controls\",\n          children: \"Cal\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1605,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1564,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1562,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: styles.frameCountControl,\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        style: styles.frameCountLabel,\n        children: \"Frame accumulation:\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1621,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n        type: \"number\",\n        min: \"1\",\n        max: \"2000\",\n        value: frameAccumCount,\n        onChange: handleFrameCountChange,\n        style: styles.frameCountInput\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1622,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        style: {\n          ...buttonVariants.smallIconButton,\n          backgroundColor: isAccumulating ? 'rgba(255, 165, 0, 0.7)' : undefined\n        },\n        onClick: toggleAccumulation,\n        title: isAccumulating ? \"Switch to live data\" : \"Switch to frame accumulation\",\n        children: isAccumulating ? \"Accumulating\" : \"Live\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1630,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          display: 'flex',\n          alignItems: 'center',\n          gap: '5px',\n          marginLeft: '20px',\n          borderLeft: '1px solid rgba(255, 255, 255, 0.2)',\n          paddingLeft: '10px'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          style: styles.frameCountLabel,\n          children: \"Peak markers:\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1652,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"number\",\n          min: \"0\",\n          max: \"10\",\n          value: peakCount,\n          onChange: handlePeakCountChange,\n          style: styles.frameCountInput,\n          title: \"Number of peak markers to display\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1653,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          style: {\n            ...buttonVariants.smallIconButton,\n            backgroundColor: showPeakMarkers ? 'rgba(120, 120, 220, 0.7)' : undefined\n          },\n          onClick: togglePeakMarkers,\n          title: showPeakMarkers ? \"Hide peak markers\" : \"Show peak markers\",\n          children: showPeakMarkers ? \"Peaks On\" : \"Peaks Off\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1662,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1644,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          display: 'flex',\n          marginLeft: 'auto',\n          alignItems: 'center',\n          gap: '5px'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          style: styles.memoryButtons,\n          children: [/*#__PURE__*/_jsxDEV(\"button\", {\n            style: styles.memoryButton,\n            onClick: addToMemory,\n            title: \"Save current graph data to memory\",\n            disabled: !graphData && !accumulatedData,\n            children: \"To Memory\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1678,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            style: {\n              ...styles.memoryButton,\n              backgroundColor: 'rgba(180, 80, 80, 0.7)'\n            },\n            onClick: clearMemory,\n            title: \"Clear all memorized data\",\n            disabled: memorizedData.length === 0,\n            children: \"Clear Memory\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1686,\n            columnNumber: 13\n          }, this), memorizedData.length > 0 && /*#__PURE__*/_jsxDEV(\"span\", {\n            style: styles.memoryCount,\n            children: memorizedData.length\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1698,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1677,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"text\",\n          value: filePrefix,\n          onChange: e => setFilePrefix(e.target.value),\n          placeholder: \"File prefix\",\n          style: {\n            ...styles.frameCountInput,\n            width: '100px'\n          },\n          title: \"Prefix for the exported data filename\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1704,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"label\", {\n          style: {\n            fontSize: '11px',\n            color: 'rgba(255, 255, 255, 0.7)',\n            display: 'flex',\n            alignItems: 'center',\n            gap: '3px',\n            marginRight: '5px'\n          },\n          children: [/*#__PURE__*/_jsxDEV(\"input\", {\n            type: \"checkbox\",\n            checked: includeDateInFilename,\n            onChange: e => setIncludeDateInFilename(e.target.checked),\n            style: {\n              margin: 0\n            }\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1723,\n            columnNumber: 13\n          }, this), \"Date\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1715,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          style: {\n            ...buttonVariants.smallSecondary,\n            backgroundColor: 'rgba(20, 120, 220, 0.7)'\n          },\n          onClick: exportGraphData,\n          title: \"Export graph data as text file\",\n          disabled: !graphData && !accumulatedData,\n          children: \"\\uD83D\\uDCBE Export Data\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1731,\n          columnNumber: 11\n        }, this), saveMessage && /*#__PURE__*/_jsxDEV(\"span\", {\n          style: {\n            fontSize: '11px',\n            backgroundColor: 'rgba(0, 0, 0, 0.6)',\n            padding: '2px 6px',\n            borderRadius: '3px',\n            marginLeft: '5px',\n            color: 'rgba(255, 255, 255, 0.9)'\n          },\n          children: saveMessage\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1744,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1675,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1620,\n      columnNumber: 7\n    }, this), showCalibration && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: styles.calibrationContainer,\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        style: styles.calibrationHeader,\n        children: [/*#__PURE__*/_jsxDEV(\"h4\", {\n          style: styles.calibrationTitle,\n          children: \"Wavelength Calibration\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1761,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          children: /*#__PURE__*/_jsxDEV(\"label\", {\n            style: {\n              fontSize: '11px',\n              color: 'rgba(255, 255, 255, 0.7)'\n            },\n            children: [/*#__PURE__*/_jsxDEV(\"input\", {\n              type: \"checkbox\",\n              checked: useCalibration,\n              onChange: toggleUseCalibration,\n              style: styles.calibrationCheckbox\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1764,\n              columnNumber: 17\n            }, this), \"Use Calibration\"]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1763,\n            columnNumber: 15\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1762,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1760,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: styles.calibrationPoints,\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          style: styles.calibrationPointsColumn,\n          children: calibrationPoints.map((point, index) => /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.calibrationPointsRow,\n            children: /*#__PURE__*/_jsxDEV(\"div\", {\n              style: styles.calibrationLabel,\n              children: [\"Point \", index + 1, \":\"]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 1779,\n              columnNumber: 19\n            }, this)\n          }, `point-${index}`, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1778,\n            columnNumber: 17\n          }, this))\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1776,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: styles.calibrationPointsColumn,\n          children: calibrationPoints.map((point, index) => /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.calibrationPointsRow,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              style: {\n                fontSize: '11px',\n                color: 'rgba(255, 255, 255, 0.7)',\n                marginRight: '4px'\n              },\n              children: \"Pos:\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1787,\n              columnNumber: 19\n            }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n              type: \"number\",\n              min: \"0\",\n              max: \"1\",\n              step: \"0.0001\",\n              value: point.position,\n              onChange: e => updateCalibrationPoint(index, 'position', e.target.value),\n              style: styles.calibrationInput\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1788,\n              columnNumber: 19\n            }, this)]\n          }, `pos-${index}`, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1786,\n            columnNumber: 17\n          }, this))\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1784,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: styles.calibrationPointsColumn,\n          children: calibrationPoints.map((point, index) => /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.calibrationPointsRow,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              style: {\n                fontSize: '11px',\n                color: 'rgba(255, 255, 255, 0.7)',\n                marginRight: '4px'\n              },\n              children: \"\\u03BB:\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1804,\n              columnNumber: 19\n            }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n              type: \"number\",\n              min: \"200\",\n              max: \"1200\",\n              step: \"0.01\",\n              value: point.wavelength,\n              onChange: e => updateCalibrationPoint(index, 'wavelength', e.target.value),\n              style: styles.calibrationInput\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1805,\n              columnNumber: 19\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: {\n                fontSize: '11px',\n                color: 'rgba(255, 255, 255, 0.7)',\n                marginLeft: '2px'\n              },\n              children: \"nm\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1814,\n              columnNumber: 19\n            }, this)]\n          }, `wavelength-${index}`, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1803,\n            columnNumber: 17\n          }, this))\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1801,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            marginLeft: 'auto',\n            display: 'flex',\n            alignItems: 'center'\n          },\n          children: /*#__PURE__*/_jsxDEV(\"label\", {\n            style: {\n              fontSize: '11px',\n              color: 'rgba(255, 255, 255, 0.7)',\n              display: 'flex',\n              alignItems: 'center'\n            },\n            children: [/*#__PURE__*/_jsxDEV(\"input\", {\n              type: \"checkbox\",\n              checked: flipXAxis,\n              onChange: toggleFlipXAxis,\n              style: {\n                marginRight: '5px'\n              }\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1821,\n              columnNumber: 17\n            }, this), \"Flip X-Axis\"]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1820,\n            columnNumber: 15\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1819,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1775,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1759,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      ref: graphContainerRef,\n      style: styles.graphView,\n      onMouseMove: handleMouseMove,\n      onMouseEnter: handleMouseEnter,\n      onMouseLeave: handleMouseLeave,\n      children: [/*#__PURE__*/_jsxDEV(\"canvas\", {\n        ref: canvasRef,\n        style: styles.canvas\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1841,\n        columnNumber: 9\n      }, this), !graphData && !accumulatedData && /*#__PURE__*/_jsxDEV(\"div\", {\n        style: styles.noData,\n        children: \"Draw a line on the camera feed to see intensity data\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1847,\n        columnNumber: 11\n      }, this), showResizeInfo && /*#__PURE__*/_jsxDEV(\"div\", {\n        style: styles.resizeInfo,\n        children: [\"Height: \", graphSize.height, \"px\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1854,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: styles.resizeHandle,\n        onMouseDown: handleResizeStart,\n        title: \"Resize graph height\",\n        children: /*#__PURE__*/_jsxDEV(\"svg\", {\n          width: \"12\",\n          height: \"12\",\n          viewBox: \"0 0 12 12\",\n          children: /*#__PURE__*/_jsxDEV(\"path\", {\n            d: \"M2,6 L10,6 M2,9 L10,9\",\n            stroke: \"white\",\n            strokeWidth: \"1.5\",\n            strokeLinecap: \"round\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1866,\n            columnNumber: 13\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1865,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1860,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1834,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 1561,\n    columnNumber: 5\n  }, this);\n}, \"0x1EHAswbhsi/HAEwx3Xc5lLUY4=\", false, function () {\n  return [useButtonStyles];\n})), \"0x1EHAswbhsi/HAEwx3Xc5lLUY4=\", false, function () {\n  return [useButtonStyles];\n});\n\n// Add display name for debugging\n_c2 = GraphComponent;\nGraphComponent.displayName = 'GraphComponent';\nexport default GraphComponent;\nvar _c, _c2;\n$RefreshReg$(_c, \"GraphComponent$React.forwardRef\");\n$RefreshReg$(_c2, \"GraphComponent\");","map":{"version":3,"names":["React","useState","useRef","useEffect","useImperativeHandle","useButtonStyles","spectralConfig","jsxDEV","_jsxDEV","GraphComponent","_s","forwardRef","_c","props","ref","onResize","lineData","onFrameAccumCountChange","onAccumulationToggle","buttonVariants","graphSize","setGraphSize","width","height","isResizing","setIsResizing","showResizeInfo","setShowResizeInfo","displayChannels","setDisplayChannels","red","green","blue","intensity","graphData","setGraphData","memorizedData","setMemorizedData","cursorPosition","setCursorPosition","showCrosshair","setShowCrosshair","frameAccumCount","setFrameAccumCount","accumulatedFrames","setAccumulatedFrames","accumulatedData","setAccumulatedData","isAccumulating","setIsAccumulating","filePrefix","setFilePrefix","includeDateInFilename","setIncludeDateInFilename","saveMessage","setSaveMessage","showPeakMarkers","setShowPeakMarkers","peakCount","setPeakCount","showCalibration","setShowCalibration","calibrationPoints","setCalibrationPoints","position","wavelength","useCalibration","setUseCalibration","flipXAxis","setFlipXAxis","graphContainerRef","canvasRef","getCalibrationSettings","applyCalibrationSettings","settings","Array","isArray","error","console","getPeakSettings","count","showMarkers","applyPeakSettings","processRawSpectralData","rawData","timestamp","wavelengths","processedData","Date","now","positions","lineLength","length","isRawData","bitDepth","bit_depth","dataType","data_type","calculateIntensityWithCorrections","redData","greenData","blueData","CHANNEL_RANGES","SENSITIVITY_FACTORS","redRange","r","greenRange","g","blueRange","b","sensitivityWavelengths","Object","keys","map","Number","fill","i","sum","closestWavelength","findClosestWavelength","sensitivityFactor","toString","targetWavelength","closest","minDiff","Math","abs","diff","pixelData","graph_data","prev","newFrames","summedData","sumFrameData","drawGraph","addToMemory","dataToMemorize","setTimeout","memorizedItem","memoryTimestamp","toISOString","clearMemory","frames","template","summedRed","summedGreen","summedBlue","summedIntensity","forEach","frame","val","frameCount","positionToWavelength","sortedPoints","sort","a","p1","p2","slope","t","handleFrameCountChange","e","parseInt","target","value","isNaN","toggleAccumulation","newValue","toggleCalibration","toggleUseCalibration","toggleFlipXAxis","updateCalibrationPoint","index","field","numValue","parseFloat","formattedValue","toFixed","points","newPoints","current","canvas","container","clientWidth","clientHeight","findPeaks","values","peaks","peak","x1","x2","x3","y1","y2","y3","denom","A","B","refinedPos","refinedPosition","warn","push","filteredPeaks","minPositionDistance","tooClose","selectedPeak","distance","data","ctx","getContext","clearRect","fillStyle","fillRect","strokeStyle","lineWidth","y","beginPath","moveTo","lineTo","stroke","x","minWavelength","maxWavelength","p","min","max","styles","color","maxRed","maxGreen","maxBlue","maxIntensity","channelPeaks","entries","channel","isEnabled","maxValue","xPos","intensityValues","wavelengthPeaks","peakWavelength","selectedWavelength","font","textAlign","timeText","toLocaleTimeString","statusText","fillText","legendStartY","legendSpacing","round","reduce","undefined","displayPosition","point","baseColor","markerColor","replace","isNearTop","setLineDash","markerY","closePath","label","valueLabel","textWidth","measureText","valueWidth","labelY","dataPosition","valueText","positionIndex","findNearestPositionIndex","channelTexts","join","wavelengthText","valueTextWidth","targetPosition","nearestIndex","minDistance","toggleChannel","handleMouseMove","rect","getBoundingClientRect","clientX","left","clientY","top","handleMouseEnter","handleMouseLeave","handleResizeStart","_graphContainerRef$cu","_graphContainerRef$cu2","preventDefault","stopPropagation","startX","startY","startWidth","startHeight","moveEvent","deltaY","newHeight","newSize","handleMouseUp","document","removeEventListener","addEventListener","exportSettings","exportGraphData","dataToExport","onMessage","lines","getFullYear","String","getMonth","padStart","getDate","getHours","getMinutes","getSeconds","headers","_","line","memData","memIndex","memIntensity","memRed","memGreen","memBlue","content","fileName","blob","Blob","type","url","URL","createObjectURL","link","createElement","href","download","body","appendChild","click","removeChild","revokeObjectURL","log","loadSettings","handlePeakCountChange","togglePeakMarkers","backgroundColor","padding","borderRadius","border","title","margin","fontSize","display","justifyContent","alignItems","controls","gap","frameCountControl","marginBottom","frameCountLabel","frameCountInput","calibrationContainer","calibrationHeader","calibrationTitle","calibrationCheckbox","marginLeft","flexDirection","flexWrap","calibrationPointsColumn","calibrationPointsRow","calibrationLabel","calibrationInput","graphView","overflow","resizeHandle","bottom","right","cursor","zIndex","borderTop","borderLeft","borderTopLeftRadius","resizeInfo","background","channelToggles","channelButton","noData","memoryButton","smallIconButton","marginRight","memoryButtons","borderRight","paddingRight","memoryCount","style","children","_jsxFileName","lineNumber","columnNumber","borderColor","onClick","onChange","paddingLeft","disabled","placeholder","checked","smallSecondary","step","onMouseMove","onMouseEnter","onMouseLeave","onMouseDown","viewBox","d","strokeWidth","strokeLinecap","_c2","displayName","$RefreshReg$"],"sources":["E:/flow chemistry/fluidicGUI/frontend/fluidicgui/src/components/Simulation/SpectrometerMQTT/MQTTGraphComponent.js"],"sourcesContent":["import React, { useState, useRef, useEffect, useImperativeHandle } from 'react';\nimport { useButtonStyles } from '../../../styles/ButtonStyleProvider';\nimport spectralConfig from './spectral_config.json';\n\nconst GraphComponent = React.forwardRef((props, ref) => {\n  const { onResize, lineData, onFrameAccumCountChange, onAccumulationToggle } = props;\n  const buttonVariants = useButtonStyles();\n  const [graphSize, setGraphSize] = useState({ width: '100%', height: 200 });\n  const [isResizing, setIsResizing] = useState(false);\n  const [showResizeInfo, setShowResizeInfo] = useState(false);\n  const [displayChannels, setDisplayChannels] = useState({\n    red: false,\n    green: false,\n    blue: false,\n    intensity: true\n  });\n  const [graphData, setGraphData] = useState(null);\n  \n  // Memory for storing graph data\n  const [memorizedData, setMemorizedData] = useState([]);\n  \n  // Cursor tracking state\n  const [cursorPosition, setCursorPosition] = useState(null);\n  const [showCrosshair, setShowCrosshair] = useState(false);\n  \n  // Frame accumulation state - internally managed but synced with parent\n  const [frameAccumCount, setFrameAccumCount] = useState(10); // Default to 10 frames\n  const [accumulatedFrames, setAccumulatedFrames] = useState([]);\n  const [accumulatedData, setAccumulatedData] = useState(null);\n  const [isAccumulating, setIsAccumulating] = useState(false);\n  \n  // Export file name prefix\n  const [filePrefix, setFilePrefix] = useState('spectrum');\n  const [includeDateInFilename, setIncludeDateInFilename] = useState(true);\n  \n  // Status message for operations\n  const [saveMessage, setSaveMessage] = useState('');\n  \n  // Peak detection state\n  const [showPeakMarkers, setShowPeakMarkers] = useState(true);\n  const [peakCount, setPeakCount] = useState(3); // Default to showing top 3 peaks\n  \n  // Calibration state\n  const [showCalibration, setShowCalibration] = useState(false);\n  const [calibrationPoints, setCalibrationPoints] = useState([\n    { position: 0.25000, wavelength: 450.0 },\n    { position: 0.75000, wavelength: 650.0 }\n  ]);\n  const [useCalibration, setUseCalibration] = useState(false);\n  const [flipXAxis, setFlipXAxis] = useState(false);\n  \n  const graphContainerRef = useRef(null);\n  const canvasRef = useRef(null);\n  \n  // Expose methods to parent component via ref\n  useImperativeHandle(ref, () => ({\n    getCalibrationSettings: () => ({\n      calibrationPoints: [...calibrationPoints],\n      useCalibration,\n      flipXAxis\n    }),\n    \n    applyCalibrationSettings: (settings) => {\n      if (!settings) return false;\n      \n      try {\n        if (settings.calibrationPoints && Array.isArray(settings.calibrationPoints)) {\n          setCalibrationPoints(settings.calibrationPoints);\n        }\n        \n        if (typeof settings.useCalibration === 'boolean') {\n          setUseCalibration(settings.useCalibration);\n          if (settings.useCalibration) {\n            setShowCalibration(true);\n          }\n        }\n        \n        if (typeof settings.flipXAxis === 'boolean') {\n          setFlipXAxis(settings.flipXAxis);\n        }\n        \n        return true;\n      } catch (error) {\n        console.error('Error applying calibration settings:', error);\n        return false;\n      }\n    },\n    \n    getPeakSettings: () => ({\n      count: peakCount,\n      showMarkers: showPeakMarkers\n    }),\n    \n    applyPeakSettings: (settings) => {\n      if (!settings) return false;\n      \n      try {\n        if (typeof settings.count === 'number') {\n          setPeakCount(settings.count);\n        }\n        \n        if (typeof settings.showMarkers === 'boolean') {\n          setShowPeakMarkers(settings.showMarkers);\n        }\n        \n        return true;\n      } catch (error) {\n        console.error('Error applying peak settings:', error);\n        return false;\n      }\n    }\n  }));\n  \n  // Process raw spectral data\n  const processRawSpectralData = (rawData) => {\n    if (!rawData) return null;\n    \n    try {\n      // Extract the necessary data from the raw data\n      const { timestamp, wavelengths } = rawData;\n      \n      // Default structure for processed data\n      const processedData = {\n        timestamp: timestamp || Date.now(),\n        positions: wavelengths || [],\n        red: [],\n        green: [],\n        blue: [],\n        intensity: [],\n        lineLength: wavelengths?.length || 0,\n        isRawData: true,\n        bitDepth: rawData.bit_depth || 12,\n        dataType: rawData.data_type || 'raw'\n      };\n      \n      // Process based on data type (RGB or monochrome)\n      if (rawData.red && rawData.green && rawData.blue) {\n        // RGB data\n        processedData.red = [...rawData.red];\n        processedData.green = [...rawData.green];\n        processedData.blue = [...rawData.blue];\n      } else {\n        console.error(\"Unknown raw data format:\", rawData);\n        return null;\n      }\n      \n      // Calculate intensity using wavelength ranges and sensitivity factors\n      processedData.intensity = calculateIntensityWithCorrections(\n        processedData.red,\n        processedData.green,\n        processedData.blue,\n        processedData.positions\n      );\n      \n      return processedData;\n    } catch (error) {\n      console.error(\"Error processing raw spectral data:\", error);\n      return null;\n    }\n  };\n  \n  // Calculate intensity with wavelength ranges and sensitivity corrections\n  const calculateIntensityWithCorrections = (redData, greenData, blueData, wavelengths) => {\n    if (!wavelengths || !wavelengths.length) return [];\n    \n    // Get channel ranges from config\n    const { CHANNEL_RANGES, SENSITIVITY_FACTORS } = spectralConfig;\n    const redRange = CHANNEL_RANGES.r;\n    const greenRange = CHANNEL_RANGES.g;\n    const blueRange = CHANNEL_RANGES.b;\n    \n    // Convert sensitivity factors object to array for easier lookup\n    const sensitivityWavelengths = Object.keys(SENSITIVITY_FACTORS).map(Number);\n    \n    // Initialize intensity array\n    const intensity = new Array(wavelengths.length).fill(0);\n    \n    // For each wavelength position\n    for (let i = 0; i < wavelengths.length; i++) {\n      const wavelength = wavelengths[i];\n      let sum = 0;\n      let count = 0;\n      \n      // Add red channel contribution if wavelength is in red range\n      if (wavelength >= redRange[0] && wavelength <= redRange[1]) {\n        // Find closest sensitivity factor\n        const closestWavelength = findClosestWavelength(wavelength, sensitivityWavelengths);\n        const sensitivityFactor = SENSITIVITY_FACTORS[closestWavelength.toString()];\n        \n        // Apply correction factor\n        sum += redData[i] / sensitivityFactor;\n        count++;\n      }\n      \n      // Add green channel contribution if wavelength is in green range\n      if (wavelength >= greenRange[0] && wavelength <= greenRange[1]) {\n        // Find closest sensitivity factor\n        const closestWavelength = findClosestWavelength(wavelength, sensitivityWavelengths);\n        const sensitivityFactor = SENSITIVITY_FACTORS[closestWavelength.toString()];\n        \n        // Apply correction factor\n        sum += greenData[i] / sensitivityFactor;\n        count++;\n      }\n      \n      // Add blue channel contribution if wavelength is in blue range\n      if (wavelength >= blueRange[0] && wavelength <= blueRange[1]) {\n        // Find closest sensitivity factor\n        const closestWavelength = findClosestWavelength(wavelength, sensitivityWavelengths);\n        const sensitivityFactor = SENSITIVITY_FACTORS[closestWavelength.toString()];\n        \n        // Apply correction factor\n        sum += blueData[i] / sensitivityFactor;\n        count++;\n      }\n      \n      // Calculate average if any channels contributed\n      intensity[i] = count > 0 ? sum / count : 0;\n    }\n    \n    return intensity;\n  };\n  \n  // Find the closest wavelength value in the sensitivity factors\n  const findClosestWavelength = (targetWavelength, wavelengths) => {\n    if (!wavelengths.length) return targetWavelength;\n    \n    let closest = wavelengths[0];\n    let minDiff = Math.abs(targetWavelength - closest);\n    \n    for (let i = 1; i < wavelengths.length; i++) {\n      const diff = Math.abs(targetWavelength - wavelengths[i]);\n      if (diff < minDiff) {\n        minDiff = diff;\n        closest = wavelengths[i];\n      }\n    }\n    \n    return closest;\n  };\n  \n  // Update graph when line data changes\n  useEffect(() => {\n    if (lineData) {\n      // Process the data differently based on what we receive\n      let pixelData;\n      \n      if (lineData.pixelData) {\n        // Legacy format - already processed data\n        pixelData = lineData.pixelData;\n      } else if (lineData.graph_data) {\n        // New format - contains raw graph data from spectrometer\n        pixelData = processRawSpectralData(lineData.graph_data);\n      } else {\n        // Direct raw data format\n        pixelData = processRawSpectralData(lineData);\n      }\n      \n      if (pixelData) {\n        // Always keep the latest raw frame data for display when not accumulating\n        setGraphData(pixelData);\n        \n        if (isAccumulating) {\n          // Add new frame to accumulation buffer\n          setAccumulatedFrames(prev => {\n            const newFrames = [...prev, pixelData];\n            \n            // If we've reached our target frame count, process the accumulated data\n            if (newFrames.length >= frameAccumCount) {\n              // Sum the color data across all frames\n              const summedData = sumFrameData(newFrames);\n              \n              // Update accumulated data state\n              setAccumulatedData(summedData);\n              \n              // Draw the accumulated data\n              drawGraph(summedData);\n              \n              // Reset the accumulation buffer\n              return [];\n            }\n            \n            return newFrames;\n          });\n        } else {\n          // If not accumulating, just display the raw frame\n          drawGraph(pixelData);\n        }\n      }\n    }\n  }, [lineData, isAccumulating, frameAccumCount, useCalibration, calibrationPoints, flipXAxis]);\n  \n  // When accumulated data changes, draw it\n  useEffect(() => {\n    if (accumulatedData && isAccumulating) {\n      drawGraph(accumulatedData);\n    }\n  }, [accumulatedData, useCalibration, calibrationPoints, flipXAxis]);\n  \n  // Function to add current data to memory\n  const addToMemory = () => {\n    const dataToMemorize = isAccumulating ? accumulatedData : graphData;\n    \n    if (!dataToMemorize) {\n      setSaveMessage('No data to memorize');\n      setTimeout(() => setSaveMessage(''), 3000);\n      return;\n    }\n    \n    // Create a copy of the data with a timestamp\n    const memorizedItem = {\n      ...dataToMemorize,\n      memoryTimestamp: new Date().toISOString()\n    };\n    \n    // Add to memory array\n    setMemorizedData(prev => [...prev, memorizedItem]);\n    setSaveMessage(`Data added to memory (${memorizedData.length + 1} items)`);\n    setTimeout(() => setSaveMessage(''), 3000);\n  };\n  \n  // Function to clear memory\n  const clearMemory = () => {\n    setMemorizedData([]);\n    setSaveMessage('Memory cleared');\n    setTimeout(() => setSaveMessage(''), 3000);\n  };\n  \n  // Sum pixel data across multiple frames\n  const sumFrameData = (frames) => {\n    if (!frames.length) return null;\n    \n    // Use the first frame as a template for structure\n    const template = frames[0];\n    \n    // Initialize arrays for summed values\n    const summedRed = Array(template.red.length).fill(0);\n    const summedGreen = Array(template.green.length).fill(0);\n    const summedBlue = Array(template.blue.length).fill(0);\n    const summedIntensity = Array(template.intensity.length).fill(0);\n    \n    // Sum values across all frames\n    frames.forEach(frame => {\n      frame.red.forEach((val, i) => summedRed[i] += val);\n      frame.green.forEach((val, i) => summedGreen[i] += val);\n      frame.blue.forEach((val, i) => summedBlue[i] += val);\n      frame.intensity.forEach((val, i) => summedIntensity[i] += val);\n    });\n\n    // Return the summed data structure\n    return {\n      timestamp: Date.now(),\n      positions: template.positions, // Positions remain the same\n      red: summedRed,\n      green: summedGreen,\n      blue: summedBlue,\n      intensity: summedIntensity,\n      lineLength: template.lineLength,\n      frameCount: frames.length, // Add count of frames that were summed\n      \n      // Preserve raw data metadata if present in template\n      isRawData: template.isRawData || false,\n      bitDepth: template.bitDepth || null,\n      dataType: template.dataType || null\n    };\n  };\n  \n  // Convert position to wavelength using calibration points\n  const positionToWavelength = (position) => {\n    if (!useCalibration || calibrationPoints.length < 2) {\n      return position;\n    }\n    \n    // Sort calibration points by position\n    const sortedPoints = [...calibrationPoints].sort((a, b) => a.position - b.position);\n    \n    // Find the two calibration points that surround the given position\n    let p1, p2;\n    for (let i = 0; i < sortedPoints.length - 1; i++) {\n      if (position >= sortedPoints[i].position && position <= sortedPoints[i + 1].position) {\n        p1 = sortedPoints[i];\n        p2 = sortedPoints[i + 1];\n        break;\n      }\n    }\n    \n    // If position is outside the calibration range, use extrapolation\n    if (!p1 || !p2) {\n      if (position < sortedPoints[0].position) {\n        // Extrapolate below the first point\n        // Use the first two points for the slope calculation\n        p1 = sortedPoints[0];\n        p2 = sortedPoints[1];\n        // Calculate the slope between first two calibration points\n        const slope = (p2.wavelength - p1.wavelength) / (p2.position - p1.position);\n        // Extrapolate using y = mx + b formula\n        return p1.wavelength + slope * (position - p1.position);\n      } else {\n        // Extrapolate above the last point\n        // Use the last two points for the slope calculation\n        p1 = sortedPoints[sortedPoints.length - 2];\n        p2 = sortedPoints[sortedPoints.length - 1];\n        // Calculate the slope between last two calibration points\n        const slope = (p2.wavelength - p1.wavelength) / (p2.position - p1.position);\n        // Extrapolate using y = mx + b formula\n        return p2.wavelength + slope * (position - p2.position);\n      }\n    }\n    \n    // Linear interpolation between the two calibration points\n    const t = (position - p1.position) / (p2.position - p1.position);\n    return p1.wavelength + t * (p2.wavelength - p1.wavelength);\n  };\n  \n  // Handle changing the frame accumulation count\n  const handleFrameCountChange = (e) => {\n    const count = parseInt(e.target.value);\n    if (!isNaN(count) && count > 0) {\n      setFrameAccumCount(count);\n      // Reset accumulation when count changes\n      setAccumulatedFrames([]);\n      setAccumulatedData(null);\n      \n      // Notify parent of change\n      if (onFrameAccumCountChange) {\n        onFrameAccumCountChange(count);\n      }\n    }\n  };\n  \n  // Toggle accumulation mode\n  const toggleAccumulation = () => {\n    const newValue = !isAccumulating;\n    setIsAccumulating(newValue);\n    // Reset accumulated data when toggling\n    setAccumulatedFrames([]);\n    setAccumulatedData(null);\n    \n    // Notify parent of change\n    if (onAccumulationToggle) {\n      onAccumulationToggle(newValue);\n    }\n  };\n  \n  // Toggle calibration controls\n  const toggleCalibration = () => {\n    setShowCalibration(!showCalibration);\n  };\n  \n  // Toggle using calibration\n  const toggleUseCalibration = () => {\n    setUseCalibration(!useCalibration);\n  };\n  \n  // Toggle flip X axis\n  const toggleFlipXAxis = () => {\n    setFlipXAxis(!flipXAxis);\n  };\n  \n  // Update calibration point\n  const updateCalibrationPoint = (index, field, value) => {\n    const numValue = parseFloat(value);\n    if (isNaN(numValue)) return;\n    \n    // Format position values to 3 decimal places\n    const formattedValue = field === 'position' ? \n      parseFloat(numValue.toFixed(3)) : \n      numValue;\n    \n    setCalibrationPoints(points => {\n      const newPoints = [...points];\n      newPoints[index] = {\n        ...newPoints[index],\n        [field]: formattedValue\n      };\n      return newPoints;\n    });\n  };\n  \n  // Initialize and resize the canvas when graph size changes\n  useEffect(() => {\n    if (canvasRef.current) {\n      const canvas = canvasRef.current;\n      const container = graphContainerRef.current;\n      \n      if (container) {\n        // Set canvas size to match container\n        canvas.width = container.clientWidth;\n        canvas.height = container.clientHeight;\n        \n        // Redraw graph with new size\n        if (isAccumulating && accumulatedData) {\n          drawGraph(accumulatedData);\n        } else if (graphData) {\n          drawGraph(graphData);\n        }\n      }\n    }\n  }, [graphSize, graphData, accumulatedData, isAccumulating, useCalibration, calibrationPoints, flipXAxis]);\n  \n  // Find peaks in data array\n  const findPeaks = (values, positions, count = 3) => {\n    if (!values || values.length < 3) return [];\n    \n    // Find local maxima (points higher than both neighbors)\n    const peaks = [];\n    \n    for (let i = 1; i < values.length - 1; i++) {\n      if (values[i] > values[i - 1] && values[i] > values[i + 1]) {\n        // This is a local maximum\n        const peak = {\n          index: i,\n          position: positions[i],\n          value: values[i]\n        };\n        \n        // Refine position using quadratic interpolation for better accuracy\n        try {\n          // Based on three points around the peak\n          const x1 = positions[i-1];\n          const x2 = positions[i];\n          const x3 = positions[i+1];\n          const y1 = values[i-1];\n          const y2 = values[i];\n          const y3 = values[i+1];\n          \n          // Only apply refinement if we have valid neighboring points\n          const denom = (x1 - x2) * (x1 - x3) * (x2 - x3);\n          if (denom !== 0) {\n            // Quadratic interpolation formula\n            const A = (x3 * (y2 - y1) + x2 * (y1 - y3) + x1 * (y3 - y2)) / denom;\n            const B = (x3*x3 * (y1 - y2) + x2*x2 * (y3 - y1) + x1*x1 * (y2 - y3)) / denom;\n            \n            // Calculate refined x position at the peak of the parabola\n            if (A !== 0) {\n              const refinedPos = -B / (2 * A);\n              \n              // Only use refined position if it's within a reasonable range\n              if (refinedPos >= x1 && refinedPos <= x3) {\n                peak.refinedPosition = refinedPos;\n              }\n            }\n          }\n        } catch (e) {\n          console.warn('Error during peak refinement', e);\n          // If refinement fails, use the original position\n        }\n        \n        peaks.push(peak);\n      }\n    }\n    \n    // Sort peaks by value (descending)\n    peaks.sort((a, b) => b.value - a.value);\n    \n    // Filter peaks to ensure they're at least 10nm apart (or equivalent in position space)\n    const filteredPeaks = [];\n    \n    // Default position-based distance (approximately 5% of the position range)\n    const minPositionDistance = 0.05;\n    \n    for (const peak of peaks) {\n      // Check if this peak is too close to any already-selected stronger peak\n      let tooClose = false;\n      \n      for (const selectedPeak of filteredPeaks) {\n        // Use position-based distance (wavelength conversion will happen in the drawing code)\n        const distance = Math.abs(peak.position - selectedPeak.position);\n        \n        if (distance < minPositionDistance) {\n          tooClose = true;\n          break;\n        }\n      }\n      \n      // Add the peak if it's not too close to any stronger peak\n      if (!tooClose) {\n        filteredPeaks.push(peak);\n        \n        // Stop if we have enough peaks\n        if (filteredPeaks.length >= count) {\n          break;\n        }\n      }\n    }\n    \n    return filteredPeaks;\n  };\n  \n  // Draw the graph based on pixel data\n  const drawGraph = (data) => {\n    if (!canvasRef.current || !data) return;\n    \n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n    \n    // Clear the canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    // Draw background\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';\n    ctx.fillRect(0, 0, width, height);\n    \n    // Draw grid lines\n    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';\n    ctx.lineWidth = 1;\n    \n    // Horizontal grid lines (at 25%, 50%, 75%)\n    for (let i = 1; i < 4; i++) {\n      const y = height * (i / 4);\n      ctx.beginPath();\n      ctx.moveTo(0, y);\n      ctx.lineTo(width, y);\n      ctx.stroke();\n    }\n    \n    // Vertical grid lines (at 25%, 50%, 75%)\n    for (let i = 1; i < 4; i++) {\n      const x = width * (i / 4);\n      ctx.beginPath();\n      ctx.moveTo(x, 0);\n      ctx.lineTo(x, height);\n      ctx.stroke();\n    }\n    \n    // Calculate min and max wavelength values for calibration upfront\n    let minWavelength, maxWavelength;\n    if (useCalibration && calibrationPoints.length >= 2) {\n      const wavelengths = calibrationPoints.map(p => p.wavelength);\n      minWavelength = Math.min(...wavelengths);\n      maxWavelength = Math.max(...wavelengths);\n    }\n    \n    // Set line styles for different channels\n    const styles = {\n      red: { color: 'rgba(255, 0, 0, 0.8)', width: 1.5 },\n      green: { color: 'rgba(0, 255, 0, 0.8)', width: 1.5 },\n      blue: { color: 'rgba(0, 0, 255, 0.8)', width: 1.5 },\n      intensity: { color: 'rgba(255, 255, 255, 0.8)', width: 2 }\n    };\n    \n    // Find max values for scaling\n    const maxRed = Math.max(...data.red, 1);\n    const maxGreen = Math.max(...data.green, 1);\n    const maxBlue = Math.max(...data.blue, 1);\n    const maxIntensity = Math.max(...data.intensity, 1);\n    \n    // Store the peak data for each displayed channel\n    const channelPeaks = {};\n    \n    // Plot each enabled channel\n    Object.entries(displayChannels).forEach(([channel, isEnabled]) => {\n      if (!isEnabled) return;\n      \n      const values = data[channel];\n      const maxValue = channel === 'red' ? maxRed : \n                      channel === 'green' ? maxGreen : \n                      channel === 'blue' ? maxBlue : maxIntensity;\n      \n      // Set line style\n      ctx.strokeStyle = styles[channel].color;\n      ctx.lineWidth = styles[channel].width;\n      \n      // Begin the path\n      ctx.beginPath();\n      \n      // Draw the line\n      for (let i = 0; i < values.length; i++) {\n        // Calculate x position, applying flip if enabled\n        let xPos = data.positions[i];\n        if (flipXAxis) {\n          xPos = 1 - xPos; // Invert position (0 becomes 1, 1 becomes 0)\n        }\n        \n        // Convert to pixel coordinates\n        const x = xPos * width;\n        \n        // Invert Y since canvas 0,0 is top-left\n        const y = height - (values[i] / maxValue) * height;\n        \n        if (i === 0) {\n          ctx.moveTo(x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n      }\n      \n      // Draw the path\n      ctx.stroke();\n    });\n    \n    // Detect peaks for intensity channel only if enabled\n    if (showPeakMarkers && displayChannels.intensity) {\n      const intensityValues = data.intensity;\n      // Use original positions for peak detection\n      const peaks = findPeaks(intensityValues, data.positions, peakCount);\n      \n      // If calibration is enabled, perform additional wavelength-based filtering\n      if (useCalibration) {\n        // Convert positions to wavelengths and filter to ensure 10nm minimum distance\n        const wavelengthPeaks = [];\n        \n        // Process peaks in order of intensity (already sorted by findPeaks)\n        for (const peak of peaks) {\n          const peakWavelength = positionToWavelength(peak.position);\n          let tooClose = false;\n          \n          // Check if this peak is too close to any already selected peak\n          for (const selectedPeak of wavelengthPeaks) {\n            const selectedWavelength = positionToWavelength(selectedPeak.position);\n            const distance = Math.abs(peakWavelength - selectedWavelength);\n            \n            if (distance < 10) { // 10nm minimum distance\n              tooClose = true;\n              break;\n            }\n          }\n          \n          // Add the peak if it's not too close to any already selected peak\n          if (!tooClose) {\n            wavelengthPeaks.push(peak);\n          }\n        }\n        \n        channelPeaks['intensity'] = wavelengthPeaks;\n      } else {\n        channelPeaks['intensity'] = peaks;\n      }\n    }\n    \n    // Draw timestamp and status information\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n    ctx.font = '10px monospace';\n    ctx.textAlign = 'left';\n    \n    // Show time and accumulation status\n    const timeText = `Time: ${new Date(data.timestamp).toLocaleTimeString()}`;\n    const statusText = isAccumulating \n      ? `Accumulating: ${accumulatedFrames.length}/${frameAccumCount} frames` \n      : 'Live data';\n    \n    ctx.fillText(timeText, 5, 15);\n    ctx.fillText(statusText, width - 150, 15);\n    \n    // Draw calibration status if enabled\n    if (useCalibration) {\n      ctx.fillText('Calibrated', width - 150, 45);\n    }\n    \n    // Draw spectral correction status\n    const { CHANNEL_RANGES } = spectralConfig;\n    ctx.fillStyle = 'rgba(255, 200, 100, 0.9)';\n    ctx.fillText(`Spectral corrections applied`, 5, 75);\n    \n    // Draw specific range info with colors matching the channels\n    ctx.fillStyle = styles.red.color;\n    ctx.fillText(`R: ${CHANNEL_RANGES.r[0].toFixed(1)}-${CHANNEL_RANGES.r[1].toFixed(1)}nm`, 5, 90);\n    \n    ctx.fillStyle = styles.green.color;\n    ctx.fillText(`G: ${CHANNEL_RANGES.g[0].toFixed(1)}-${CHANNEL_RANGES.g[1].toFixed(1)}nm`, 5, 105);\n    \n    ctx.fillStyle = styles.blue.color;\n    ctx.fillText(`B: ${CHANNEL_RANGES.b[0].toFixed(1)}-${CHANNEL_RANGES.b[1].toFixed(1)}nm`, 5, 120);\n    \n    // Draw frame count if this is accumulated data\n    if (data.frameCount) {\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n      ctx.fillText(`Summed ${data.frameCount} frames`, width - 150, 30);\n    }\n    \n    // Draw raw data and bit depth information if available\n    if (data.isRawData) {\n      const bitDepth = data.bitDepth || 12;\n      const dataType = data.dataType || 'raw';\n      ctx.fillStyle = 'rgba(255, 200, 100, 0.9)';\n      ctx.fillText(`RAW ${bitDepth}-bit | ${dataType}`, 5, 60);\n    }\n    \n    // Draw channel legend\n    const legendStartY = 30;\n    const legendSpacing = 15;\n    \n    if (displayChannels.red) {\n      ctx.fillStyle = styles.red.color;\n      // For raw data, show max value as well\n      if (data.isRawData) {\n        ctx.fillText(`Red: ${Math.round(data.red.reduce((a, b) => a + b, 0) / data.red.length)} (max: ${Math.round(maxRed)})`, 5, legendStartY);\n      } else {\n        ctx.fillText(`Red: ${Math.round(data.red.reduce((a, b) => a + b, 0) / data.red.length)}`, 5, legendStartY);\n      }\n    }\n    \n    if (displayChannels.green) {\n      ctx.fillStyle = styles.green.color;\n      // For raw data, show max value as well\n      if (data.isRawData) {\n        ctx.fillText(`Green: ${Math.round(data.green.reduce((a, b) => a + b, 0) / data.green.length)} (max: ${Math.round(maxGreen)})`, 5, legendStartY + legendSpacing);\n      } else {\n        ctx.fillText(`Green: ${Math.round(data.green.reduce((a, b) => a + b, 0) / data.green.length)}`, 5, legendStartY + legendSpacing);\n      }\n    }\n    \n    if (displayChannels.blue) {\n      ctx.fillStyle = styles.blue.color;\n      // For raw data, show max value as well\n      if (data.isRawData) {\n        ctx.fillText(`Blue: ${Math.round(data.blue.reduce((a, b) => a + b, 0) / data.blue.length)} (max: ${Math.round(maxBlue)})`, 5, legendStartY + legendSpacing * 2);\n      } else {\n        ctx.fillText(`Blue: ${Math.round(data.blue.reduce((a, b) => a + b, 0) / data.blue.length)}`, 5, legendStartY + legendSpacing * 2);\n      }\n    }\n    \n    if (displayChannels.intensity) {\n      ctx.fillStyle = styles.intensity.color;\n      // For raw data, show max value as well\n      if (data.isRawData) {\n        ctx.fillText(`Intensity: ${(data.intensity.reduce((a, b) => a + b, 0) / data.intensity.length).toFixed(2)} (max: ${Math.round(maxIntensity)})`, 5, legendStartY + legendSpacing * 3);\n      } else {\n        ctx.fillText(`Intensity: ${(data.intensity.reduce((a, b) => a + b, 0) / data.intensity.length).toFixed(2)}`, 5, legendStartY + legendSpacing * 3);\n      }\n    }\n    \n    // Draw wavelength axis labels if calibration is enabled (unified section)\n    if (useCalibration && minWavelength !== undefined && maxWavelength !== undefined) {\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';\n      ctx.font = '10px monospace';\n      ctx.textAlign = 'center';\n      \n      // Clear the bottom area where labels will go\n      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; // Match background color\n      ctx.fillRect(0, height - 20, width, 20);\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'; // Reset text color\n      \n      // Draw axis labels at regular position intervals (0%, 25%, 50%, 75%, 100%)\n      // but show the corresponding wavelength values\n      for (let i = 0; i <= 4; i++) {\n        const position = i / 4; // Regular positions (0, 0.25, 0.5, 0.75, 1)\n        \n        // Apply flip if enabled\n        const displayPosition = flipXAxis ? 1 - position : position;\n        const x = displayPosition * width;\n        \n        // Convert position to wavelength using calibration\n        const wavelength = positionToWavelength(position);\n        \n        ctx.fillText(`${Math.round(wavelength)}nm`, x, height - 5);\n      }\n    }\n    \n    // Draw calibration points if enabled\n    if (useCalibration) {\n      calibrationPoints.forEach(point => {\n        // Apply flip if enabled\n        const displayPosition = flipXAxis ? 1 - point.position : point.position;\n        // Draw vertical line at calibration point position\n        const x = displayPosition * width;\n        \n        ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n        ctx.moveTo(x, 0);\n        ctx.lineTo(x, height);\n        ctx.stroke();\n        \n        // Draw wavelength label at the calibration point\n        ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';\n        ctx.font = '10px monospace';\n        ctx.textAlign = 'center';\n        ctx.fillText(`${point.wavelength}nm`, x, height - 20); // Higher position to avoid overlap\n      });\n    }\n    \n    // Draw peak markers if enabled\n    if (showPeakMarkers) {\n      // Draw peaks for each enabled channel\n      Object.entries(channelPeaks).forEach(([channel, peaks]) => {\n        // Use the same color as the channel with increased opacity\n        const baseColor = styles[channel].color;\n        const markerColor = baseColor.replace('rgba', 'rgb').replace(/,\\s*[\\d.]+\\)/, ')');\n        \n        // Get max value for this channel for y-coordinate calculation\n        const maxValue = channel === 'red' ? maxRed : \n                        channel === 'green' ? maxGreen : \n                        channel === 'blue' ? maxBlue : maxIntensity;\n        \n        peaks.forEach(peak => {\n          // Get the original position\n          let xPos = peak.position;\n          \n          // Use refined position if available (within reasonable bounds)\n          if (peak.refinedPosition !== undefined) {\n            xPos = peak.refinedPosition;\n          }\n          \n          // Apply flip if enabled\n          if (flipXAxis) {\n            xPos = 1 - xPos;\n          }\n          \n          // Convert to pixel coordinates\n          const x = xPos * width;\n          const y = height - (peak.value / maxValue) * height;\n          \n          // Check if peak is near the top of the graph (below a minimum distance from top)\n          const isNearTop = y < 60; // 60px from top\n          \n          // Draw a vertical line first (always visible)\n          ctx.strokeStyle = markerColor;\n          ctx.setLineDash([2, 2]);\n          ctx.beginPath();\n          ctx.moveTo(x, y);\n          ctx.lineTo(x, height);\n          ctx.stroke();\n          ctx.setLineDash([]);\n          \n          // Draw marker at peak position (triangle pointing down or up based on position)\n          ctx.fillStyle = markerColor;\n          ctx.beginPath();\n          \n          if (isNearTop) {\n            // If near top, draw triangle pointing up from a position slightly below the peak\n            const markerY = y + 15;\n            ctx.moveTo(x, markerY);  \n            ctx.lineTo(x - 5, markerY + 10);\n            ctx.lineTo(x + 5, markerY + 10);\n          } else {\n            // Normal case - draw triangle pointing down\n            ctx.moveTo(x, y);  \n            ctx.lineTo(x - 5, y - 10);\n            ctx.lineTo(x + 5, y - 10);\n          }\n          ctx.closePath();\n          ctx.fill();\n          \n          // Prepare label text\n          let label;\n          if (useCalibration) {\n            const wavelength = positionToWavelength(peak.position);\n            label = `${wavelength.toFixed(1)}nm`;\n          } else {\n            label = `Pos: ${peak.position.toFixed(3)}`;\n          }\n          \n          const valueLabel = `I: ${peak.value.toFixed(1)}`;\n          \n          // Setup text rendering\n          ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n          ctx.font = '10px monospace';\n          ctx.textAlign = 'center';\n          \n          // Measure text dimensions for backgrounds\n          const textWidth = ctx.measureText(label).width + 6;\n          const valueWidth = ctx.measureText(valueLabel).width + 6;\n          \n          if (isNearTop) {\n            // Draw position/wavelength label below the marker\n            const labelY = y + 30;\n            \n            // Draw text background\n            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';\n            ctx.fillRect(x - textWidth/2, labelY - 10, textWidth, 16);\n            \n            // Draw label text\n            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n            ctx.fillText(label, x, labelY);\n            \n            // Draw value label below that\n            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';\n            ctx.fillRect(x - valueWidth/2, labelY + 7, valueWidth, 16);\n            \n            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n            ctx.fillText(valueLabel, x, labelY + 17);\n          } else {\n            // Standard label position above marker\n            // Draw text background for better readability\n            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';\n            ctx.fillRect(x - textWidth/2, y - 25, textWidth, 16);\n            \n            // Draw label above marker\n            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n            ctx.fillText(label, x, y - 14);\n            \n            // Draw peak value\n            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';\n            ctx.fillRect(x - valueWidth/2, y - 42, valueWidth, 16);\n            \n            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n            ctx.fillText(valueLabel, x, y - 31);\n          }\n        });\n      });\n    }\n    \n    // Draw crosshair at cursor position\n    if (showCrosshair && cursorPosition) {\n      const { x, y } = cursorPosition;\n      \n      if (x >= 0 && x <= width && y >= 0 && y <= height) {\n        // Draw vertical line\n        ctx.beginPath();\n        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';\n        ctx.lineWidth = 1;\n        ctx.setLineDash([3, 3]); // Dashed line\n        ctx.moveTo(x, 0);\n        ctx.lineTo(x, height);\n        ctx.stroke();\n        \n        // Draw horizontal line\n        ctx.beginPath();\n        ctx.moveTo(0, y);\n        ctx.lineTo(width, y);\n        ctx.stroke();\n        ctx.setLineDash([]); // Reset line style\n        \n        // Calculate and display wavelength at cursor position\n        const position = x / width; // Normalize cursor position (0-1)\n        \n        // Apply flip if needed to get the actual data position\n        const dataPosition = flipXAxis ? 1 - position : position;\n        \n        // Determine wavelength based on cursor position\n        let wavelength;\n        if (useCalibration) {\n          wavelength = positionToWavelength(dataPosition);\n        } else {\n          wavelength = dataPosition; // Just show the position value when not calibrated\n        }\n        \n        // Calculate y-values at the cursor position\n        let valueText = '';\n        \n        if (data && data.positions && data.positions.length > 0) {\n          // Find the nearest data point to the cursor\n          const positionIndex = findNearestPositionIndex(data.positions, dataPosition);\n          \n          // Build value text based on active channels\n          const channelTexts = [];\n          if (displayChannels.red) {\n            channelTexts.push(`R:${Math.round(data.red[positionIndex])}`);\n          }\n          if (displayChannels.green) {\n            channelTexts.push(`G:${Math.round(data.green[positionIndex])}`);\n          }\n          if (displayChannels.blue) {\n            channelTexts.push(`B:${Math.round(data.blue[positionIndex])}`);\n          }\n          if (displayChannels.intensity) {\n            channelTexts.push(`I:${data.intensity[positionIndex].toFixed(1)}`);\n          }\n          \n          valueText = channelTexts.join(', ');\n        }\n        \n        // Create a background for the text for better readability\n        const wavelengthText = useCalibration ? `${wavelength.toFixed(1)}nm` : `Pos: ${wavelength.toFixed(3)}`;\n        \n        // Draw text background\n        const textWidth = ctx.measureText(wavelengthText).width + 10;\n        const valueTextWidth = ctx.measureText(valueText).width + 10;\n        \n        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n        ctx.fillRect(x - textWidth/2, height - 45, textWidth, 20);\n        \n        if (valueText) {\n          ctx.fillRect(x - valueTextWidth/2, 5, valueTextWidth, 20);\n        }\n        \n        // Draw wavelength text below cursor\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n        ctx.textAlign = 'center';\n        ctx.fillText(wavelengthText, x, height - 30);\n        \n        // Draw value text above cursor\n        if (valueText) {\n          ctx.fillText(valueText, x, 20);\n        }\n      }\n    }\n  };\n  \n  // Helper to find the index of the nearest position value to a given position\n  const findNearestPositionIndex = (positions, targetPosition) => {\n    if (!positions || positions.length === 0) return -1;\n    \n    let nearestIndex = 0;\n    let minDistance = Math.abs(positions[0] - targetPosition);\n    \n    for (let i = 1; i < positions.length; i++) {\n      const distance = Math.abs(positions[i] - targetPosition);\n      if (distance < minDistance) {\n        minDistance = distance;\n        nearestIndex = i;\n      }\n    }\n    \n    return nearestIndex;\n  };\n  \n  // Toggle display of a specific channel\n  const toggleChannel = (channel) => {\n    setDisplayChannels(prev => ({\n      ...prev,\n      [channel]: !prev[channel]\n    }));\n  };\n  \n  // Handle mouse movement over the graph\n  const handleMouseMove = (e) => {\n    if (!graphContainerRef.current) return;\n    \n    // Get canvas bounds\n    const rect = graphContainerRef.current.getBoundingClientRect();\n    \n    // Calculate cursor position relative to canvas\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    \n    // Update cursor position state\n    setCursorPosition({ x, y });\n    \n    // Redraw the graph with crosshair\n    if (isAccumulating && accumulatedData) {\n      drawGraph(accumulatedData);\n    } else if (graphData) {\n      drawGraph(graphData);\n    }\n  };\n  \n  // Handle mouse enter/leave events\n  const handleMouseEnter = () => {\n    setShowCrosshair(true);\n  };\n  \n  const handleMouseLeave = () => {\n    setShowCrosshair(false);\n    setCursorPosition(null);\n    \n    // Redraw the graph without crosshair\n    if (isAccumulating && accumulatedData) {\n      drawGraph(accumulatedData);\n    } else if (graphData) {\n      drawGraph(graphData);\n    }\n  };\n  \n  // Similar resize functionality as before\n  const handleResizeStart = (e) => {\n    e.preventDefault();\n    e.stopPropagation();\n    \n    // Get initial coordinates and size\n    const startX = e.clientX;\n    const startY = e.clientY;\n    const startWidth = graphContainerRef.current?.clientWidth || 400;\n    const startHeight = graphContainerRef.current?.clientHeight || graphSize.height;\n    \n    // Show resize feedback\n    setIsResizing(true);\n    setShowResizeInfo(true);\n    \n    // Define move handler\n    function handleMouseMove(moveEvent) {\n      const deltaY = moveEvent.clientY - startY;\n      \n      // Only adjust height, keep width as 100%\n      const newHeight = Math.max(100, startHeight + deltaY);\n      \n      // Update graph size\n      const newSize = {\n        width: '100%',  // Keep width as 100% for responsive behavior\n        height: Math.round(newHeight)\n      };\n      \n      setGraphSize(newSize);\n      \n      // Notify parent if needed\n      if (onResize) {\n        onResize(newSize);\n      }\n      \n      // Prevent default to avoid text selection during resize\n      moveEvent.preventDefault();\n    }\n    \n    // Define up handler\n    function handleMouseUp() {\n      // Clean up\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n      \n      setIsResizing(false);\n      setTimeout(() => setShowResizeInfo(false), 800);\n    }\n    \n    // Attach handlers to document to capture events outside component\n    document.addEventListener('mousemove', handleMouseMove);\n    document.addEventListener('mouseup', handleMouseUp);\n  };\n  \n  // Export settings to JSON file\n  const exportSettings = () => {\n    try {\n      // fill this gap\n    } catch (error) {\n      console.error('Failed to export settings:', error);\n      setSaveMessage('Error exporting settings');\n      setTimeout(() => setSaveMessage(''), 3000);\n    }\n  };\n  \n  // Export graph data as text file\n  const exportGraphData = () => {\n    // Make sure we have data to export\n    const dataToExport = isAccumulating ? accumulatedData : graphData;\n    \n    if (!dataToExport) {\n      console.warn('No data to export');\n      if (props.onMessage) {\n        props.onMessage('No data to export');\n      }\n      return;\n    }\n    \n    try {\n      const lines = [];\n      // Create a timestamp string with units separated by semicolons: YYYY;MM;DD;hh;mm;ss\n      const now = new Date();\n      const timestamp = now.getFullYear() + ';' +\n        String(now.getMonth() + 1).padStart(2, '0') + ';' +\n        String(now.getDate()).padStart(2, '0') + ';' +\n        String(now.getHours()).padStart(2, '0') + ';' +\n        String(now.getMinutes()).padStart(2, '0') + ';' +\n        String(now.getSeconds()).padStart(2, '0');\n        \n      lines.push(timestamp);\n      \n      // Add raw data metadata if available\n      if (dataToExport.isRawData) {\n        const bitDepth = dataToExport.bitDepth || 12;\n        const dataType = dataToExport.dataType || 'raw';\n        lines.push(`# RAW DATA: ${bitDepth}-bit, type: ${dataType}`);\n      }\n      \n      // Add information about frame accumulation\n      if (dataToExport.frameCount) {\n        lines.push(`# Accumulated frames: ${dataToExport.frameCount}`);\n      }\n      \n      // Add information about memorized data if available\n      if (memorizedData.length > 0) {\n        lines.push(`# Memory entries: ${memorizedData.length}`);\n      }\n      \n      // Add column headers with memory columns if available\n      let headers = useCalibration ? \n        \"Wavelength (nm);Intensity;Red;Green;Blue\" : \n        \"Position;Intensity;Red;Green;Blue\";\n      \n      // Add headers for memorized data\n      if (memorizedData.length > 0) {\n        memorizedData.forEach((_, index) => {\n          headers += `;Memory${index+1}_Intensity;Memory${index+1}_Red;Memory${index+1}_Green;Memory${index+1}_Blue`;\n        });\n      }\n      \n      lines.push(headers);\n      \n      // Loop through data points\n      for (let i = 0; i < dataToExport.positions.length; i++) {\n        let position = dataToExport.positions[i];\n        // Convert position to wavelength if calibration is enabled\n        let wavelength = position;\n        if (useCalibration) {\n          wavelength = positionToWavelength(position);\n        }\n        \n        // Get all channel values for current data\n        const intensity = dataToExport.intensity[i];\n        const red = dataToExport.red[i];\n        const green = dataToExport.green[i];\n        const blue = dataToExport.blue[i];\n        \n        // Start the line with current data\n        let line = `${wavelength.toFixed(3)};${intensity.toFixed(2)};${red.toFixed(2)};${green.toFixed(2)};${blue.toFixed(2)}`;\n        \n        // Add memorized data if available\n        if (memorizedData.length > 0) {\n          memorizedData.forEach(memData => {\n            // Find the closest position in the memorized data\n            const memIndex = findNearestPositionIndex(memData.positions, position);\n            if (memIndex >= 0) {\n              const memIntensity = memData.intensity[memIndex];\n              const memRed = memData.red[memIndex];\n              const memGreen = memData.green[memIndex];\n              const memBlue = memData.blue[memIndex];\n              \n              // Add to the line\n              line += `;${memIntensity.toFixed(2)};${memRed.toFixed(2)};${memGreen.toFixed(2)};${memBlue.toFixed(2)}`;\n            } else {\n              // If no matching position found, add empty values\n              line += `;0;0;0;0`;\n            }\n          });\n        }\n        \n        // Add line with all values\n        lines.push(line);\n      }\n      \n      // Join lines with newlines\n      const content = lines.join('\\n');\n      \n      // Create filename with prefix and optional timestamp\n      // For raw data, add raw indicator to filename\n      let fileName = '';\n      if (dataToExport.isRawData) {\n        fileName = includeDateInFilename ? \n          `${filePrefix}_RAW${dataToExport.bitDepth || 12}bit_${timestamp}.txt` : \n          `${filePrefix}_RAW${dataToExport.bitDepth || 12}bit.txt`;\n      } else {\n        fileName = includeDateInFilename ? \n          `${filePrefix}_${timestamp}.txt` : \n          `${filePrefix}.txt`;\n      }\n      \n      // Create Blob with content\n      const blob = new Blob([content], { type: 'text/plain' });\n      \n      // Create download link\n      const url = URL.createObjectURL(blob);\n      const link = document.createElement('a');\n      link.href = url;\n      link.download = fileName;\n      \n      // Append to document, click, and remove\n      document.body.appendChild(link);\n      link.click();\n      \n      // Clean up\n      setTimeout(() => {\n        document.body.removeChild(link);\n        URL.revokeObjectURL(url);\n      }, 100);\n      \n      // Show success message\n      if (props.onMessage) {\n        props.onMessage(`Data exported as ${fileName}`);\n      } else {\n        // If no message handler provided, show alert\n        console.log(`Data exported as ${fileName}`);\n        setSaveMessage && setSaveMessage(`Data exported as ${fileName}`);\n        setTimeout(() => setSaveMessage && setSaveMessage(''), 3000);\n      }\n      \n    } catch (error) {\n      console.error('Failed to export graph data:', error);\n      if (props.onMessage) {\n        props.onMessage('Error exporting data');\n      } else {\n        setSaveMessage && setSaveMessage('Error exporting data');\n        setTimeout(() => setSaveMessage && setSaveMessage(''), 3000);\n      }\n    }\n  };\n  \n  // Load saved camera and calibration settings\n  const loadSettings = () => {\n    // fill this gap\n  };\n  \n  // Handle peak count change\n  const handlePeakCountChange = (e) => {\n    const count = parseInt(e.target.value);\n    if (!isNaN(count) && count >= 0 && count <= 10) {\n      setPeakCount(count);\n    }\n  };\n  \n  // Toggle peak markers\n  const togglePeakMarkers = () => {\n    setShowPeakMarkers(!showPeakMarkers);\n  };\n  \n  const styles = {\n    container: {\n      backgroundColor: 'rgba(0, 0, 0, 0.2)',\n      padding: '10px',\n      borderRadius: '4px',\n      position: 'relative',\n      border: isResizing ? '1px dashed #4CAF50' : 'none',\n    },\n    title: {\n      margin: '0 0 10px 0',\n      fontSize: '14px',\n      display: 'flex',\n      justifyContent: 'space-between',\n      alignItems: 'center'\n    },\n    controls: {\n      display: 'flex',\n      gap: '5px',\n      alignItems: 'center',\n    },\n    frameCountControl: {\n      display: 'flex',\n      alignItems: 'center',\n      marginBottom: '10px',\n      gap: '8px'\n    },\n    frameCountLabel: {\n      fontSize: '12px',\n      color: 'rgba(255, 255, 255, 0.8)'\n    },\n    frameCountInput: {\n      width: '50px',\n      padding: '2px 4px',\n      backgroundColor: 'rgba(30, 30, 30, 0.8)',\n      color: 'white',\n      border: '1px solid rgba(80, 80, 80, 0.5)',\n      borderRadius: '3px',\n      fontSize: '12px'\n    },\n    calibrationContainer: {\n      marginBottom: '10px',\n      padding: '8px',\n      backgroundColor: 'rgba(0, 0, 0, 0.3)',\n      borderRadius: '4px'\n    },\n    calibrationHeader: {\n      display: 'flex',\n      justifyContent: 'space-between',\n      alignItems: 'center',\n      marginBottom: '8px'\n    },\n    calibrationTitle: {\n      fontSize: '12px',\n      color: 'rgba(255, 255, 255, 0.9)',\n      margin: 0\n    },\n    calibrationCheckbox: {\n      marginLeft: '8px'\n    },\n    calibrationPoints: {\n      display: 'flex',\n      flexDirection: 'row',\n      flexWrap: 'wrap',\n      gap: '10px'\n    },\n    calibrationPointsColumn: {\n      display: 'flex',\n      flexDirection: 'column',\n      gap: '6px'\n    },\n    calibrationPointsRow: {\n      display: 'flex', \n      alignItems: 'center',\n      gap: '6px'\n    },\n    calibrationLabel: {\n      fontSize: '11px',\n      color: 'rgba(255, 255, 255, 0.7)',\n      width: '40px'\n    },\n    calibrationInput: {\n      width: '60px',\n      padding: '2px 4px',\n      backgroundColor: 'rgba(30, 30, 30, 0.8)',\n      color: 'white',\n      border: '1px solid rgba(80, 80, 80, 0.5)',\n      borderRadius: '3px',\n      fontSize: '11px'\n    },\n    graphView: {\n      width: graphSize.width,\n      height: `${graphSize.height}px`,\n      backgroundColor: 'rgba(0, 0, 0, 0.5)',\n      position: 'relative',\n      overflow: 'hidden'\n    },\n    canvas: {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%'\n    },\n    resizeHandle: {\n      position: 'absolute',\n      bottom: '0',\n      right: '0',\n      width: '20px',\n      height: '20px',\n      cursor: 'ns-resize', // Only allow vertical resizing\n      zIndex: 100,\n      display: 'flex',\n      justifyContent: 'center',\n      alignItems: 'center',\n      backgroundColor: 'rgba(60, 60, 60, 0.8)',\n      borderTop: '1px solid rgba(180, 180, 180, 0.7)',\n      borderLeft: '1px solid rgba(180, 180, 180, 0.7)',\n      borderTopLeftRadius: '4px',\n    },\n    resizeInfo: {\n      position: 'absolute',\n      right: '25px',\n      bottom: '25px',\n      padding: '2px 6px',\n      background: 'rgba(0, 0, 0, 0.7)',\n      color: 'white',\n      borderRadius: '3px',\n      fontSize: '11px',\n      zIndex: 100\n    },\n    channelToggles: {\n      display: 'flex',\n      gap: '5px'\n    },\n    channelButton: {\n      fontSize: '10px',\n      padding: '2px 5px',\n      borderRadius: '3px',\n      cursor: 'pointer',\n      border: '1px solid rgba(255, 255, 255, 0.3)',\n      backgroundColor: 'rgba(30, 30, 30, 0.7)'\n    },\n    noData: {\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'center',\n      height: '100%',\n      color: 'rgba(255, 255, 255, 0.5)',\n      fontSize: '12px'\n    },\n    memoryButton: {\n      ...buttonVariants.smallIconButton,\n      backgroundColor: 'rgba(100, 160, 100, 0.7)',\n      marginRight: '5px',\n      fontSize: '11px',\n      padding: '3px 6px'\n    },\n    memoryButtons: {\n      display: 'flex',\n      alignItems: 'center',\n      marginRight: '5px',\n      borderRight: '1px solid rgba(255, 255, 255, 0.2)',\n      paddingRight: '5px'\n    },\n    memoryCount: {\n      fontSize: '10px',\n      backgroundColor: 'rgba(80, 120, 80, 0.5)',\n      padding: '1px 5px',\n      borderRadius: '10px',\n      marginLeft: '5px'\n    }\n  };\n  \n  // Return the component JSX\n  return (\n    <div style={styles.container}>\n      <div style={styles.title}>\n        <h3 style={{ margin: 0 }}>Intensity Graph</h3>\n        <div style={styles.channelToggles}>\n          <button \n            style={{\n              ...styles.channelButton,\n              color: displayChannels.red ? 'rgb(255, 100, 100)' : 'rgba(255, 100, 100, 0.4)',\n              borderColor: displayChannels.red ? 'rgb(255, 100, 100)' : 'rgba(255, 100, 100, 0.2)'\n            }}\n            onClick={() => toggleChannel('red')}\n          >\n            R\n          </button>\n          <button \n            style={{\n              ...styles.channelButton,\n              color: displayChannels.green ? 'rgb(100, 255, 100)' : 'rgba(100, 255, 100, 0.4)',\n              borderColor: displayChannels.green ? 'rgb(100, 255, 100)' : 'rgba(100, 255, 100, 0.2)'\n            }}\n            onClick={() => toggleChannel('green')}\n          >\n            G\n          </button>\n          <button \n            style={{\n              ...styles.channelButton,\n              color: displayChannels.blue ? 'rgb(100, 100, 255)' : 'rgba(100, 100, 255, 0.4)',\n              borderColor: displayChannels.blue ? 'rgb(100, 100, 255)' : 'rgba(100, 100, 255, 0.2)'\n            }}\n            onClick={() => toggleChannel('blue')}\n          >\n            B\n          </button>\n          <button \n            style={{\n              ...styles.channelButton,\n              color: displayChannels.intensity ? 'rgb(220, 220, 220)' : 'rgba(220, 220, 220, 0.4)',\n              borderColor: displayChannels.intensity ? 'rgb(220, 220, 220)' : 'rgba(220, 220, 220, 0.2)'\n            }}\n            onClick={() => toggleChannel('intensity')}\n          >\n            I\n          </button>\n          <button \n            style={{\n              ...styles.channelButton,\n              color: 'rgb(255, 255, 100)',\n              borderColor: showCalibration ? 'rgb(255, 255, 100)' : 'rgba(255, 255, 100, 0.2)',\n              backgroundColor: showCalibration ? 'rgba(60, 60, 0, 0.6)' : 'rgba(30, 30, 30, 0.7)'\n            }}\n            onClick={toggleCalibration}\n            title=\"Toggle calibration controls\"\n          >\n            Cal\n          </button>\n        </div>\n      </div>\n      \n      <div style={styles.frameCountControl}>\n        <div style={styles.frameCountLabel}>Frame accumulation:</div>\n        <input \n          type=\"number\" \n          min=\"1\" \n          max=\"2000\"\n          value={frameAccumCount}\n          onChange={handleFrameCountChange}\n          style={styles.frameCountInput}\n        />\n        <button \n          style={{\n            ...buttonVariants.smallIconButton,\n            backgroundColor: isAccumulating ? 'rgba(255, 165, 0, 0.7)' : undefined\n          }}\n          onClick={toggleAccumulation}\n          title={isAccumulating ? \"Switch to live data\" : \"Switch to frame accumulation\"}\n        >\n          {isAccumulating ? \"Accumulating\" : \"Live\"}\n        </button>\n\n        {/*button that pauses graph*/}\n        \n        {/* Peak markers control */}\n        <div style={{ \n          display: 'flex', \n          alignItems: 'center', \n          gap: '5px',\n          marginLeft: '20px',\n          borderLeft: '1px solid rgba(255, 255, 255, 0.2)',\n          paddingLeft: '10px'\n        }}>\n          <div style={styles.frameCountLabel}>Peak markers:</div>\n          <input \n            type=\"number\" \n            min=\"0\" \n            max=\"10\"\n            value={peakCount}\n            onChange={handlePeakCountChange}\n            style={styles.frameCountInput}\n            title=\"Number of peak markers to display\"\n          />\n          <button \n            style={{\n              ...buttonVariants.smallIconButton,\n              backgroundColor: showPeakMarkers ? 'rgba(120, 120, 220, 0.7)' : undefined\n            }}\n            onClick={togglePeakMarkers}\n            title={showPeakMarkers ? \"Hide peak markers\" : \"Show peak markers\"}\n          >\n            {showPeakMarkers ? \"Peaks On\" : \"Peaks Off\"}\n          </button>\n        </div>\n        \n        {/* Add export controls */}\n        <div style={{ display: 'flex', marginLeft: 'auto', alignItems: 'center', gap: '5px' }}>\n          {/* Add memory buttons */}\n          <div style={styles.memoryButtons}>\n            <button\n              style={styles.memoryButton}\n              onClick={addToMemory}\n              title=\"Save current graph data to memory\"\n              disabled={!graphData && !accumulatedData}\n            >\n              To Memory\n            </button>\n            <button\n              style={{\n                ...styles.memoryButton,\n                backgroundColor: 'rgba(180, 80, 80, 0.7)'\n              }}\n              onClick={clearMemory}\n              title=\"Clear all memorized data\"\n              disabled={memorizedData.length === 0}\n            >\n              Clear Memory\n            </button>\n            {memorizedData.length > 0 && (\n              <span style={styles.memoryCount}>\n                {memorizedData.length}\n              </span>\n            )}\n          </div>\n          \n          <input\n            type=\"text\"\n            value={filePrefix}\n            onChange={(e) => setFilePrefix(e.target.value)}\n            placeholder=\"File prefix\"\n            style={{\n              ...styles.frameCountInput,\n              width: '100px'\n            }}\n            title=\"Prefix for the exported data filename\"\n          />\n          <label style={{ \n            fontSize: '11px', \n            color: 'rgba(255, 255, 255, 0.7)', \n            display: 'flex', \n            alignItems: 'center',\n            gap: '3px',\n            marginRight: '5px'\n          }}>\n            <input \n              type=\"checkbox\" \n              checked={includeDateInFilename}\n              onChange={(e) => setIncludeDateInFilename(e.target.checked)}\n              style={{ margin: 0 }}\n            />\n            Date\n          </label>\n          <button\n            style={{\n              ...buttonVariants.smallSecondary,\n              backgroundColor: 'rgba(20, 120, 220, 0.7)'\n            }}\n            onClick={exportGraphData}\n            title=\"Export graph data as text file\"\n            disabled={!graphData && !accumulatedData}\n          >\n            💾 Export Data\n          </button>\n          \n          {saveMessage && (\n            <span style={{\n              fontSize: '11px',\n              backgroundColor: 'rgba(0, 0, 0, 0.6)',\n              padding: '2px 6px',\n              borderRadius: '3px',\n              marginLeft: '5px',\n              color: 'rgba(255, 255, 255, 0.9)'\n            }}>\n              {saveMessage}\n            </span>\n          )}\n        </div>\n      </div>\n      \n      {showCalibration && (\n        <div style={styles.calibrationContainer}>\n          <div style={styles.calibrationHeader}>\n            <h4 style={styles.calibrationTitle}>Wavelength Calibration</h4>\n            <div>\n              <label style={{ fontSize: '11px', color: 'rgba(255, 255, 255, 0.7)' }}>\n                <input \n                  type=\"checkbox\" \n                  checked={useCalibration}\n                  onChange={toggleUseCalibration}\n                  style={styles.calibrationCheckbox}\n                />\n                Use Calibration\n              </label>\n            </div>\n          </div>\n          \n          <div style={styles.calibrationPoints}>\n            <div style={styles.calibrationPointsColumn}>\n              {calibrationPoints.map((point, index) => (\n                <div key={`point-${index}`} style={styles.calibrationPointsRow}>\n                  <div style={styles.calibrationLabel}>Point {index+1}:</div>\n                </div>\n              ))}\n            </div>\n            \n            <div style={styles.calibrationPointsColumn}>\n              {calibrationPoints.map((point, index) => (\n                <div key={`pos-${index}`} style={styles.calibrationPointsRow}>\n                  <span style={{ fontSize: '11px', color: 'rgba(255, 255, 255, 0.7)', marginRight: '4px' }}>Pos:</span>\n                  <input \n                    type=\"number\" \n                    min=\"0\" \n                    max=\"1\" \n                    step=\"0.0001\"\n                    value={point.position}\n                    onChange={(e) => updateCalibrationPoint(index, 'position', e.target.value)}\n                    style={styles.calibrationInput}\n                  />\n                </div>\n              ))}\n            </div>\n            \n            <div style={styles.calibrationPointsColumn}>\n              {calibrationPoints.map((point, index) => (\n                <div key={`wavelength-${index}`} style={styles.calibrationPointsRow}>\n                  <span style={{ fontSize: '11px', color: 'rgba(255, 255, 255, 0.7)', marginRight: '4px' }}>λ:</span>\n                  <input \n                    type=\"number\" \n                    min=\"200\" \n                    max=\"1200\" \n                    step=\"0.01\"\n                    value={point.wavelength}\n                    onChange={(e) => updateCalibrationPoint(index, 'wavelength', e.target.value)}\n                    style={styles.calibrationInput}\n                  />\n                  <span style={{ fontSize: '11px', color: 'rgba(255, 255, 255, 0.7)', marginLeft: '2px' }}>nm</span>\n                </div>\n              ))}\n            </div>\n            \n            <div style={{ marginLeft: 'auto', display: 'flex', alignItems: 'center' }}>\n              <label style={{ fontSize: '11px', color: 'rgba(255, 255, 255, 0.7)', display: 'flex', alignItems: 'center' }}>\n                <input \n                  type=\"checkbox\" \n                  checked={flipXAxis}\n                  onChange={toggleFlipXAxis}\n                  style={{ marginRight: '5px' }}\n                />\n                Flip X-Axis\n              </label>\n            </div>\n          </div>\n        </div>\n      )}\n      \n      <div \n        ref={graphContainerRef}\n        style={styles.graphView}\n        onMouseMove={handleMouseMove}\n        onMouseEnter={handleMouseEnter}\n        onMouseLeave={handleMouseLeave}\n      >\n        <canvas\n          ref={canvasRef}\n          style={styles.canvas}\n        />\n        \n        {!graphData && !accumulatedData && (\n          <div style={styles.noData}>\n            Draw a line on the camera feed to see intensity data\n          </div>\n        )}\n        \n        {/* Resize info overlay */}\n        {showResizeInfo && (\n          <div style={styles.resizeInfo}>\n            Height: {graphSize.height}px\n          </div>\n        )}\n        \n        {/* Resize handle */}\n        <div \n          style={styles.resizeHandle}\n          onMouseDown={handleResizeStart}\n          title=\"Resize graph height\"\n        >\n          <svg width=\"12\" height=\"12\" viewBox=\"0 0 12 12\">\n            <path \n              d=\"M2,6 L10,6 M2,9 L10,9\" \n              stroke=\"white\" \n              strokeWidth=\"1.5\"\n              strokeLinecap=\"round\"\n            />\n          </svg>\n        </div>\n      </div>\n    </div>\n  );\n});\n\n// Add display name for debugging\nGraphComponent.displayName = 'GraphComponent';\n\nexport default GraphComponent; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}