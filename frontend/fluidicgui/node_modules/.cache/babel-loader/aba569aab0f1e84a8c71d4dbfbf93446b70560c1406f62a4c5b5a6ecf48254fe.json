{"ast":null,"code":"// mqttDebugger.js - Utility to help debug MQTT communication\n\n// Function to parse device info from different payload formats\nexport const parseDeviceInfo = payload => {\n  if (!payload) {\n    console.error(\"Empty payload received\");\n    return null;\n  }\n  console.log('ðŸ” Attempting to parse device payload:', payload);\n  let MQTTname, type;\n  const payloadStr = typeof payload === 'string' ? payload : JSON.stringify(payload);\n\n  // Try different formats\n\n  // Format 1: \"MQTTname:type\"\n  if (payloadStr.includes(':')) {\n    [MQTTname, type] = payloadStr.split(':');\n    console.log('ðŸ” Parsed using colon format:', {\n      MQTTname,\n      type\n    });\n  }\n  // Format 2: JSON object\n  else {\n    try {\n      let jsonData;\n      // Check if we need to parse it\n      if (typeof payload === 'object') {\n        jsonData = payload;\n      } else {\n        jsonData = JSON.parse(payloadStr);\n      }\n      MQTTname = jsonData.MQTTname || jsonData.name || jsonData.mqtt_name;\n      type = jsonData.type || jsonData.device_type;\n      console.log('ðŸ” Parsed using JSON format:', {\n        MQTTname,\n        type\n      });\n    } catch (e) {\n      console.error('Failed to parse payload as JSON:', e);\n    }\n  }\n  if (MQTTname && type) {\n    return {\n      MQTTname,\n      type\n    };\n  }\n  console.error('Could not parse device info from payload:', payload);\n  return null;\n};\n\n// Create a WebSocket connection with auto-reconnect\nexport const createWebSocket = (url, options = {}) => {\n  const {\n    maxRetries = 5,\n    retryDelay = 3000,\n    onMessage,\n    onOpen,\n    onClose,\n    onError\n  } = options;\n  let ws = null;\n  let retryCount = 0;\n  let reconnectTimeout = null;\n  const connect = () => {\n    ws = new WebSocket(url);\n    ws.onopen = () => {\n      console.log('ðŸ”Œ WebSocket connected');\n      retryCount = 0;\n      if (onOpen) onOpen(ws);\n    };\n    ws.onmessage = event => {\n      try {\n        const data = JSON.parse(event.data);\n\n        // Check if payload is a string that looks like JSON and parse it\n        if (data.payload && typeof data.payload === 'string') {\n          try {\n            // Check if the string starts and ends with quotes (already serialized string)\n            if (data.payload.startsWith('\"') && data.payload.endsWith('\"')) {\n              // Remove the extra quotes\n              data.payload = JSON.parse(data.payload);\n            }\n          } catch (e) {\n            // If parsing fails, keep the original payload\n            console.log('Note: Payload is not a JSON string');\n          }\n        }\n        /*\r\n        console.log('ðŸ”Œ Received WebSocket message:', {\r\n          topic: data.topic,\r\n          payload: data.payload,\r\n          timestamp: new Date().toISOString()\r\n        });\r\n        */\n        // Handle system status messages\n        if (data.topic === 'system/status') {\n          console.log('ðŸ”Œ MQTT Broker status:', {\n            connected: data.payload.mqttConnected,\n            topics: data.payload.subscribedTopics\n          });\n        }\n\n        // Log all messages on common/* topics\n        if (data.topic && data.topic.startsWith('common/')) {\n          console.log('ðŸ”Œ Common topic message:', {\n            topic: data.topic,\n            payload: data.payload,\n            timestamp: new Date().toISOString()\n          });\n        }\n        if (onMessage) onMessage(data);\n      } catch (error) {\n        console.error('Error processing WebSocket message:', error);\n        console.log('Raw message:', event.data);\n      }\n    };\n    ws.onclose = () => {\n      console.log('ðŸ”Œ WebSocket disconnected');\n      if (retryCount < maxRetries) {\n        retryCount++;\n        console.log(`Retrying connection (${retryCount}/${maxRetries}) in ${retryDelay}ms...`);\n        reconnectTimeout = setTimeout(connect, retryDelay);\n      } else {\n        console.error('Max retries reached, giving up');\n      }\n      if (onClose) onClose();\n    };\n    ws.onerror = error => {\n      console.error('ðŸ”Œ WebSocket error:', error);\n      if (onError) onError(error);\n    };\n  };\n\n  // Initial connection\n  connect();\n\n  // Return cleanup function\n  return () => {\n    if (reconnectTimeout) {\n      clearTimeout(reconnectTimeout);\n    }\n    if (ws) {\n      ws.close();\n    }\n  };\n};\n\n// Enhances the WebSocket handling for MQTT messages\nexport const setupMQTTDebugger = () => {\n  console.log('ðŸ” MQTT Debugger initialized');\n\n  // Add a global helper to test message parsing\n  window.testMQTTParser = payload => {\n    console.log('Test result:', parseDeviceInfo(payload));\n  };\n\n  // Add a global function to send a test scan message\n  window.sendTestScan = () => {\n    if (window.appWebSocket && window.appWebSocket.readyState === WebSocket.OPEN) {\n      const testMessage = {\n        topic: \"common/device_scan\",\n        payload: {}\n      };\n      window.appWebSocket.send(JSON.stringify(testMessage));\n      console.log('Test scan message sent!');\n    } else {\n      console.error('WebSocket not available for test');\n    }\n  };\n\n  // Add a global function to check MQTT status\n  window.checkMQTTStatus = () => {\n    if (window.appWebSocket && window.appWebSocket.readyState === WebSocket.OPEN) {\n      fetch('http://localhost:4000/mqtt-status').then(response => response.json()).then(status => {\n        console.log('ðŸ”Œ MQTT Status:', status);\n      }).catch(error => {\n        console.error('Error fetching MQTT status:', error);\n      });\n    }\n  };\n\n  // Monkey patch console.log to highlight MQTT messages\n  /*const originalLog = console.log;\r\n  console.log = function(...args) {\r\n    if (args.length > 0 && typeof args[0] === 'string') {\r\n      if (args[0].includes('MQTT') || args[0].includes('device_')) {\r\n        args[0] = `ðŸ”Œ ${args[0]}`;\r\n      }\r\n    }\r\n    originalLog.apply(console, args);\r\n  };*/\n};\n\n// Export default function to initialize everything\nexport default function initMQTTDebugging() {\n  setupMQTTDebugger();\n}","map":{"version":3,"names":["parseDeviceInfo","payload","console","error","log","MQTTname","type","payloadStr","JSON","stringify","includes","split","jsonData","parse","name","mqtt_name","device_type","e","createWebSocket","url","options","maxRetries","retryDelay","onMessage","onOpen","onClose","onError","ws","retryCount","reconnectTimeout","connect","WebSocket","onopen","onmessage","event","data","startsWith","endsWith","topic","connected","mqttConnected","topics","subscribedTopics","timestamp","Date","toISOString","onclose","setTimeout","onerror","clearTimeout","close","setupMQTTDebugger","window","testMQTTParser","sendTestScan","appWebSocket","readyState","OPEN","testMessage","send","checkMQTTStatus","fetch","then","response","json","status","catch","initMQTTDebugging"],"sources":["E:/flow chemistry/fluidicGUI/frontend/fluidicgui/src/utils/mqttDebugger.js"],"sourcesContent":["// mqttDebugger.js - Utility to help debug MQTT communication\r\n\r\n// Function to parse device info from different payload formats\r\nexport const parseDeviceInfo = (payload) => {\r\n  if (!payload) {\r\n    console.error(\"Empty payload received\");\r\n    return null;\r\n  }\r\n  \r\n  console.log('ðŸ” Attempting to parse device payload:', payload);\r\n  \r\n  let MQTTname, type;\r\n  const payloadStr = typeof payload === 'string' ? payload : JSON.stringify(payload);\r\n  \r\n  // Try different formats\r\n  \r\n  // Format 1: \"MQTTname:type\"\r\n  if (payloadStr.includes(':')) {\r\n    [MQTTname, type] = payloadStr.split(':');\r\n    console.log('ðŸ” Parsed using colon format:', { MQTTname, type });\r\n  } \r\n  // Format 2: JSON object\r\n  else {\r\n    try {\r\n      let jsonData;\r\n      // Check if we need to parse it\r\n      if (typeof payload === 'object') {\r\n        jsonData = payload;\r\n      } else {\r\n        jsonData = JSON.parse(payloadStr);\r\n      }\r\n      \r\n      MQTTname = jsonData.MQTTname || jsonData.name || jsonData.mqtt_name;\r\n      type = jsonData.type || jsonData.device_type;\r\n      console.log('ðŸ” Parsed using JSON format:', { MQTTname, type });\r\n    } catch (e) {\r\n      console.error('Failed to parse payload as JSON:', e);\r\n    }\r\n  }\r\n  \r\n  if (MQTTname && type) {\r\n    return { MQTTname, type };\r\n  }\r\n  \r\n  console.error('Could not parse device info from payload:', payload);\r\n  return null;\r\n};\r\n\r\n// Create a WebSocket connection with auto-reconnect\r\nexport const createWebSocket = (url, options = {}) => {\r\n  const {\r\n    maxRetries = 5,\r\n    retryDelay = 3000,\r\n    onMessage,\r\n    onOpen,\r\n    onClose,\r\n    onError\r\n  } = options;\r\n\r\n  let ws = null;\r\n  let retryCount = 0;\r\n  let reconnectTimeout = null;\r\n\r\n  const connect = () => {\r\n    ws = new WebSocket(url);\r\n    \r\n    ws.onopen = () => {\r\n      console.log('ðŸ”Œ WebSocket connected');\r\n      retryCount = 0;\r\n      if (onOpen) onOpen(ws);\r\n    };\r\n\r\n    ws.onmessage = (event) => {\r\n      try {\r\n        const data = JSON.parse(event.data);\r\n        \r\n        // Check if payload is a string that looks like JSON and parse it\r\n        if (data.payload && typeof data.payload === 'string') {\r\n          try {\r\n            // Check if the string starts and ends with quotes (already serialized string)\r\n            if (data.payload.startsWith('\"') && data.payload.endsWith('\"')) {\r\n              // Remove the extra quotes\r\n              data.payload = JSON.parse(data.payload);\r\n            }\r\n          } catch (e) {\r\n            // If parsing fails, keep the original payload\r\n            console.log('Note: Payload is not a JSON string');\r\n          }\r\n        }\r\n        /*\r\n        console.log('ðŸ”Œ Received WebSocket message:', {\r\n          topic: data.topic,\r\n          payload: data.payload,\r\n          timestamp: new Date().toISOString()\r\n        });\r\n        */\r\n        // Handle system status messages\r\n        if (data.topic === 'system/status') {\r\n          console.log('ðŸ”Œ MQTT Broker status:', {\r\n            connected: data.payload.mqttConnected,\r\n            topics: data.payload.subscribedTopics\r\n          });\r\n        }\r\n        \r\n        // Log all messages on common/* topics\r\n        if (data.topic && data.topic.startsWith('common/')) {\r\n          console.log('ðŸ”Œ Common topic message:', {\r\n            topic: data.topic,\r\n            payload: data.payload,\r\n            timestamp: new Date().toISOString()\r\n          });\r\n        }\r\n        \r\n        if (onMessage) onMessage(data);\r\n      } catch (error) {\r\n        console.error('Error processing WebSocket message:', error);\r\n        console.log('Raw message:', event.data);\r\n      }\r\n    };\r\n\r\n    ws.onclose = () => {\r\n      console.log('ðŸ”Œ WebSocket disconnected');\r\n      \r\n      if (retryCount < maxRetries) {\r\n        retryCount++;\r\n        console.log(`Retrying connection (${retryCount}/${maxRetries}) in ${retryDelay}ms...`);\r\n        reconnectTimeout = setTimeout(connect, retryDelay);\r\n      } else {\r\n        console.error('Max retries reached, giving up');\r\n      }\r\n      \r\n      if (onClose) onClose();\r\n    };\r\n\r\n    ws.onerror = (error) => {\r\n      console.error('ðŸ”Œ WebSocket error:', error);\r\n      if (onError) onError(error);\r\n    };\r\n  };\r\n\r\n  // Initial connection\r\n  connect();\r\n\r\n  // Return cleanup function\r\n  return () => {\r\n    if (reconnectTimeout) {\r\n      clearTimeout(reconnectTimeout);\r\n    }\r\n    if (ws) {\r\n      ws.close();\r\n    }\r\n  };\r\n};\r\n\r\n// Enhances the WebSocket handling for MQTT messages\r\nexport const setupMQTTDebugger = () => {\r\n  console.log('ðŸ” MQTT Debugger initialized');\r\n  \r\n  // Add a global helper to test message parsing\r\n  window.testMQTTParser = (payload) => {\r\n    console.log('Test result:', parseDeviceInfo(payload));\r\n  };\r\n  \r\n  // Add a global function to send a test scan message\r\n  window.sendTestScan = () => {\r\n    if (window.appWebSocket && window.appWebSocket.readyState === WebSocket.OPEN) {\r\n      const testMessage = {\r\n        topic: \"common/device_scan\",\r\n        payload: {}\r\n      };\r\n      window.appWebSocket.send(JSON.stringify(testMessage));\r\n      console.log('Test scan message sent!');\r\n    } else {\r\n      console.error('WebSocket not available for test');\r\n    }\r\n  };\r\n  \r\n  // Add a global function to check MQTT status\r\n  window.checkMQTTStatus = () => {\r\n    if (window.appWebSocket && window.appWebSocket.readyState === WebSocket.OPEN) {\r\n      fetch('http://localhost:4000/mqtt-status')\r\n        .then(response => response.json())\r\n        .then(status => {\r\n          console.log('ðŸ”Œ MQTT Status:', status);\r\n        })\r\n        .catch(error => {\r\n          console.error('Error fetching MQTT status:', error);\r\n        });\r\n    }\r\n  };\r\n  \r\n  // Monkey patch console.log to highlight MQTT messages\r\n  /*const originalLog = console.log;\r\n  console.log = function(...args) {\r\n    if (args.length > 0 && typeof args[0] === 'string') {\r\n      if (args[0].includes('MQTT') || args[0].includes('device_')) {\r\n        args[0] = `ðŸ”Œ ${args[0]}`;\r\n      }\r\n    }\r\n    originalLog.apply(console, args);\r\n  };*/\r\n};\r\n\r\n// Export default function to initialize everything\r\nexport default function initMQTTDebugging() {\r\n  setupMQTTDebugger();\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}