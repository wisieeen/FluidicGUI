{"ast":null,"code":"var _jsxFileName = \"E:\\\\flow chemistry\\\\fluidicGUI\\\\frontend\\\\fluidicgui\\\\src\\\\components\\\\Simulation\\\\Simulation.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useCallback, useRef, Suspense } from 'react';\nimport { ReactFlowProvider, useNodesState, useEdgesState } from 'react-flow-renderer';\nimport PumpActions from './NodeActions/PumpActions';\nimport DraggablePanel from './DraggablePanel';\nimport { convertToHardwareValuesPump } from '../../utils/pumpCalculations';\nimport { useButtonStyles } from '../../styles/ButtonStyleProvider';\nimport { backgroundVariants } from '../../styles/backgroundStyles';\nimport { findOutletNode, findFurthestNode, orderNodesByDistance, calculateEdgeVolume, getVolumeBetweenNodes, findConnectedPump, getPumpSpeed, getPumpsBetweenPositions, cleanAndSortEventList, getPumpSpeedAtTime, sendEventsToDevices, setOfMainLineNodes, setOfSecondaryLineNodes } from '../../utils/simulationUtils';\nimport './simulation.css'; // We'll create this CSS file\nimport SvgDefs from './SvgDefs';\nimport { calculateEdgePoints, createLabels } from '../../utils/flowchartUtils';\nimport USBSpectrometer from './USBSpectrometer';\nimport SpectrometerMQTT from './SpectrometerMQTT';\nimport PumpPanel from './PumpPanel';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst Simulation = ({\n  nodes = [],\n  edges = [],\n  droplets = [],\n  selectedCarrierPumps = [],\n  onBack,\n  onNext\n}) => {\n  _s();\n  var _dropletHistory$curre, _selectedNode$data, _selectedNode$data2, _selectedNode$data3;\n  const buttonVariants = useButtonStyles();\n  const [graphData, setGraphData] = useState({\n    nodes: [],\n    links: []\n  });\n  const [simulationDroplets, setSimulationDroplets] = useState([]);\n  const [isSimulationRunning, setIsSimulationRunning] = useState(false);\n  const [key, setKey] = useState(0);\n  const [currentTime, setCurrentTime] = useState(0);\n  const [timeScale, setTimeScale] = useState(1); // Default 1x speed\n  const animationFrameRef = useRef();\n  const lastFrameTimeRef = useRef();\n  const [currentBlockDroplets, setCurrentBlockDroplets] = useState([]);\n  const [dropletHistory, setDropletHistory] = useState([]);\n  const [currentTimepoint, setCurrentTimepoint] = useState(0);\n  const [pumpEvents, setPumpEvents] = useState([]);\n  const [detectorEvents, setDetectorEvents] = useState([]);\n  const [displayPumpSpeeds, setDisplayPumpSpeeds] = useState(false);\n  const [displayNodeIds, setDisplayNodeIds] = useState(false);\n  const [displayDropletInfo, setDisplayDropletInfo] = useState(false);\n  const [displayDropletGaps, setDisplayDropletGaps] = useState(true);\n  const [displayEdgeLabels, setDisplayEdgeLabels] = useState(false);\n  const [isDisplayMenuOpen, setDisplayMenuOpen] = useState(false);\n  const [displayTimelineDropletInfo, setDisplayTimelineDropletInfo] = useState(false);\n  const [displayDetectorEvents, setDisplayDetectorEvents] = useState(false);\n  const displayMenuRef = useRef(null);\n  const [selectedNode, setSelectedNode] = useState(null);\n  const [ws, setWs] = useState(null);\n  const [pumpPanelPosition, setPumpPanelPosition] = useState({\n    x: window.innerWidth - 300,\n    y: 100\n  });\n  const [visiblePumpPanel, setVisiblePumpPanel] = useState(null);\n  const [isSendingEvents, setIsSendingEvents] = useState(false);\n  const graphRefs = useRef({});\n  const [overlayComponent, setOverlayComponent] = useState(null);\n\n  // Add at the beginning of the component, after the state initialization\n  useEffect(() => {\n    // Log all nodes and their types for debugging\n    console.log('All nodes:', nodes);\n    if (nodes && nodes.length > 0) {\n      console.log('Node types in simulation:', nodes.map(node => {\n        var _node$data;\n        return {\n          id: node.id,\n          type: node.type,\n          dataType: (_node$data = node.data) === null || _node$data === void 0 ? void 0 : _node$data.type\n        };\n      }));\n    }\n  }, [nodes]);\n  useEffect(() => {\n    // Create WebSocket connection\n    const websocket = new WebSocket('ws://localhost:4000');\n    websocket.onopen = () => {\n      console.log('Connected to WebSocket server');\n    };\n    websocket.onerror = error => {\n      console.error('WebSocket error:', error);\n    };\n    setWs(websocket);\n\n    // Cleanup on unmount\n    return () => {\n      if (websocket) {\n        websocket.close();\n      }\n    };\n  }, []);\n  const sendingEventsToDevices = () => {\n    setIsSendingEvents(true);\n    sendEventsToDevices(pumpEvents, ws, nodes);\n    // Reset simulation state\n    setCurrentTime(0);\n    setCurrentTimepoint(0);\n    setIsSimulationRunning(true);\n    setDropletHistory([]);\n    // Generate new event list\n    generateEventList([{\n      droplets: droplets\n    }]);\n  };\n\n  // Add effect to handle automatic memory addition when events are being sent\n  useEffect(() => {\n    if (isSendingEvents) {\n      // Get all graph refs and add data to memory\n      Object.values(graphRefs.current).forEach(graphRef => {\n        if (graphRef && graphRef.current && graphRef.current.addToMemory) {\n          graphRef.current.addToMemory();\n        }\n      });\n    }\n  }, [isSendingEvents]);\n  const eventType = ['setPumpSpeed', 'setThermostatTemperature', 'setLedIntensity', 'wait', 'blockEnd'];\n  const calculateVolumesBetweenThermostats = graphData => {\n    // Find outlet node first\n    const outletNode = findOutletNode(graphData.nodes);\n    const visited = new Set();\n    const queue = [[outletNode.id, 0, []]]; // [nodeId, accumulated volume, path of thermostats]\n    const thermostatVolumes = [];\n    while (queue.length > 0) {\n      let [currentNodeId, accumulatedVolume, thermostatPath] = queue.shift();\n      const currentNode = graphData.nodes.find(n => n.id === currentNodeId);\n      if (!currentNode) continue;\n\n      // Track all visited nodes to prevent infinite loops\n      if (visited.has(currentNodeId)) continue;\n      visited.add(currentNodeId);\n\n      // If we found a thermostat, add it to the path\n      let updatedPath = [...thermostatPath];\n      if (currentNode.type === 'thermostat') {\n        if (thermostatPath.length > 0) {\n          thermostatVolumes.push({\n            startThermostatId: thermostatPath[thermostatPath.length - 1],\n            endThermostatId: currentNodeId,\n            volume: accumulatedVolume\n          });\n        }\n        updatedPath.push(currentNodeId);\n        // Reset accumulated volume after finding a thermostat\n        accumulatedVolume = 0;\n      }\n\n      // Find all connected edges and nodes\n      const connectedEdges = graphData.links.filter(link => link.source === currentNodeId || link.target === currentNodeId);\n      for (const edge of connectedEdges) {\n        const nextNodeId = edge.source === currentNodeId ? edge.target : edge.source;\n        const nextNode = graphData.nodes.find(n => n.id === nextNodeId);\n\n        // Skip paths to pumps\n        if (nextNode && nextNode.type !== 'pump') {\n          const edgeVolume = calculateEdgeVolume(edge);\n          queue.push([nextNodeId, accumulatedVolume + edgeVolume, updatedPath]);\n        }\n      }\n    }\n    return thermostatVolumes;\n  };\n  //add something to handle lack of thermostat\n  const divideDropletsIntoBlocks = (droplets, thermostatVolumes) => {\n    if (thermostatVolumes.length === 0) {\n      return [{\n        droplets: droplets,\n        thermostatId: null,\n        totalVolume: droplets.reduce((acc, droplet) => acc + droplet.actualVolume, 0),\n        temperature: null,\n        time: null\n      }];\n    }\n    const furthestNode = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links);\n    const volumeToFurthestNode = getVolumeBetweenNodes(thermostatVolumes[0].endThermostatId, furthestNode.id, graphData.nodes, graphData.links);\n    if (!droplets.length || !thermostatVolumes.length) return [];\n    const blocks = [];\n    let currentBlock = {\n      droplets: [],\n      thermostatId: thermostatVolumes[0].endThermostatId,\n      totalVolume: 0,\n      temperature: null,\n      time: null\n    };\n\n    // Helper to finalize a block and start a new one\n    const finalizeBlock = (thermostatId, temperature, time) => {\n      if (currentBlock.droplets.length > 0) {\n        // Add volumeToFurthestNode to the surfixVolume of the last droplet in the block\n        const lastDroplet = currentBlock.droplets[currentBlock.droplets.length - 1];\n        const surfixParam = lastDroplet.parameters.find(p => p.name === 'surfixVolume');\n        if (surfixParam) {\n          surfixParam.value = Math.max(volumeToFurthestNode, surfixParam.value);\n        } else {\n          lastDroplet.parameters.push({\n            name: 'surfixVolume',\n            value: volumeToFurthestNode\n          });\n        }\n        blocks.push({\n          ...currentBlock\n        });\n      }\n      currentBlock = {\n        droplets: [],\n        thermostatId: thermostatId,\n        totalVolume: 0,\n        temperature: temperature,\n        time: time\n      };\n    };\n\n    // Process droplets in order\n    for (let i = 0; i < droplets.length; i++) {\n      var _droplet$parameters$f, _droplet$parameters$f2, _droplet$parameters$f3, _droplet$parameters$f4, _droplet$parameters$f5;\n      const droplet = droplets[i];\n      const temperature = (_droplet$parameters$f = droplet.parameters.find(p => p.name === 'temperature')) === null || _droplet$parameters$f === void 0 ? void 0 : _droplet$parameters$f.value;\n      const time = (_droplet$parameters$f2 = droplet.parameters.find(p => p.name === 'time')) === null || _droplet$parameters$f2 === void 0 ? void 0 : _droplet$parameters$f2.value;\n\n      // Start new block if temperature or time changes, or if volume limit exceeded\n      const relevantVolume = thermostatVolumes.find(tv => tv.startThermostatId === currentBlock.thermostatId || tv.endThermostatId === currentBlock.thermostatId);\n      let dropletVolume = (_droplet$parameters$f3 = droplet.parameters.find(p => p.name === 'volume')) === null || _droplet$parameters$f3 === void 0 ? void 0 : _droplet$parameters$f3.value;\n      dropletVolume += (_droplet$parameters$f4 = droplet.parameters.find(p => p.name === 'prefixVolume')) === null || _droplet$parameters$f4 === void 0 ? void 0 : _droplet$parameters$f4.value;\n      if (currentBlock.temperature !== temperature || currentBlock.time !== time || relevantVolume && currentBlock.totalVolume + dropletVolume > relevantVolume.volume) {\n        finalizeBlock(thermostatVolumes[0].endThermostatId, temperature, time);\n      }\n      dropletVolume += (_droplet$parameters$f5 = droplet.parameters.find(p => p.name === 'surfixVolume')) === null || _droplet$parameters$f5 === void 0 ? void 0 : _droplet$parameters$f5.value;\n      // Add droplet to current block\n      currentBlock.droplets.push(droplet);\n      currentBlock.totalVolume += dropletVolume;\n      currentBlock.temperature = temperature;\n      currentBlock.time = time;\n    }\n\n    // Finalize last block\n    finalizeBlock(null, null, null);\n    return blocks;\n  };\n  function printDropletFrontPositionsAndSpeeds(droplets) {\n    droplets.forEach(droplet => {\n      console.log(`Droplet ID: ${droplet.id}, Front Volumetric Position: ${droplet.frontVolumetricPosition}, Front time to next node  : ${droplet.frontTimeToReachNextNode}, Front Volumetric Distance to next node: ${droplet.frontVolumetricDistanceToNextNode}, Rear Volumetric Position: ${droplet.rearVolumetricPosition}, Rear time to next node: ${droplet.rearTimeToReachNextNode}, Rear Volumetric Distance to next node: ${droplet.rearVolumetricDistanceToNextNode}, frontNextNodeID: ${droplet.frontNextNodeID}, rearNextNodeID: ${droplet.rearNextNodeID}`);\n    });\n  }\n  const extractPumpEvents = eventList => {\n    // eventList is now an array of arrays, where each inner array contains events for a specific pump\n    return eventList.flat() // Flatten the array of arrays\n    .filter(event => event.type === 'setPumpSpeed').sort((a, b) => a.time - b.time);\n  };\n  const extractDetectorEvents = eventList => {\n    // Extract detector/spectrometer measurement events\n    return eventList.flat() // Flatten the array of arrays\n    .filter(event => event.type === 'setDetectorMeasurement').sort((a, b) => a.time - b.time);\n  };\n  const recalculateEventListForDevices = eventList => {\n    const deviceEventMap = new Map();\n    const convertPumpEvent = (event, deviceProperties) => {\n      var _deviceProperties$fin, _deviceProperties$fin2, _deviceProperties$fin3, _deviceProperties$fin4;\n      // Find properties by name from the properties array\n      const syringeDiameter = ((_deviceProperties$fin = deviceProperties.find(p => p.name === 'diameter')) === null || _deviceProperties$fin === void 0 ? void 0 : _deviceProperties$fin.default) || 0;\n      const syringeLength = ((_deviceProperties$fin2 = deviceProperties.find(p => p.name === 'length')) === null || _deviceProperties$fin2 === void 0 ? void 0 : _deviceProperties$fin2.default) || 0;\n      const stepsPerRevolution = ((_deviceProperties$fin3 = deviceProperties.find(p => p.name === 'steps per revolution')) === null || _deviceProperties$fin3 === void 0 ? void 0 : _deviceProperties$fin3.default) || 0;\n      const lead = ((_deviceProperties$fin4 = deviceProperties.find(p => p.name === 'lead')) === null || _deviceProperties$fin4 === void 0 ? void 0 : _deviceProperties$fin4.default) || 0;\n      const syringeArea = Math.PI * Math.pow(syringeDiameter / 2, 2);\n      const linearSpeed = Math.abs(event.value) / syringeArea;\n      const stepsPerMm = stepsPerRevolution / lead;\n      const stepsPerSecond = linearSpeed * stepsPerMm;\n      const delayMicroseconds = stepsPerSecond > 0 ? Math.round(1000000 / stepsPerSecond) : 0;\n      return {\n        target: event.target,\n        time: Math.round(event.time * 1000000),\n        delay: delayMicroseconds\n      };\n    };\n    const convertThermostatEvent = (event, deviceProperties) => {\n      // Placeholder for thermostat conversion logic\n      return {\n        target: event.target,\n        time: Math.round(event.time * 1000000),\n        temperature: event.value\n        // Add other thermostat-specific parameters here\n      };\n    };\n    const convertLedEvent = (event, deviceProperties) => {\n      // Placeholder for LED conversion logic\n      return {\n        target: event.target,\n        time: Math.round(event.time * 1000000),\n        intensity: event.value\n        // Add other LED-specific parameters here\n      };\n    };\n    const convertDetectorEvent = (event, deviceProperties) => {\n      // Placeholder for detector conversion logic\n      return {\n        target: event.target,\n        time: Math.round(event.time * 1000000),\n        setting: event.value\n        // Add other detector-specific parameters here\n      };\n    };\n    eventList.forEach(deviceEventList => {\n      if (!deviceEventList.length) return;\n      const targetId = deviceEventList[0].target;\n      const deviceNode = nodes.find(node => node.id === targetId);\n      if (!deviceNode || !deviceNode.data) {\n        console.error(`Device node or data not found for ID: ${targetId}`);\n        return;\n      }\n      const deviceEvents = deviceEventList.map(event => {\n        switch (event.type) {\n          case 'setPumpSpeed':\n            return convertPumpEvent(event, deviceNode.data.properties);\n          case 'setThermostatTemperature':\n            return convertThermostatEvent(event, deviceNode.data.properties);\n          case 'setLedIntensity':\n            return convertLedEvent(event, deviceNode.data.properties);\n          case 'setDetectorSetting':\n            return convertDetectorEvent(event, deviceNode.data.properties);\n          default:\n            console.warn(`Unknown event type: ${event.type}`);\n            return null;\n        }\n      }).filter(Boolean); // Remove any null events\n\n      if (deviceEvents.length > 0) {\n        deviceEventMap.set(targetId, deviceEvents);\n      }\n    });\n    console.log('deviceEventMap: ', Array.from(deviceEventMap.values()));\n    return Array.from(deviceEventMap.values());\n  };\n  const generateEventList = blocks => {\n    // Early exit if blocks array is invalid\n    if (!blocks || !Array.isArray(blocks) || blocks.length === 0) {\n      console.warn('No valid blocks found for event generation');\n      return [];\n    }\n    const orderedNodes = orderNodesByDistance(findOutletNode(graphData.nodes), graphData.nodes, graphData.links);\n    console.log('orderedNodes: ', orderedNodes);\n\n    // Early exit if no ordered nodes\n    if (!orderedNodes || orderedNodes.length === 0) {\n      console.warn('No ordered nodes found for event generation');\n      return [];\n    }\n    let eventList = [];\n    let dropletSnapshot = [];\n\n    // Validate block droplets\n    if (!blocks[0] || !blocks[0].droplets || !Array.isArray(blocks[0].droplets) || blocks[0].droplets.length === 0) {\n      console.warn('No valid droplets found in blocks for event generation');\n      return [];\n    }\n    const i = 0;\n    const currentBlockDroplets = blocks[i].droplets;\n\n    // Add fallback for volumetricSpeed in case it's not found\n    const dropletWithParams = currentBlockDroplets.find(d => d && d.parameters && Array.isArray(d.parameters));\n    if (!dropletWithParams) {\n      console.warn('No droplet with valid parameters found');\n      return [];\n    }\n\n    // Make sure we can find the volumetricSpeed parameter or use a default\n    const volumetricSpeedParam = dropletWithParams.parameters.find(p => p && p.name === 'volumetricSpeed');\n    const commonVolumetricSpeed = (volumetricSpeedParam === null || volumetricSpeedParam === void 0 ? void 0 : volumetricSpeedParam.value) || 1;\n    console.log('Using volumetricSpeed:', commonVolumetricSpeed);\n\n    //adds some parameters to nodes\n    orderedNodes.forEach(node => {\n      node.inletVolumetricSpeed = commonVolumetricSpeed;\n      node.outletVolumetricSpeed = commonVolumetricSpeed;\n      const pump = findConnectedPump(node.node.id, graphData.nodes, graphData.links);\n      if (pump) {\n        node.connectedPump = pump;\n      } else {\n        node.connectedPump = 0;\n      }\n      node.connectedPumpRatio = 0;\n      node.connectedPumpSpeedAtPause = 0;\n      node.pumpSpeedMultiplier = 1;\n      //node.requestedRatio = 0;\n      node.pauseLevel = 0;\n    });\n    //ustawia carrier pump na odpowiednią predkość\n    const carrierPumpConnector = graphData.links.find(link => link.source === selectedCarrierPumps[0]).target;\n    if (carrierPumpConnector) {\n      const connectorNode = orderedNodes.find(node => node.node.id === carrierPumpConnector);\n      connectorNode.inletVolumetricSpeed = commonVolumetricSpeed;\n      connectorNode.outletVolumetricSpeed = commonVolumetricSpeed;\n      connectorNode.connectedPump = graphData.nodes.find(node => node.id === selectedCarrierPumps[0]);\n      connectorNode.connectedPumpRatio = 1;\n      connectorNode.connectedPumpSpeedAtPause = commonVolumetricSpeed;\n      //connectorNode.requestedRatio = 0;\n      connectorNode.pauseLevel = 0;\n    }\n    let event = {\n      //it is ok\n      type: 'setPumpSpeed',\n      target: selectedCarrierPumps[0],\n      time: 0,\n      value: commonVolumetricSpeed\n    };\n    eventList.push(event);\n    orderedNodes.filter(node => node.node.type === 'pump' && node.node.id !== selectedCarrierPumps[0]).forEach(pump => {\n      event = {\n        //it is ok\n        type: 'setPumpSpeed',\n        target: pump.node.id,\n        time: 0,\n        value: 0\n      };\n      eventList.push(event);\n    });\n    let position = -0.001;\n    //prepares all droplets in block and calculates some parameters\n    currentBlockDroplets.forEach(droplet => {\n      var _droplet$parameters$f6, _droplet$parameters$f7;\n      const prefixVolume = (_droplet$parameters$f6 = droplet.parameters.find(p => p.name === 'prefixVolume')) === null || _droplet$parameters$f6 === void 0 ? void 0 : _droplet$parameters$f6.value;\n      const surfixVolume = (_droplet$parameters$f7 = droplet.parameters.find(p => p.name === 'surfixVolume')) === null || _droplet$parameters$f7 === void 0 ? void 0 : _droplet$parameters$f7.value;\n      droplet.frontVolumetricSpeed = commonVolumetricSpeed;\n      droplet.rearVolumetricSpeed = commonVolumetricSpeed;\n      droplet.frontVolumetricPosition = position - prefixVolume;\n      droplet.rearVolumetricPosition = droplet.frontVolumetricPosition;\n      droplet.frontVolumetricDistanceToNextNode = Math.abs(droplet.frontVolumetricPosition);\n      droplet.rearVolumetricDistanceToNextNode = Math.abs(droplet.rearVolumetricPosition);\n      droplet.frontTimeToReachNextNode = 0;\n      droplet.rearTimeToReachNextNode = 0;\n      droplet.frontNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\n      droplet.rearNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\n      droplet.pumpSpeedMultiplier = 1;\n      droplet.pauseLevel = 0;\n      droplet.frontVolumetricSpeedAtPause = 0;\n      droplet.rearVolumetricSpeedAtPause = 0;\n      droplet.stoppingDroplet = false;\n      droplet.initialPumping = false;\n      position -= prefixVolume + surfixVolume;\n    });\n    console.log('findFurthestNode: ', findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id);\n    console.log('Droplet positions initialized, nodes ready');\n    let lastDropletRearPosition = currentBlockDroplets[currentBlockDroplets.length - 1].rearVolumetricPosition;\n    let outletNodePosition = orderedNodes[0].node.volumetricPosition;\n    let timePassed = 0; //in s\n    let newTimePassed = 0;\n\n    // Simulate the movement of droplets in the current block\n    currentBlockDroplets.forEach(droplet => {\n      droplet.frontTimeToReachNextNode = Math.abs(droplet.frontVolumetricDistanceToNextNode / droplet.frontVolumetricSpeed);\n      droplet.rearTimeToReachNextNode = Math.abs(droplet.rearVolumetricDistanceToNextNode / droplet.rearVolumetricSpeed);\n    });\n    while (lastDropletRearPosition < outletNodePosition) {\n      let smallestFrontTime = Infinity;\n      let smallestRearTime = Infinity;\n      let smallestFrontTimeDroplet = [];\n      let smallestRearTimeDroplet = [];\n      currentBlockDroplets.forEach(droplet => {\n        // Update the smallest front and rear times and associated droplet(s) based on the current droplet's front and rear times to reach the next node.\n\n        if (Math.abs(droplet.frontTimeToReachNextNode) < smallestFrontTime) {\n          smallestFrontTime = Math.abs(droplet.frontTimeToReachNextNode);\n          smallestFrontTimeDroplet = [droplet];\n        } else if (Math.abs(droplet.frontTimeToReachNextNode) === smallestFrontTime) {\n          smallestFrontTimeDroplet.push(droplet);\n        }\n        if (Math.abs(droplet.rearTimeToReachNextNode) < smallestRearTime) {\n          smallestRearTime = Math.abs(droplet.rearTimeToReachNextNode);\n          smallestRearTimeDroplet = [droplet];\n        } else if (Math.abs(droplet.rearTimeToReachNextNode) === smallestRearTime) {\n          smallestRearTimeDroplet.push(droplet);\n        }\n      });\n      newTimePassed += Math.min(Math.abs(smallestFrontTime), Math.abs(smallestRearTime));\n      if (smallestFrontTime === smallestRearTime) {\n        //przypadek w ktorym wiele kropel ma ten sam czas do przejścia do nastepnego noda, rzadki\n\n        if (smallestFrontTimeDroplet.length > 1 || smallestRearTimeDroplet.length > 1) {\n          //sprawdź czy wśród nich jest kropla z rear i front\n          console.log('Multiple droplets have reached the next node simultaneously');\n          console.log('smallestFrontTimeDroplet: ', smallestFrontTimeDroplet);\n          console.log('smallestRearTimeDroplet: ', smallestRearTimeDroplet);\n        } else if (smallestFrontTimeDroplet[0] === smallestRearTimeDroplet[0]) {\n          //przypadek gdy kropla ma 0 objętości\n          console.log('Both front and rear times are for the same droplet');\n          const reachedNode = orderedNodes.find(n => n.node.id === smallestFrontTimeDroplet[0].frontNextNodeID);\n          const reachedNodeDistance = orderedNodes.find(node => node.node.id === reachedNode.node.id).distance;\n          if (reachedNode.node.type === 'connector') {\n            const index = currentBlockDroplets.indexOf(smallestFrontTimeDroplet[0]);\n            const dropletsOlder = currentBlockDroplets.slice(0, index);\n            const dropletsNewer = currentBlockDroplets.slice(index + 1);\n            const ds = [];\n            ds.drops = JSON.parse(JSON.stringify(dropletsNewer)); // Create deep copy\n            ds.snappedNode = smallestFrontTimeDroplet[0].frontNextNodeID;\n            const existingSnapshotIndex = dropletSnapshot.findIndex(snapshot => snapshot.snappedNode === ds.snappedNode);\n            if (existingSnapshotIndex !== -1) {\n              dropletSnapshot[existingSnapshotIndex] = ds;\n            } else {\n              dropletSnapshot.push(ds);\n            }\n\n            //aktualizuje starsze krople\n            dropletsOlder.forEach(droplet => {\n              droplet.frontTimeToReachNextNode -= smallestFrontTime;\n              droplet.rearTimeToReachNextNode -= smallestFrontTime;\n              droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n              droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n              droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n              droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n            });\n\n            //aktualizuje kroplę\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n            const nextEdge = graphData.links.find(link => link.source === smallestFrontTimeDroplet[0].frontNextNodeID && link.target === nextNode.node.id);\n            if (reachedNode.connectedPump !== null) {\n              var _smallestFrontTimeDro, _smallestFrontTimeDro2;\n              const pumpRatio = ((_smallestFrontTimeDro = smallestFrontTimeDroplet[0].parameters.find(param => param.nodeId === reachedNode.connectedPump.id && param.name === 'ratio')) === null || _smallestFrontTimeDro === void 0 ? void 0 : _smallestFrontTimeDro.value) || 0;\n              const dropletDesiredVolume = ((_smallestFrontTimeDro2 = smallestFrontTimeDroplet[0].parameters.find(param => param.name === 'volume')) === null || _smallestFrontTimeDro2 === void 0 ? void 0 : _smallestFrontTimeDro2.value) || 0;\n              reachedNode.connectedPumpRatio = pumpRatio;\n              //reachedNode.inletVolumetricSpeed = 0;\n              //smallestFrontTimeDroplet[0].frontVolumetricSpeed = reachedNode.outletVolumetricSpeed;\n              smallestFrontTimeDroplet[0].frontVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              smallestFrontTimeDroplet[0].rearVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].rearVolumetricSpeed;\n              smallestFrontTimeDroplet[0].rearVolumetricSpeed = 0;\n              smallestFrontTimeDroplet[0].frontVolumetricPosition = reachedNode.node.volumetricPosition;\n              smallestFrontTimeDroplet[0].rearVolumetricPosition = reachedNode.node.volumetricPosition;\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n              smallestFrontTimeDroplet[0].rearVolumetricDistanceToNextNode = 0;\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              smallestFrontTimeDroplet[0].rearTimeToReachNextNode = dropletDesiredVolume * pumpRatio / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\n              //smallestFrontTimeDroplet[0].rearNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\n              smallestFrontTimeDroplet[0].pumpSpeedMultiplier = 1;\n              //smallestFrontTimeDroplet[0].pauseLevel = 0;\n              smallestFrontTimeDroplet[0].stoppingDroplet = true;\n              smallestFrontTimeDroplet[0].initialPumping = true;\n              if (reachedNode.connectedPump.id !== selectedCarrierPumps[0]) {\n                event = {\n                  type: 'setPumpSpeed',\n                  target: reachedNode.connectedPump.id,\n                  time: newTimePassed,\n                  value: smallestFrontTimeDroplet[0].frontVolumetricSpeed\n                };\n                eventList.push(event);\n              }\n\n              //update newer droplets\n              dropletsNewer.forEach(droplet => {\n                droplet.pauseLevel += 1;\n                if (droplet.pauseLevel === 1) {\n                  droplet.frontVolumetricSpeedAtPause = droplet.frontVolumetricSpeed;\n                  if (droplet.stoppingDroplet !== true) {\n                    droplet.rearVolumetricSpeedAtPause = droplet.rearVolumetricSpeed;\n                  }\n                }\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricSpeed = 0;\n                droplet.rearVolumetricSpeed = 0;\n                droplet.frontTimeToReachNextNode += smallestFrontTimeDroplet[0].rearTimeToReachNextNode - smallestFrontTime;\n                droplet.rearTimeToReachNextNode += smallestFrontTimeDroplet[0].rearTimeToReachNextNode - smallestFrontTime;\n              });\n              getPumpsBetweenPositions(smallestFrontTimeDroplet[0].frontVolumetricPosition, -1, graphData.nodes, graphData.links).filter(pump => pump.id !== reachedNode.connectedPump.id).forEach(pump => {\n                event = {\n                  type: 'setPumpSpeed',\n                  target: pump.id,\n                  time: newTimePassed,\n                  value: 0\n                };\n                eventList.push(event);\n              });\n            }\n          } else if (reachedNode.type === 'thermostat' || reachedNode.type === 'LED') {\n            console.log('reachedNode is thermostat');\n          } else if (reachedNode.type === 'outlet') {\n            console.log('reachedNode is outlet');\n          } else if (reachedNode.type === 'detector' || reachedNode.type === 'USBSpectrometer' || reachedNode.type === 'MQTTSpectrometer') {\n            console.log('reachedNode is detector');\n          }\n        } else {\n          console.log('Front and rear times are for different droplets');\n        }\n      } else if (smallestFrontTime < smallestRearTime) {\n        //przypadek gdzie przód jest przed tyłem\n        console.log('Front time is smaller than rear time');\n        if (smallestFrontTimeDroplet.length > 1) {\n          console.log(`Multiple droplets have reached the next node simultaneously`);\n          smallestFrontTimeDroplet.forEach(droplet => {\n            // Perform some action for each droplet in smallestFrontTimeDroplet\n          });\n        } else {\n          //przypadek gdy przód jednej kropelki dochodzi do noda\n          console.log(`Single droplet front has reached the next node`);\n          const reachedNode = orderedNodes.find(n => n.node.id === smallestFrontTimeDroplet[0].frontNextNodeID);\n          const reachedNodeDistance = orderedNodes.find(node => node.node.id === reachedNode.node.id).distance;\n          if (reachedNode.node.type === 'connector') {\n            //przypadek gdy dochodzi do connectora\n            console.log('reachedNode is connector');\n            const index = currentBlockDroplets.indexOf(smallestFrontTimeDroplet[0]);\n            const dropletsOlder = currentBlockDroplets.slice(0, index);\n            const dropletsNewer = currentBlockDroplets.slice(index + 1);\n\n            //aktualizuje kroplę\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n            const nextEdge = graphData.links.find(link => link.source === reachedNode.node.id && link.target === nextNode.node.id);\n            if (reachedNode.connectedPump.id !== null) {\n              var _smallestFrontTimeDro3, _smallestFrontTimeDro4;\n              const pumpRatio = ((_smallestFrontTimeDro3 = smallestFrontTimeDroplet[0].parameters.find(param => param.nodeId === reachedNode.connectedPump.id && param.name === 'ratio')) === null || _smallestFrontTimeDro3 === void 0 ? void 0 : _smallestFrontTimeDro3.value) || 0;\n              const dropletDesiredVolume = ((_smallestFrontTimeDro4 = smallestFrontTimeDroplet[0].parameters.find(param => param.name === 'volume')) === null || _smallestFrontTimeDro4 === void 0 ? void 0 : _smallestFrontTimeDro4.value) || 0;\n              smallestFrontTimeDroplet[0].frontVolumetricPosition = reachedNode.node.volumetricPosition;\n              smallestFrontTimeDroplet[0].rearVolumetricPosition += smallestFrontTime * smallestFrontTimeDroplet[0].rearVolumetricSpeed;\n              smallestFrontTimeDroplet[0].actualVolume = smallestFrontTimeDroplet[0].frontVolumetricPosition - smallestFrontTimeDroplet[0].rearVolumetricPosition;\n              reachedNode.inletVolumetricSpeed = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              reachedNode.connectedPumpRatio = pumpRatio;\n              smallestFrontTimeDroplet[0].rearTimeToReachNextNode -= smallestFrontTime;\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n              smallestFrontTimeDroplet[0].rearVolumetricDistanceToNextNode -= smallestFrontTime * smallestFrontTimeDroplet[0].rearVolumetricSpeed;\n              if (smallestFrontTimeDroplet[0].initialPumping === true) {\n                //przypadek gdy kropla jest w pierwszej fazie pompowania (od 0uL)\n                console.log('Kropla jest w pierwszej fazie pompowania');\n                //smallestFrontTimeDroplet[0].initialPumping = false;\n                const rearTimeLeft = smallestFrontTimeDroplet[0].rearTimeToReachNextNode;\n                const totalTimeLeft = rearTimeLeft + smallestFrontTimeDroplet[0].actualVolume / commonVolumetricSpeed;\n                console.log('commonVolumetricSpeed: ', commonVolumetricSpeed);\n                console.log('smallestFrontTimeDroplet[0].actualVolume: ', smallestFrontTimeDroplet[0].actualVolume);\n                console.log('rearTimeLeft: ', rearTimeLeft);\n                console.log('totalTimeLeft: ', totalTimeLeft);\n                const thispumpspeed = pumpRatio * dropletDesiredVolume / totalTimeLeft;\n                console.log('thispumpspeed: ', thispumpspeed);\n                reachedNode.connectedPumpSpeedAtPause = thispumpspeed;\n              } else {\n                console.log('Normalne pompowanie');\n                reachedNode.connectedPumpSpeedAtPause = dropletDesiredVolume * pumpRatio / (smallestFrontTimeDroplet[0].actualVolume / reachedNode.inletVolumetricSpeed);\n              }\n              reachedNode.outletVolumetricSpeed = reachedNode.inletVolumetricSpeed + reachedNode.connectedPumpSpeedAtPause;\n              smallestFrontTimeDroplet[0].frontVolumetricSpeed += reachedNode.connectedPumpSpeedAtPause;\n              //smallestFrontTimeDroplet[0].rearVolumetricSpeed = 0;\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\n              //smallestFrontTimeDroplet[0].rearNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\n              //smallestFrontTimeDroplet[0].pumpSpeedMultiplier = 1;\n              //smallestFrontTimeDroplet[0].pauseLevel = 0;\n              //smallestFrontTimeDroplet[0].frontVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              //smallestFrontTimeDroplet[0].rearVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              //smallestFrontTimeDroplet[0].stoppingDroplet = true;\n              event = {\n                type: 'setPumpSpeed',\n                target: reachedNode.connectedPump.id,\n                time: newTimePassed,\n                value: reachedNode.connectedPumpSpeedAtPause\n              };\n              eventList.push(event);\n              //update newer droplets\n              dropletsNewer.forEach(droplet => {\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontTimeToReachNextNode -= smallestFrontTime;\n                droplet.rearTimeToReachNextNode -= smallestFrontTime;\n              });\n              //aktualizuje starsze krople\n              let accumulatedSpeed = reachedNode.connectedPumpSpeedAtPause;\n              dropletsOlder.reverse().forEach(droplet => {\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.rearVolumetricSpeed += accumulatedSpeed;\n                getPumpsBetweenPositions(droplet.frontVolumetricPosition, droplet.rearVolumetricPosition, graphData.nodes, graphData.links).forEach(pump => {\n                  const editedNode = orderedNodes.find(node => node.connectedPump.id === pump.id);\n                  //editedNode.pumpSpeedMultiplier = 1;\n                  const pumpBoost = editedNode.connectedPumpSpeedAtPause * accumulatedSpeed / editedNode.inletVolumetricSpeed;\n                  editedNode.connectedPumpSpeedAtPause += pumpBoost;\n                  editedNode.inletVolumetricSpeed += accumulatedSpeed;\n                  accumulatedSpeed += pumpBoost;\n                  editedNode.outletVolumetricSpeed += accumulatedSpeed;\n                  event = {\n                    type: 'setPumpSpeed',\n                    target: pump.id,\n                    time: newTimePassed,\n                    value: editedNode.connectedPumpSpeedAtPause\n                  };\n                  eventList.push(event);\n                });\n                droplet.frontVolumetricSpeed += accumulatedSpeed;\n                droplet.frontTimeToReachNextNode = droplet.frontVolumetricDistanceToNextNode / droplet.frontVolumetricSpeed;\n                droplet.rearTimeToReachNextNode = droplet.rearVolumetricDistanceToNextNode / droplet.rearVolumetricSpeed;\n              });\n            }\n          } else if (reachedNode.node.type === 'thermostat' || reachedNode.type === 'LED') {\n            //przypadek gdy dochodzi do termostatu\n            console.log('reachedNode (thermostat, LED): ', reachedNode);\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n            if (nextNode) {\n              const nextEdge = graphData.links.find(link => link.source === smallestFrontTimeDroplet[0].frontNextNodeID && link.target === nextNode.node.id);\n              //aktualizuje krople\n              currentBlockDroplets.forEach(droplet => {\n                droplet.frontTimeToReachNextNode -= smallestFrontTime;\n                droplet.rearTimeToReachNextNode -= smallestFrontTime;\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n              });\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\n            }\n          } else if (reachedNode.node.type === 'outlet') {\n            //jeśli ostatni node osiągnięty\n            console.log('reachedNode (outlet): ', reachedNode);\n            //typowe zaktualizowanie czasu do następnego noda dla reszty kropel i zestallowanie frontu\n            currentBlockDroplets.forEach(droplet => {\n              droplet.frontTimeToReachNextNode -= smallestFrontTime;\n              droplet.rearTimeToReachNextNode -= smallestFrontTime;\n              droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n              droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n              droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n              droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n            });\n            smallestFrontTimeDroplet[0].frontTimeToReachNextNode = Infinity;\n            smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = Infinity;\n            smallestFrontTimeDroplet[0].frontNextNodeID = null;\n          } else if (reachedNode.node.type === 'detector' || reachedNode.node.type === 'USBSpectrometer' || reachedNode.node.type === 'MQTTSpectrometer') {\n            var _smallestRearTimeDrop;\n            //przypadek gdy dochodzi do detektora\n            console.log('reachedNode (detector): ', reachedNode);\n\n            // Create detector measurement end event when droplet rear reaches detector\n            const detectorEndEvent = {\n              type: 'setDetectorMeasurement',\n              target: reachedNode.node.id,\n              time: newTimePassed,\n              dropletId: smallestRearTimeDroplet[0].id,\n              eventSubtype: 'dropletRearPassed',\n              dropletData: {\n                volume: ((_smallestRearTimeDrop = smallestRearTimeDroplet[0].parameters.find(p => p.name === 'volume')) === null || _smallestRearTimeDrop === void 0 ? void 0 : _smallestRearTimeDrop.value) || 0,\n                frontVolumetricPosition: smallestRearTimeDroplet[0].frontVolumetricPosition,\n                rearVolumetricPosition: smallestRearTimeDroplet[0].rearVolumetricPosition,\n                rearVolumetricSpeed: smallestRearTimeDroplet[0].rearVolumetricSpeed,\n                parameters: smallestRearTimeDroplet[0].parameters\n              }\n            };\n            eventList.push(detectorEndEvent);\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n            if (nextNode) {\n              const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\n              //aktualizuje krople\n              currentBlockDroplets.forEach(droplet => {\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\n                droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n              });\n              smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n              smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\n              smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\n            }\n          }\n        }\n      } else {\n        //przypadek gdzie tył jest przed przodem\n        console.log('Rear time is smaller than front time');\n        if (smallestRearTimeDroplet.length > 1) {\n          //przypadek gdy dochodzi do noda wiele kropel\n          console.log(`Multiple droplets ends have reached the next node simultaneously`);\n          smallestRearTimeDroplet.forEach(droplet => {\n            // Perform some action for each droplet in smallestRearTimeDroplet\n          });\n        } else {\n          //przypadek gdy tył jednej kropelki dochodzi do noda\n          const reachedNode = orderedNodes.find(n => n.node.id === smallestRearTimeDroplet[0].rearNextNodeID);\n          const reachedNodeDistance = orderedNodes.find(node => node.node.id === reachedNode.node.id).distance;\n          if (reachedNode.node.type === 'connector') {\n            //przypadek gdy dochodzi do connectora\n            console.log('reachedNode is connector');\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n            const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\n            const index = currentBlockDroplets.indexOf(smallestRearTimeDroplet[0]);\n            const dropletsOlder = currentBlockDroplets.slice(0, index);\n            const dropletsNewer = currentBlockDroplets.slice(index + 1);\n            if (smallestRearTimeDroplet[0].stoppingDroplet === true) {\n              //wznawia jeśli była zatrzymana\n              //aktualizuje starsze krople\n              dropletsOlder.forEach(droplet => {\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\n                droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n              });\n\n              //aktualizuje nowsze krople\n              dropletsNewer.forEach(droplet => {\n                if (droplet.pauseLevel === 1) {\n                  //\n                  droplet.pauseLevel = 0;\n                  droplet.frontVolumetricSpeed = droplet.frontVolumetricSpeedAtPause;\n                  droplet.rearVolumetricSpeed = droplet.rearVolumetricSpeedAtPause;\n                  getPumpsBetweenPositions(droplet.frontVolumetricPosition, droplet.rearVolumetricPosition, graphData.nodes, graphData.links).forEach(pump => {\n                    event = {\n                      type: 'setPumpSpeed',\n                      target: pump.id,\n                      time: newTimePassed,\n                      value: orderedNodes.find(node => node.node.id === pump.id).connectedPumpSpeedAtPause\n                    };\n                    eventList.push(event);\n                  });\n                } else {\n                  droplet.pauseLevel -= 1;\n                }\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\n              });\n              reachedNode.connectedPumpRatio = 0;\n              //reachedNode.inletVolumetricSpeed = 0;\n              //smallestRearTimeDroplet[0].frontVolumetricSpeed = reachedNode.outletVolumetricSpeed;\n              smallestRearTimeDroplet[0].rearVolumetricSpeed = smallestRearTimeDroplet[0].rearVolumetricSpeedAtPause;\n              smallestRearTimeDroplet[0].frontVolumetricPosition += smallestRearTimeDroplet[0].frontVolumetricSpeed * smallestRearTime;\n              smallestRearTimeDroplet[0].rearVolumetricPosition = reachedNode.node.volumetricPosition;\n              smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode -= smallestRearTimeDroplet[0].frontVolumetricSpeed * smallestRearTime;\n              smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n              smallestRearTimeDroplet[0].frontTimeToReachNextNode = smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].frontVolumetricSpeed;\n              smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\n              //smallestRearTimeDroplet[0].frontNextNodeID = nextNode.id;\n              smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\n              //smallestRearTimeDroplet[0].pumpSpeedMultiplier = 1;\n              //smallestRearTimeDroplet[0].pauseLevel = 0;\n              smallestRearTimeDroplet[0].frontVolumetricSpeedAtPause = smallestRearTimeDroplet[0].frontVolumetricSpeed;\n              smallestRearTimeDroplet[0].rearVolumetricSpeedAtPause = smallestRearTimeDroplet[0].rearVolumetricSpeed;\n              smallestRearTimeDroplet[0].stoppingDroplet = false;\n              smallestRearTimeDroplet[0].initialPumping = false;\n              reachedNode.connectedPumpRatio = 0;\n              event = {\n                type: 'setPumpSpeed',\n                target: reachedNode.connectedPump.id,\n                time: newTimePassed,\n                value: 0\n              };\n              eventList.push(event);\n              event = {\n                type: 'setPumpSpeed',\n                target: selectedCarrierPumps[0],\n                time: newTimePassed,\n                value: commonVolumetricSpeed\n              };\n              eventList.push(event);\n            } else {\n              console.log('it is not stopper');\n              if (reachedNode.connectedPump.id !== null) {\n                const speedDifference = reachedNode.outletVolumetricSpeed - reachedNode.inletVolumetricSpeed;\n                //reachedNode.inletVolumetricSpeed = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n                reachedNode.outletVolumetricSpeed = reachedNode.inletVolumetricSpeed;\n                reachedNode.connectedPumpRatio = 0;\n                reachedNode.connectedPumpSpeedAtPause = 0;\n                smallestRearTimeDroplet[0].frontVolumetricPosition += smallestRearTime * smallestRearTimeDroplet[0].frontVolumetricSpeed;\n                smallestRearTimeDroplet[0].rearVolumetricPosition = reachedNode.node.volumetricPosition;\n                smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode -= smallestRearTime * smallestRearTimeDroplet[0].frontVolumetricSpeed;\n                smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n                //smallestRearTimeDroplet[0].frontNextNodeID = nextNode.id;\n                smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\n                //smallestRearTimeDroplet[0].pumpSpeedMultiplier = 1;\n                //smallestRearTimeDroplet[0].pauseLevel = 0; \n                //smallestRearTimeDroplet[0].stoppingDroplet = true;\n                smallestRearTimeDroplet[0].frontVolumetricSpeed = smallestRearTimeDroplet[0].frontVolumetricSpeed - speedDifference;\n                //smallestRearTimeDroplet[0].rearVolumetricSpeed = 0;\n                smallestRearTimeDroplet[0].frontVolumetricSpeedAtPause = smallestRearTimeDroplet[0].frontVolumetricSpeed;\n                //smallestRearTimeDroplet[0].rearVolumetricSpeedAtPause = smallestRearTimeDroplet[0].rearVolumetricSpeed;\n                smallestRearTimeDroplet[0].frontTimeToReachNextNode = smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].frontVolumetricSpeed;\n                smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\n                event = {\n                  type: 'setPumpSpeed',\n                  target: reachedNode.connectedPump.id,\n                  time: newTimePassed,\n                  value: reachedNode.connectedPumpSpeedAtPause\n                };\n                eventList.push(event);\n                //updte newer droplets\n                dropletsNewer.forEach(droplet => {\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                  droplet.frontTimeToReachNextNode -= smallestRearTime;\n                  droplet.rearTimeToReachNextNode -= smallestRearTime;\n                });\n                //aktualizuje starsze krople\n                let accumulatedSpeedDecrease = speedDifference;\n                dropletsOlder.reverse().forEach(droplet => {\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                  droplet.rearVolumetricSpeed -= accumulatedSpeedDecrease;\n                  getPumpsBetweenPositions(droplet.frontVolumetricPosition, droplet.rearVolumetricPosition, graphData.nodes, graphData.links).forEach(pump => {\n                    const editedNode = orderedNodes.find(node => node.connectedPump.id === pump.id);\n                    const pumpBreak = editedNode.connectedPumpSpeedAtPause * accumulatedSpeedDecrease / editedNode.inletVolumetricSpeed;\n                    editedNode.connectedPumpSpeedAtPause -= pumpBreak;\n                    editedNode.inletVolumetricSpeed -= accumulatedSpeedDecrease;\n                    accumulatedSpeedDecrease += pumpBreak;\n                    editedNode.outletVolumetricSpeed -= accumulatedSpeedDecrease;\n                    event = {\n                      type: 'setPumpSpeed',\n                      target: pump.id,\n                      time: newTimePassed,\n                      value: editedNode.connectedPumpSpeedAtPause\n                    };\n                    eventList.push(event);\n                  });\n                  droplet.frontVolumetricSpeed -= accumulatedSpeedDecrease;\n                  droplet.frontTimeToReachNextNode = droplet.frontVolumetricDistanceToNextNode / droplet.frontVolumetricSpeed;\n                  droplet.rearTimeToReachNextNode = droplet.rearVolumetricDistanceToNextNode / droplet.rearVolumetricSpeed;\n                });\n              }\n            }\n          } else if (reachedNode.node.type === 'thermostat' || reachedNode.node.type === 'LED') {\n            //przypadek gdy dochodzi do termostatu\n            console.log('reachedNode thermostat: ', reachedNode);\n            const isFarthestThermostatOrLED = orderedNodes.filter(node => node.node.type === 'thermostat' || node.node.type === 'LED').every(node => node.distance <= reachedNodeDistance);\n\n            // This line checks if the smallestRearTimeDroplet is the last droplet in the currentBlockDroplets array.\n            if (isFarthestThermostatOrLED && currentBlockDroplets.length === currentBlockDroplets.indexOf(smallestRearTimeDroplet[0]) + 1) {\n              var _smallestRearTimeDrop2;\n              console.log('This is the farthest thermostat or LED node. Also, last droplet just passed through it.');\n              const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n              const waitTime = ((_smallestRearTimeDrop2 = smallestRearTimeDroplet[0].parameters.find(param => param.nodeId === reachedNode.node.id && param.name === 'time')) === null || _smallestRearTimeDrop2 === void 0 ? void 0 : _smallestRearTimeDrop2.value) || 0;\n              if (nextNode) {\n                const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\n                smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n                smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed + smallestRearTime;\n                smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\n                //aktualizuje resztę kropli\n                currentBlockDroplets.forEach(droplet => {\n                  droplet.frontTimeToReachNextNode += waitTime - smallestRearTime;\n                  droplet.rearTimeToReachNextNode += waitTime - smallestRearTime;\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed - waitTime * droplet.frontVolumetricSpeed; //to jest zrobione na razie aby czas się zgadzał\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed - waitTime * droplet.rearVolumetricSpeed;\n                });\n                let carrierPumpEvent = {\n                  type: 'setPumpSpeed',\n                  target: selectedCarrierPumps[0],\n                  // Assuming 'carrierPumpId' is the ID of the carrier pump\n                  time: newTimePassed,\n                  value: 0\n                };\n                eventList.push(carrierPumpEvent);\n                carrierPumpEvent = {\n                  type: 'setPumpSpeed',\n                  target: selectedCarrierPumps[0],\n                  // Assuming 'carrierPumpId' is the ID of the carrier pump\n                  time: newTimePassed + waitTime,\n                  value: commonVolumetricSpeed\n                };\n                eventList.push(carrierPumpEvent);\n              }\n            } else {\n              //droplet wasnt the last one\n              console.log('smallestRearTimeDroplet is not the last droplet in the currentBlockDroplets array');\n              const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n              if (nextNode) {\n                const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\n                //aktualizuje krople\n                currentBlockDroplets.forEach(droplet => {\n                  droplet.frontTimeToReachNextNode -= smallestRearTime;\n                  droplet.rearTimeToReachNextNode -= smallestRearTime;\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n                });\n                smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n                smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\n                smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\n              }\n            }\n          } else if (reachedNode.node.type === 'outlet') {\n            //jeśli ostatni node osiągnięty\n            //typowe zaktualizowanie czasu do następnego noda dla reszty kropel i zestallowanie reara\n            //aktualizuje resztę kropli\n            currentBlockDroplets.forEach(droplet => {\n              droplet.frontTimeToReachNextNode -= smallestRearTime;\n              droplet.rearTimeToReachNextNode -= smallestRearTime;\n              droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n              droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n              droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n              droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n            });\n            smallestRearTimeDroplet[0].frontTimeToReachNextNode = Infinity;\n            smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode = Infinity;\n            smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = Infinity;\n            smallestRearTimeDroplet[0].rearNextNodeID = null;\n            smallestRearTimeDroplet[0].rearTimeToReachNextNode = Infinity;\n          } else if (reachedNode.node.type === 'detector' || reachedNode.node.type === 'USBSpectrometer' || reachedNode.node.type === 'MQTTSpectrometer') {\n            var _smallestRearTimeDrop3;\n            //przypadek gdy dochodzi do detektora\n            console.log('reachedNode (detector): ', reachedNode);\n\n            // Create detector measurement end event when droplet rear reaches detector\n            const detectorEndEvent = {\n              type: 'setDetectorMeasurement',\n              target: reachedNode.node.id,\n              time: newTimePassed,\n              dropletId: smallestRearTimeDroplet[0].id,\n              eventSubtype: 'dropletRearPassed',\n              dropletData: {\n                volume: ((_smallestRearTimeDrop3 = smallestRearTimeDroplet[0].parameters.find(p => p.name === 'volume')) === null || _smallestRearTimeDrop3 === void 0 ? void 0 : _smallestRearTimeDrop3.value) || 0,\n                frontVolumetricPosition: smallestRearTimeDroplet[0].frontVolumetricPosition,\n                rearVolumetricPosition: smallestRearTimeDroplet[0].rearVolumetricPosition,\n                rearVolumetricSpeed: smallestRearTimeDroplet[0].rearVolumetricSpeed,\n                parameters: smallestRearTimeDroplet[0].parameters\n              }\n            };\n            eventList.push(detectorEndEvent);\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n            if (nextNode) {\n              const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\n              //aktualizuje krople\n              currentBlockDroplets.forEach(droplet => {\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\n                droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n              });\n              smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n              smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\n              smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\n            }\n          }\n        }\n      }\n      timePassed = newTimePassed;\n      // Update last droplet rear position\n      lastDropletRearPosition = currentBlockDroplets[currentBlockDroplets.length - 1].rearVolumetricPosition;\n\n      //add code that preserves droplets positions and speeds for visualization\n      const dropletState = {\n        time: timePassed,\n        droplets: currentBlockDroplets.map(droplet => {\n          var _droplet$parameters$f8;\n          return {\n            id: droplet.id,\n            frontVolumetricPosition: droplet.frontVolumetricPosition,\n            rearVolumetricPosition: droplet.rearVolumetricPosition,\n            frontVolumetricSpeed: droplet.frontVolumetricSpeed,\n            rearVolumetricSpeed: droplet.rearVolumetricSpeed,\n            pumpSpeedMultiplier: droplet.pumpSpeedMultiplier,\n            frontTimeToReachNextNode: droplet.frontTimeToReachNextNode,\n            rearTimeToReachNextNode: droplet.rearTimeToReachNextNode,\n            frontVolumetricDistanceToNextNode: droplet.frontVolumetricDistanceToNextNode,\n            rearVolumetricDistanceToNextNode: droplet.rearVolumetricDistanceToNextNode,\n            volume: ((_droplet$parameters$f8 = droplet.parameters.find(p => p.name === 'volume')) === null || _droplet$parameters$f8 === void 0 ? void 0 : _droplet$parameters$f8.value) || 0,\n            frontNextNodeID: droplet.frontNextNodeID,\n            rearNextNodeID: droplet.rearNextNodeID\n          };\n        })\n      };\n      setDropletHistory(prev => [...prev, dropletState]);\n\n      //if (timePassed > 9999) {//here for testing, preventing infinite loop\n      //  lastDropletRearPosition = 88100;\n      //}\n    }\n    event = {\n      //it is ok\n      type: 'setPumpSpeed',\n      target: selectedCarrierPumps[0],\n      time: timePassed,\n      value: 0\n    };\n    eventList.push(event);\n    eventList = cleanAndSortEventList(eventList);\n    console.log('dropletHistory in event generator: ', dropletHistory);\n    console.log('eventList: ', eventList.sort((a, b) => a.time - b.time));\n    setPumpEvents(extractPumpEvents(eventList));\n    setDetectorEvents(extractDetectorEvents(eventList));\n    console.log('Detector events:', extractDetectorEvents(eventList));\n    return eventList;\n  };\n  // First useEffect to set initial graphData\n  useEffect(() => {\n    setDropletHistory([]);\n    if (nodes.length > 0 && edges.length > 0) {\n      const graphNodes = nodes.map(node => ({\n        id: node.id,\n        label: node.data.label,\n        type: node.data.type,\n        x: 0,\n        y: 0,\n        volumetricPosition: 0\n      }));\n      const graphLinks = edges.map(edge => {\n        var _edge$data, _edge$data$properties, _edge$data2, _edge$data2$propertie;\n        return {\n          source: edge.source,\n          target: edge.target,\n          length: ((_edge$data = edge.data) === null || _edge$data === void 0 ? void 0 : (_edge$data$properties = _edge$data.properties) === null || _edge$data$properties === void 0 ? void 0 : _edge$data$properties.length) || 100,\n          diameter: ((_edge$data2 = edge.data) === null || _edge$data2 === void 0 ? void 0 : (_edge$data2$propertie = _edge$data2.properties) === null || _edge$data2$propertie === void 0 ? void 0 : _edge$data2$propertie.diameter) || 1\n        };\n      });\n      setGraphData({\n        nodes: graphNodes,\n        links: graphLinks\n      });\n    }\n  }, [nodes, edges]);\n\n  // Second useEffect to calculate nodes positions and set up simulation data\n  useEffect(() => {\n    if (!graphData.nodes.length || !graphData.links.length || !droplets.length) {\n      console.log('Missing required data for simulation setup:', {\n        nodesLength: graphData.nodes.length,\n        linksLength: graphData.links.length,\n        dropletsLength: droplets.length\n      });\n      return;\n    }\n    const graphNodes = [...graphData.nodes];\n\n    // Find outlet node first\n    const outletNode = findOutletNode(graphData.nodes);\n    if (!outletNode) {\n      console.error('No outlet node found. Cannot set up simulation.');\n      return;\n    }\n\n    // Get ordered nodes from outlet\n    const orderedNodes = orderNodesByDistance(outletNode, graphData.nodes, graphData.links);\n\n    // Separate nodes into main line and secondary line\n    const mainLineNodes = orderedNodes.filter(({\n      node\n    }) => setOfMainLineNodes.includes(node.type)).reverse();\n    const secondaryLineNodes = orderedNodes.filter(({\n      node\n    }) => setOfSecondaryLineNodes.includes(node.type)).sort((a, b) => b.distance - a.distance);\n\n    // Position settings\n    const mainLineY = 300;\n    const secondaryLineY = 150;\n    const pumpSpacing = 100; // Increased horizontal spacing between pumps\n    let currentX = 100;\n\n    // Position main line nodes\n    let currentVolumetricPosition = 0;\n    mainLineNodes.forEach(({\n      node\n    }, index) => {\n      const graphNode = graphNodes.find(n => n.id === node.id);\n      if (!graphNode) return;\n      graphNode.x = currentX;\n      graphNode.y = mainLineY;\n      graphNode.volumetricPosition = currentVolumetricPosition;\n      if (index < mainLineNodes.length - 1) {\n        const nextNode = mainLineNodes[index + 1];\n        const edge = graphData.links.find(e => e.source === graphNode.id && e.target === nextNode.node.id || e.target === graphNode.id && e.source === nextNode.node.id);\n        if (edge && edge.length) {\n          currentX += edge.length * 2;\n          // Use existing calculateEdgeVolume function\n          const edgeVolume = calculateEdgeVolume(edge);\n          currentVolumetricPosition += edgeVolume;\n        } else {\n          currentX += 200;\n          currentVolumetricPosition += 150;\n        }\n      }\n    });\n\n    // Group secondary nodes by distance\n    const nodesByDistance = {};\n    secondaryLineNodes.forEach(({\n      node,\n      distance\n    }) => {\n      if (!nodesByDistance[distance]) {\n        nodesByDistance[distance] = [];\n      }\n      nodesByDistance[distance].push(node);\n    });\n\n    // Position secondary nodes based on their connected main line nodes\n    const pumpOffset = 50; // Add this constant for pump spacing\n    Object.entries(nodesByDistance).forEach(([distance, nodes]) => {\n      nodes.forEach((node, index) => {\n        const graphNode = graphNodes.find(n => n.id === node.id);\n        if (!graphNode) return;\n\n        // Find connected main line node through edges\n        const connectedEdge = edges.find(e => e.source === node.id || e.target === node.id);\n        if (connectedEdge) {\n          const connectedNodeId = connectedEdge.source === node.id ? connectedEdge.target : connectedEdge.source;\n          const connectedMainNode = graphNodes.find(n => n.id === connectedNodeId);\n          if (connectedMainNode) {\n            // Position pump above its connected main line node with offset if needed\n            graphNode.x = connectedMainNode.x + index * pumpOffset - (nodes.length - 1) * pumpOffset / 2;\n            graphNode.y = secondaryLineY;\n          }\n        }\n      });\n    });\n    setGraphData(prev => ({\n      ...prev,\n      nodes: graphNodes\n    }));\n\n    // Only calculate volumes and blocks if not already done\n    if (currentBlockDroplets.length === 0) {\n      console.log('Calculating thermostat volumes and blocks for droplets:', droplets.length);\n      const thermoVol = calculateVolumesBetweenThermostats(graphData);\n\n      // Create deep copy of droplets to avoid mutation issues\n      const dropletsCopy = JSON.parse(JSON.stringify(droplets));\n      const blocks = divideDropletsIntoBlocks(dropletsCopy, thermoVol);\n      if (blocks.length > 0) {\n        setCurrentBlockDroplets(blocks[0].droplets);\n        // Generate event list only once when initializing\n        const eventList = generateEventList(blocks);\n        const eventListForDevices = recalculateEventListForDevices(eventList);\n      }\n    }\n\n    // Important: the dependency array includes currentBlockDroplets.length to prevent infinite recalculations\n  }, [graphData.nodes.length, graphData.links.length, droplets, edges, currentBlockDroplets.length]);\n  const startSimulation = useCallback(() => {\n    setIsSimulationRunning(true);\n    lastFrameTimeRef.current = null; // Reset the last frame time\n  }, []);\n  const stopSimulation = useCallback(() => {\n    setIsSimulationRunning(false);\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n      animationFrameRef.current = null;\n    }\n  }, []);\n  const restartSimulation = useCallback(() => {\n    stopSimulation();\n    setKey(prevKey => prevKey + 1);\n    setCurrentTime(0);\n    startSimulation();\n  }, [stopSimulation, startSimulation]);\n  const getNodeColor = node => {\n    switch (node.type) {\n      case 'pump':\n        return '#4CAF50';\n      case 'connector':\n        return '#2196F3';\n      case 'outlet':\n        return '#F44336';\n      default:\n        return '#FFA000';\n      // Default color for unknown types\n    }\n  };\n\n  // Update volumetricToXPosition function\n  const volumetricToXPosition = useCallback(volumetricPosition => {\n    var _graphData$nodes$find, _graphData$nodes$find2;\n    const outletNode = findOutletNode(graphData.nodes);\n    const furthestNode = findFurthestNode(outletNode, graphData.nodes, graphData.links);\n    if (!outletNode || !furthestNode) return 0;\n    const totalVolume = getVolumeBetweenNodes(furthestNode.id, outletNode.id, graphData.nodes, graphData.links);\n    const outletX = ((_graphData$nodes$find = graphData.nodes.find(n => n.id === outletNode.id)) === null || _graphData$nodes$find === void 0 ? void 0 : _graphData$nodes$find.x) || 0;\n    const furthestX = ((_graphData$nodes$find2 = graphData.nodes.find(n => n.id === furthestNode.id)) === null || _graphData$nodes$find2 === void 0 ? void 0 : _graphData$nodes$find2.x) || 0;\n\n    // Handle edge cases\n    if (!totalVolume || totalVolume === 0 || isNaN(totalVolume)) {\n      console.warn('Total volume is invalid:', totalVolume);\n      return furthestX;\n    }\n    if (volumetricPosition === undefined || volumetricPosition === null || isNaN(volumetricPosition)) {\n      console.warn('Volumetric position is invalid:', volumetricPosition);\n      return furthestX;\n    }\n\n    // Clamp the position to valid range\n    const clampedPosition = Math.max(-totalVolume, Math.min(totalVolume, volumetricPosition));\n\n    // Apply scaling factor to the position calculation\n    const scaledX = furthestX + clampedPosition / totalVolume * (outletX - furthestX);\n\n    // Ensure the returned value is a valid number\n    if (!isFinite(scaledX) || isNaN(scaledX)) {\n      console.warn('Invalid scaled position calculated:', {\n        scaledX,\n        clampedPosition,\n        totalVolume,\n        outletX,\n        furthestX\n      });\n      return furthestX;\n    }\n    return scaledX;\n  }, [graphData.nodes]);\n\n  // Update the updateDropletPositions function\n  const updateDropletPositions = useCallback(timestamp => {\n    if (!isSimulationRunning || dropletHistory.length === 0) return;\n    if (!lastFrameTimeRef.current) {\n      lastFrameTimeRef.current = timestamp;\n      animationFrameRef.current = requestAnimationFrame(updateDropletPositions);\n      return;\n    }\n    const deltaTime = (timestamp - lastFrameTimeRef.current) / 1000; // Convert to seconds\n    const simulationDeltaTime = deltaTime * timeScale;\n    setCurrentTime(prevTime => {\n      const newTime = prevTime + simulationDeltaTime;\n\n      // Get the time range of our history\n      const lastHistoryTime = dropletHistory[dropletHistory.length - 1].time;\n\n      // If we've reached the end, loop back to start\n      if (newTime >= lastHistoryTime) {\n        setCurrentTime(0);\n        return 0;\n      }\n\n      // Find the appropriate states to interpolate between\n      const currentState = interpolateDropletState(newTime);\n      // Update droplet visualization\n      const updatedDroplets = currentState.map(droplet => {\n        const frontX = volumetricToXPosition(droplet.frontVolumetricPosition);\n        const rearX = volumetricToXPosition(droplet.rearVolumetricPosition);\n        if (isNaN(frontX) || isNaN(rearX)) {\n          console.warn('Invalid droplet position calculated:', {\n            dropletId: droplet.id,\n            frontPosition: droplet.frontVolumetricPosition,\n            rearPosition: droplet.rearVolumetricPosition,\n            frontX,\n            rearX\n          });\n          return null;\n        }\n        return {\n          id: droplet.id,\n          frontX,\n          rearX,\n          y: 300,\n          volume: droplet.frontVolumetricPosition - droplet.rearVolumetricPosition,\n          speed: droplet.frontVolumetricSpeed\n        };\n      }).filter(Boolean);\n      setSimulationDroplets(updatedDroplets);\n      return newTime;\n    });\n    lastFrameTimeRef.current = timestamp;\n    animationFrameRef.current = requestAnimationFrame(updateDropletPositions);\n  }, [isSimulationRunning, timeScale, volumetricToXPosition, dropletHistory]);\n\n  // Add animation effect\n  useEffect(() => {\n    if (isSimulationRunning) {\n      lastFrameTimeRef.current = null;\n      animationFrameRef.current = requestAnimationFrame(updateDropletPositions);\n    }\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [isSimulationRunning, updateDropletPositions]);\n\n  // Add this helper function for interpolation\n  const interpolateDropletState = time => {\n    if (!dropletHistory.length) return [];\n\n    // Find the two closest states\n    const index = dropletHistory.findIndex(state => state.time > time);\n    if (index === -1) return dropletHistory[dropletHistory.length - 1].droplets;\n    if (index === 0) return dropletHistory[0].droplets;\n    const beforeState = dropletHistory[index - 1];\n    const afterState = dropletHistory[index];\n    const fraction = (time - beforeState.time) / (afterState.time - beforeState.time);\n    return beforeState.droplets.map(beforeDroplet => {\n      const afterDroplet = afterState.droplets.find(d => d.id === beforeDroplet.id);\n      if (!afterDroplet) return beforeDroplet;\n      return {\n        ...beforeDroplet,\n        frontVolumetricPosition: beforeDroplet.frontVolumetricPosition + (afterDroplet.frontVolumetricPosition - beforeDroplet.frontVolumetricPosition) * fraction,\n        rearVolumetricPosition: beforeDroplet.rearVolumetricPosition + (afterDroplet.rearVolumetricPosition - beforeDroplet.rearVolumetricPosition) * fraction\n      };\n    });\n  };\n\n  // Add navigation functions\n  const jumpToTimepoint = useCallback(index => {\n    if (index >= 0 && index < dropletHistory.length) {\n      setCurrentTimepoint(index);\n      setCurrentTime(dropletHistory[index].time);\n    }\n  }, [dropletHistory]);\n  const nextTimepoint = useCallback(() => {\n    jumpToTimepoint(currentTimepoint + 1);\n  }, [currentTimepoint, jumpToTimepoint]);\n  const previousTimepoint = useCallback(() => {\n    jumpToTimepoint(currentTimepoint - 1);\n  }, [currentTimepoint, jumpToTimepoint]);\n  const handleNodeClick = node => {\n    var _node$data2, _node$data3;\n    console.log('Node clicked:', node);\n    console.log('Node type:', node.type);\n    console.log('Node data type:', (_node$data2 = node.data) === null || _node$data2 === void 0 ? void 0 : _node$data2.type);\n\n    // Check both node.type and node.data.type\n    const nodeType = node.type || ((_node$data3 = node.data) === null || _node$data3 === void 0 ? void 0 : _node$data3.type);\n    console.log('Determined node type:', nodeType);\n    if (nodeType === 'pump' || nodeType === 'USBSpectrometer' || nodeType === 'MQTTSpectrometer') {\n      setSelectedNode(node);\n      console.log('Selected node set:', node.id, nodeType);\n    }\n    if (node.type === 'detector' || node.type === 'USBSpectrometer' || node.type === 'MQTTSpectrometer') {\n      // Store the graph ref when opening a spectrometer\n      const graphRef = /*#__PURE__*/React.createRef();\n      graphRefs.current[node.id] = graphRef;\n\n      // ... rest of the existing handleNodeClick code ...\n    }\n  };\n  const handleNodeAction = action => {\n    console.log('Node action:', action);\n    // Here you would implement the actual device communication\n    // based on the action type and parameters\n  };\n  const togglePumpSpeeds = () => {\n    setDisplayPumpSpeeds(!displayPumpSpeeds);\n  };\n\n  // Toggle functions for each display option\n  const toggleNodeIds = () => {\n    setDisplayNodeIds(!displayNodeIds);\n  };\n  const toggleDropletInfo = () => {\n    setDisplayDropletInfo(!displayDropletInfo);\n  };\n  const toggleDropletGaps = () => {\n    setDisplayDropletGaps(!displayDropletGaps);\n  };\n  const toggleEdgeLabels = () => {\n    setDisplayEdgeLabels(!displayEdgeLabels);\n  };\n  const toggleDisplayMenu = () => {\n    setDisplayMenuOpen(!isDisplayMenuOpen);\n  };\n  const toggleTimelineDropletInfo = () => {\n    setDisplayTimelineDropletInfo(!displayTimelineDropletInfo);\n  };\n  const toggleDetectorEvents = () => {\n    setDisplayDetectorEvents(!displayDetectorEvents);\n  };\n\n  // Close menu when clicking outside\n  useEffect(() => {\n    const handleClickOutside = event => {\n      if (displayMenuRef.current && !displayMenuRef.current.contains(event.target)) {\n        setDisplayMenuOpen(false);\n      }\n    };\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => {\n      document.removeEventListener('mousedown', handleClickOutside);\n    };\n  }, []);\n\n  // Function to toggle pump panel visibility\n  const togglePumpPanel = pumpId => {\n    setVisiblePumpPanel(prev => prev === pumpId ? null : pumpId);\n  };\n\n  // Add styles for the display menu\n  const styles = {\n    container: {\n      ...backgroundVariants.mainBackground,\n      padding: '20px',\n      minHeight: '100vh'\n    },\n    dropletInfo: {\n      padding: '8px',\n      borderRadius: '4px',\n      fontSize: '12px',\n      ...backgroundVariants.panelBackground,\n      color: '#fff',\n      minWidth: '150px'\n    },\n    timelineContainer: {\n      display: 'flex',\n      flexDirection: 'column',\n      gap: '10px',\n      marginBottom: '20px'\n    },\n    timeInput: {\n      width: '100px',\n      ...backgroundVariants.inputBackground,\n      padding: '5px',\n      borderRadius: '4px',\n      marginLeft: '8px'\n    },\n    buttonGroup: {\n      display: 'flex',\n      gap: '10px',\n      marginTop: '20px',\n      marginBottom: '20px'\n    },\n    timelineControls: {\n      display: 'flex',\n      flexDirection: 'column',\n      gap: '15px',\n      marginBottom: '20px',\n      ...backgroundVariants.panelBackground,\n      padding: '15px',\n      borderRadius: '4px'\n    },\n    timeControls: {\n      display: 'flex',\n      flexDirection: 'column',\n      gap: '15px'\n    },\n    sliderContainer: {\n      display: 'flex',\n      gap: '10px',\n      alignItems: 'center',\n      borderBottom: '1px solid rgba(255,255,255,0.1)',\n      paddingBottom: '15px'\n    },\n    timeStepButtons: {\n      display: 'flex',\n      gap: '5px',\n      alignItems: 'center',\n      justifyContent: 'flex-start'\n    },\n    timeScaleContainer: {\n      display: 'flex',\n      alignItems: 'center',\n      gap: '15px',\n      justifyContent: 'flex-start',\n      borderTop: '1px solid rgba(255,255,255,0.1)',\n      paddingTop: '15px'\n    },\n    svgContainer: {\n      background: backgroundVariants.panelBackground.background,\n      borderRadius: '4px',\n      padding: '10px'\n    },\n    navigationButtons: {\n      display: 'flex',\n      justifyContent: 'space-between',\n      marginBottom: '20px'\n    },\n    timeSlider: {\n      width: '33%',\n      ...backgroundVariants.inputBackground,\n      height: '20px',\n      borderRadius: '10px',\n      WebkitAppearance: 'none',\n      appearance: 'none',\n      background: backgroundVariants.inputBackground.background,\n      outline: 'none',\n      opacity: '0.7',\n      transition: 'opacity .2s',\n      '&:hover': {\n        opacity: '1'\n      },\n      '&::-webkit-slider-thumb': {\n        WebkitAppearance: 'none',\n        appearance: 'none',\n        width: '20px',\n        height: '20px',\n        background: '#4CAF50',\n        cursor: 'pointer',\n        borderRadius: '50%'\n      },\n      '&::-moz-range-thumb': {\n        width: '20px',\n        height: '20px',\n        background: '#4CAF50',\n        cursor: 'pointer',\n        borderRadius: '50%'\n      }\n    },\n    // Add styles for display menu\n    displayMenuButton: {\n      ...buttonVariants.infoButton,\n      position: 'relative'\n    },\n    displayMenu: {\n      position: 'absolute',\n      top: '100%',\n      right: 0,\n      backgroundColor: '#333',\n      border: '1px solid #555',\n      borderRadius: '4px',\n      padding: '8px 0',\n      zIndex: 1000,\n      width: '220px',\n      boxShadow: '0 2px 10px rgba(0, 0, 0, 0.3)'\n    },\n    menuItem: {\n      padding: '8px 16px',\n      cursor: 'pointer',\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'space-between',\n      color: 'white',\n      transition: 'background-color 0.2s',\n      '&:hover': {\n        backgroundColor: '#444'\n      }\n    },\n    checkmark: {\n      color: '#4CAF50',\n      fontWeight: 'bold'\n    }\n  };\n  const sliderStyle = {\n    width: '100%',\n    height: '10px',\n    borderRadius: '5px',\n    background: '#333',\n    outline: 'none',\n    opacity: '0.7',\n    transition: 'opacity .2s'\n    // Remove all pseudo-element styles that were here\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: styles.container,\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      style: styles.timelineControls,\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        style: styles.timeControls,\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          style: styles.sliderContainer,\n          children: [/*#__PURE__*/_jsxDEV(\"input\", {\n            type: \"range\",\n            min: 0,\n            max: Math.max(0, dropletHistory.length - 1),\n            value: currentTimepoint,\n            onChange: e => jumpToTimepoint(Number(e.target.value)),\n            disabled: isSimulationRunning,\n            style: styles.timeSlider,\n            className: \"time-slider\" // Add this className\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1759,\n            columnNumber: 13\n          }, this), displayTimelineDropletInfo && /*#__PURE__*/_jsxDEV(\"div\", {\n            style: {\n              display: 'flex',\n              gap: '10px',\n              flexWrap: 'wrap'\n            },\n            children: dropletHistory.length > 0 && ((_dropletHistory$curre = dropletHistory[currentTimepoint]) === null || _dropletHistory$curre === void 0 ? void 0 : _dropletHistory$curre.droplets.map((droplet, index) => {\n              var _graphData$nodes$find3, _graphData$nodes$find4;\n              return /*#__PURE__*/_jsxDEV(\"div\", {\n                style: styles.dropletInfo,\n                children: [/*#__PURE__*/_jsxDEV(\"div\", {\n                  children: [\"Droplet \", index + 1, \":\"]\n                }, void 0, true, {\n                  fileName: _jsxFileName,\n                  lineNumber: 1773,\n                  columnNumber: 21\n                }, this), droplet.frontNextNodeID && /*#__PURE__*/_jsxDEV(\"div\", {\n                  children: [\"Front \\u2192 \", ((_graphData$nodes$find3 = graphData.nodes.find(n => n.id === droplet.frontNextNodeID)) === null || _graphData$nodes$find3 === void 0 ? void 0 : _graphData$nodes$find3.label) || droplet.frontNextNodeID]\n                }, void 0, true, {\n                  fileName: _jsxFileName,\n                  lineNumber: 1775,\n                  columnNumber: 23\n                }, this), droplet.rearNextNodeID && /*#__PURE__*/_jsxDEV(\"div\", {\n                  children: [\"Rear \\u2192 \", ((_graphData$nodes$find4 = graphData.nodes.find(n => n.id === droplet.rearNextNodeID)) === null || _graphData$nodes$find4 === void 0 ? void 0 : _graphData$nodes$find4.label) || droplet.rearNextNodeID]\n                }, void 0, true, {\n                  fileName: _jsxFileName,\n                  lineNumber: 1778,\n                  columnNumber: 23\n                }, this)]\n              }, droplet.id, true, {\n                fileName: _jsxFileName,\n                lineNumber: 1772,\n                columnNumber: 19\n              }, this);\n            }))\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1770,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1758,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: styles.timeStepButtons,\n          children: [/*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => jumpToTimepoint(0),\n            disabled: currentTimepoint === 0 || isSimulationRunning,\n            style: {\n              ...buttonVariants.secondaryButton,\n              padding: '4px 8px'\n            },\n            children: \"\\u23EE\\uFE0F Start\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1787,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => jumpToTimepoint(currentTimepoint - 1),\n            disabled: currentTimepoint === 0 || isSimulationRunning,\n            style: {\n              ...buttonVariants.secondaryButton,\n              padding: '4px 8px'\n            },\n            children: \"\\u23EA Previous\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1794,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => jumpToTimepoint(currentTimepoint + 1),\n            disabled: currentTimepoint >= dropletHistory.length - 1 || isSimulationRunning,\n            style: {\n              ...buttonVariants.secondaryButton,\n              padding: '4px 8px'\n            },\n            children: \"Next \\u23E9\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1801,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => jumpToTimepoint(dropletHistory.length - 1),\n            disabled: currentTimepoint >= dropletHistory.length - 1 || isSimulationRunning,\n            style: {\n              ...buttonVariants.secondaryButton,\n              padding: '4px 8px'\n            },\n            children: \"End \\u23ED\\uFE0F\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1808,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1786,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: styles.timeScaleContainer,\n          children: [/*#__PURE__*/_jsxDEV(\"label\", {\n            style: {\n              color: '#fff',\n              marginRight: '10px'\n            },\n            children: [\"Time Scale:\", /*#__PURE__*/_jsxDEV(\"select\", {\n              value: timeScale,\n              onChange: e => setTimeScale(Number(e.target.value)),\n              style: styles.timeInput,\n              children: [/*#__PURE__*/_jsxDEV(\"option\", {\n                value: 0.0625,\n                children: \"1/16x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1825,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 0.25,\n                children: \"1/4x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1826,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 1,\n                children: \"1x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1827,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 4,\n                children: \"4x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1828,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 16,\n                children: \"16x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1829,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 64,\n                children: \"64x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1830,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 256,\n                children: \"256x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1831,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 1024,\n                children: \"1024x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1832,\n                columnNumber: 17\n              }, this)]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 1820,\n              columnNumber: 15\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1818,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"label\", {\n            style: {\n              color: '#fff',\n              marginRight: '10px'\n            },\n            children: [\"Current Time: \", currentTime.toFixed(2), \"s\"]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1835,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"label\", {\n            style: {\n              color: '#fff'\n            },\n            children: [\"Step: \", currentTimepoint + 1, \"/\", dropletHistory.length]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1838,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1817,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1757,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1756,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: styles.buttonGroup,\n      children: [/*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: isSimulationRunning ? stopSimulation : startSimulation,\n        style: {\n          ...buttonVariants.primaryButton\n        },\n        children: isSimulationRunning ? 'Stop Simulation' : 'Start Simulation'\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1846,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: restartSimulation,\n        style: {\n          ...buttonVariants.secondaryButton\n        },\n        children: \"Restart simulation\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1852,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: sendingEventsToDevices,\n        style: {\n          ...buttonVariants.primaryButton\n        },\n        children: \"Send Events to Devices\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1858,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        ref: displayMenuRef,\n        style: {\n          position: 'relative',\n          display: 'inline-block'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: toggleDisplayMenu,\n          style: styles.displayMenuButton,\n          children: \"Display Settings\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1865,\n          columnNumber: 11\n        }, this), isDisplayMenuOpen && /*#__PURE__*/_jsxDEV(\"div\", {\n          style: styles.displayMenu,\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: toggleNodeIds,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Node IDs\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1877,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayNodeIds ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1878,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1873,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: toggleDropletInfo,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Droplet Info\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1884,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayDropletInfo ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1885,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1880,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: toggleDropletGaps,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Droplet Gaps\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1891,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayDropletGaps ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1892,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1887,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: toggleEdgeLabels,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Tube Dimensions\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1898,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayEdgeLabels ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1899,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1894,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: togglePumpSpeeds,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Pump Speeds\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1905,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayPumpSpeeds ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1906,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1901,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: toggleTimelineDropletInfo,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Timeline Droplet Info\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1912,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayTimelineDropletInfo ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1913,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1908,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: toggleDetectorEvents,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Detector Events\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1919,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayDetectorEvents ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1920,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1915,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1872,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1864,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1845,\n      columnNumber: 7\n    }, this), graphData.nodes.length > 0 && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: styles.svgContainer,\n      children: /*#__PURE__*/_jsxDEV(\"svg\", {\n        width: \"2000\",\n        height: \"400\",\n        children: [graphData.links.map((link, index) => {\n          const sourceNode = graphData.nodes.find(node => node.id === link.source);\n          const targetNode = graphData.nodes.find(node => node.id === link.target);\n          if (!sourceNode || !targetNode) return null;\n          const midX = (sourceNode.x + targetNode.x) / 2;\n          const midY = (sourceNode.y + targetNode.y) / 2;\n          return /*#__PURE__*/_jsxDEV(\"g\", {\n            children: [/*#__PURE__*/_jsxDEV(\"line\", {\n              x1: sourceNode.x,\n              y1: sourceNode.y,\n              x2: targetNode.x,\n              y2: targetNode.y,\n              stroke: \"#999\",\n              strokeWidth: 2\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1942,\n              columnNumber: 19\n            }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n              x: midX,\n              y: midY - 20,\n              textAnchor: \"middle\",\n              fill: \"#fff\",\n              fontSize: \"12px\",\n              style: {\n                display: displayEdgeLabels ? 'block' : 'none'\n              },\n              children: `${link.length} mm (Ø ${link.diameter} mm)`\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1950,\n              columnNumber: 19\n            }, this)]\n          }, `edge-${index}`, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1941,\n            columnNumber: 17\n          }, this);\n        }), graphData.nodes.map((node, index) => /*#__PURE__*/_jsxDEV(\"g\", {\n          children: [/*#__PURE__*/_jsxDEV(\"circle\", {\n            cx: node.x,\n            cy: node.y,\n            r: 15,\n            fill: getNodeColor(node),\n            stroke: selectedNode && selectedNode.id === node.id ? '#FFA500' : 'none',\n            strokeWidth: selectedNode && selectedNode.id === node.id ? '3' : '0',\n            onClick: () => handleNodeClick(node),\n            style: {\n              cursor: 'pointer'\n            }\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1967,\n            columnNumber: 17\n          }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n            x: node.x,\n            y: node.y - 25,\n            textAnchor: \"middle\",\n            fill: \"#fff\",\n            fontSize: \"12px\",\n            children: node.label\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1977,\n            columnNumber: 17\n          }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n            x: node.x,\n            y: node.y - 10,\n            textAnchor: \"middle\",\n            fill: \"#fff\",\n            fontSize: \"10px\",\n            style: {\n              display: displayNodeIds ? 'block' : 'none'\n            },\n            children: `ID: ${node.id}`\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1986,\n            columnNumber: 17\n          }, this)]\n        }, `node-${index}`, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1966,\n          columnNumber: 15\n        }, this)), interpolateDropletState(currentTime).map((droplet, index, droplets) => {\n          const frontX = volumetricToXPosition(droplet.frontVolumetricPosition);\n          const rearX = volumetricToXPosition(droplet.rearVolumetricPosition);\n          const centerX = (frontX + rearX) / 2;\n\n          // Calculate distance to next droplet if this isn't the last droplet\n          const distanceInfo = index < droplets.length - 1 ? {\n            nextDropletFront: droplets[index + 1].frontVolumetricPosition,\n            distance: Math.abs(droplets[index + 1].frontVolumetricPosition - droplet.rearVolumetricPosition)\n          } : null;\n\n          // Calculate midpoint for distance label\n          const distanceLabelX = distanceInfo ? (volumetricToXPosition(droplet.rearVolumetricPosition) + volumetricToXPosition(distanceInfo.nextDropletFront)) / 2 : null;\n          return /*#__PURE__*/_jsxDEV(\"g\", {\n            children: [/*#__PURE__*/_jsxDEV(\"line\", {\n              x1: rearX,\n              y1: 300,\n              x2: frontX,\n              y2: 300,\n              stroke: \"rgba(255, 100, 100, 0.9)\",\n              strokeWidth: 8,\n              strokeLinecap: \"butt\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 2019,\n              columnNumber: 19\n            }, this), distanceInfo && displayDropletGaps && /*#__PURE__*/_jsxDEV(\"g\", {\n              children: [/*#__PURE__*/_jsxDEV(\"line\", {\n                x1: rearX,\n                y1: 320,\n                x2: volumetricToXPosition(distanceInfo.nextDropletFront),\n                y2: 320,\n                stroke: \"#fff\",\n                strokeWidth: 1,\n                strokeDasharray: \"5,5\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2033,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"line\", {\n                x1: rearX,\n                y1: 315,\n                x2: rearX,\n                y2: 325,\n                stroke: \"#fff\",\n                strokeWidth: 1\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2043,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"line\", {\n                x1: volumetricToXPosition(distanceInfo.nextDropletFront),\n                y1: 315,\n                x2: volumetricToXPosition(distanceInfo.nextDropletFront),\n                y2: 325,\n                stroke: \"#666\",\n                strokeWidth: 1\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2051,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                x: distanceLabelX,\n                y: 335,\n                textAnchor: \"middle\",\n                fill: \"#666\",\n                fontSize: \"12px\",\n                children: `${distanceInfo.distance.toFixed(2)} μL`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2060,\n                columnNumber: 23\n              }, this)]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 2031,\n              columnNumber: 21\n            }, this), displayDropletInfo && /*#__PURE__*/_jsxDEV(_Fragment, {\n              children: [/*#__PURE__*/_jsxDEV(\"text\", {\n                x: centerX,\n                y: 270,\n                textAnchor: \"middle\",\n                fill: \"#6f6\",\n                fontSize: \"12px\",\n                children: `Vol: ${(droplet.frontVolumetricPosition - droplet.rearVolumetricPosition).toFixed(2)} μL`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2075,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                x: centerX,\n                y: 255,\n                textAnchor: \"middle\",\n                fill: \"#6f6\",\n                fontSize: \"12px\",\n                children: `Spd f: ${droplet.frontVolumetricSpeed.toFixed(2)} μL/s`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2084,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                x: centerX,\n                y: 240,\n                textAnchor: \"middle\",\n                fill: \"#6f6\",\n                fontSize: \"12px\",\n                children: `Spd r: ${droplet.rearVolumetricSpeed.toFixed(2)} μL/s`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2093,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                x: centerX,\n                y: 225,\n                textAnchor: \"middle\",\n                fill: \"#6f6\",\n                fontSize: \"12px\",\n                children: `mlt: ${droplet.pumpSpeedMultiplier.toFixed(2)}`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2102,\n                columnNumber: 23\n              }, this)]\n            }, void 0, true)]\n          }, `droplet-${droplet.id}`, true, {\n            fileName: _jsxFileName,\n            lineNumber: 2017,\n            columnNumber: 17\n          }, this);\n        }), displayPumpSpeeds && graphData.nodes.map((node, index) => {\n          if (node.type === 'pump') {\n            var _dropletHistory;\n            const currentSpeed = getPumpSpeedAtTime(node.id, pumpEvents, currentTime);\n            const maxTime = ((_dropletHistory = dropletHistory[dropletHistory.length - 1]) === null || _dropletHistory === void 0 ? void 0 : _dropletHistory.time) || 1;\n            const pumpSpecificEvents = pumpEvents.filter(event => event.target === node.id);\n            return /*#__PURE__*/_jsxDEV(\"g\", {\n              children: [/*#__PURE__*/_jsxDEV(\"text\", {\n                x: node.x,\n                y: node.y - 35,\n                textAnchor: \"middle\",\n                fill: \"#4CAF50\",\n                fontSize: \"12px\",\n                children: `${currentSpeed.toFixed(2)} μL/s`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2126,\n                columnNumber: 21\n              }, this), /*#__PURE__*/_jsxDEV(\"g\", {\n                transform: `translate(${node.x - 40}, ${node.y - 65})`,\n                children: [pumpSpecificEvents.map((event, i, arr) => {\n                  const nextEvent = arr[i + 1];\n                  const width = 80;\n                  const x = 0;\n                  const y = 0;\n\n                  // Calculate position based on time\n                  const timePosition = event.time / maxTime * width;\n                  const nextTimePosition = nextEvent ? nextEvent.time / maxTime * width : width;\n\n                  // Calculate height based on speed value (normalized)\n                  const maxSpeed = Math.max(...pumpSpecificEvents.map(e => e.value));\n                  const normalizedHeight = event.value / (maxSpeed || 1) * 20;\n                  return /*#__PURE__*/_jsxDEV(\"g\", {\n                    children: [/*#__PURE__*/_jsxDEV(\"line\", {\n                      x1: x + timePosition,\n                      y1: y - normalizedHeight,\n                      x2: x + nextTimePosition,\n                      y2: y - normalizedHeight,\n                      stroke: \"#4CAF50\",\n                      strokeWidth: 2\n                    }, void 0, false, {\n                      fileName: _jsxFileName,\n                      lineNumber: 2157,\n                      columnNumber: 29\n                    }, this), /*#__PURE__*/_jsxDEV(\"circle\", {\n                      cx: x + timePosition,\n                      cy: y - normalizedHeight,\n                      r: 2,\n                      fill: \"#4CAF50\"\n                    }, void 0, false, {\n                      fileName: _jsxFileName,\n                      lineNumber: 2166,\n                      columnNumber: 29\n                    }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                      x: x + timePosition,\n                      y: y + 12,\n                      textAnchor: \"middle\",\n                      fill: \"#666\",\n                      fontSize: \"10px\",\n                      children: [event.time.toFixed(1), \"s\"]\n                    }, void 0, true, {\n                      fileName: _jsxFileName,\n                      lineNumber: 2173,\n                      columnNumber: 29\n                    }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                      x: x + timePosition,\n                      y: y - normalizedHeight - 5,\n                      textAnchor: \"middle\",\n                      fill: \"#4CAF50\",\n                      fontSize: \"8px\",\n                      children: event.value.toFixed(1)\n                    }, void 0, false, {\n                      fileName: _jsxFileName,\n                      lineNumber: 2183,\n                      columnNumber: 29\n                    }, this)]\n                  }, `pump-event-${i}`, true, {\n                    fileName: _jsxFileName,\n                    lineNumber: 2155,\n                    columnNumber: 27\n                  }, this);\n                }), /*#__PURE__*/_jsxDEV(\"line\", {\n                  x1: currentTime / maxTime * 80,\n                  y1: -25,\n                  x2: currentTime / maxTime * 80,\n                  y2: 15,\n                  stroke: \"red\",\n                  strokeWidth: 1,\n                  strokeDasharray: \"2,2\"\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 2196,\n                  columnNumber: 23\n                }, this)]\n              }, void 0, true, {\n                fileName: _jsxFileName,\n                lineNumber: 2137,\n                columnNumber: 21\n              }, this)]\n            }, `pump-speed-${node.id}`, true, {\n              fileName: _jsxFileName,\n              lineNumber: 2124,\n              columnNumber: 19\n            }, this);\n          }\n          return null;\n        })]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1930,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1929,\n      columnNumber: 9\n    }, this), selectedNode && (selectedNode.type === 'pump' || ((_selectedNode$data = selectedNode.data) === null || _selectedNode$data === void 0 ? void 0 : _selectedNode$data.type) === 'pump') && /*#__PURE__*/_jsxDEV(DraggablePanel, {\n      initialPosition: pumpPanelPosition,\n      title: `Pump Controls - ${selectedNode.label || selectedNode.id}`,\n      children: /*#__PURE__*/_jsxDEV(PumpActions, {\n        node: selectedNode,\n        nodes: nodes,\n        edges: edges,\n        onAction: handleNodeAction\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 2220,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 2216,\n      columnNumber: 9\n    }, this), selectedNode && (selectedNode.type === 'USBSpectrometer' || ((_selectedNode$data2 = selectedNode.data) === null || _selectedNode$data2 === void 0 ? void 0 : _selectedNode$data2.type) === 'USBSpectrometer') && /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [console.log('Rendering USBSpectrometer component for node:', selectedNode), /*#__PURE__*/_jsxDEV(USBSpectrometer, {\n        detector: selectedNode,\n        detectorId: selectedNode.id,\n        detectorName: selectedNode.label || selectedNode.id,\n        onClose: () => setSelectedNode(null),\n        initialPosition: {\n          x: 150,\n          y: 100\n        },\n        isVisible: true\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 2231,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true), selectedNode && (selectedNode.type === 'MQTTSpectrometer' || ((_selectedNode$data3 = selectedNode.data) === null || _selectedNode$data3 === void 0 ? void 0 : _selectedNode$data3.type) === 'MQTTSpectrometer') && /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [console.log('Rendering SpectrometerMQTT component for node:', selectedNode), /*#__PURE__*/_jsxDEV(SpectrometerMQTT, {\n        detector: selectedNode,\n        detectorId: selectedNode.id,\n        detectorName: selectedNode.label || selectedNode.id,\n        onClose: () => setSelectedNode(null),\n        initialPosition: {\n          x: 150,\n          y: 100\n        },\n        isVisible: true\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 2244,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true), /*#__PURE__*/_jsxDEV(\"style\", {\n      children: `\n          .node-actions {\n            position: fixed;\n            top: 20px;\n            right: 20px;\n            background: black;\n            padding: 20px;\n            border: 1px solid #ccc;\n            border-radius: 5px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n          }\n          .node-actions h3 {\n            margin: 0 0 15px 0;\n            color: #333;\n          }\n          .node-actions button {\n            margin: 5px;\n            padding: 8px 16px;\n            background: #4CAF50;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n          }\n          .node-actions button:disabled {\n            background: #ccc;\n            cursor: not-allowed;\n          }\n          .node-actions input {\n            margin: 5px;\n            padding: 8px;\n            border: 1px solid #ccc;\n            border-radius: 4px;\n            width: 80px;\n          }\n          .move-controls {\n            display: flex;\n            flex-direction: column;\n            gap: 10px;\n            margin-top: 10px;\n          }\n          .input-group {\n            display: flex;\n            align-items: center;\n            gap: 10px;\n          }\n          .input-group label {\n            min-width: 100px;\n            text-align: right;\n            color: #666;\n          }\n        `\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 2255,\n      columnNumber: 7\n    }, this), overlayComponent && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: 'fixed',\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0,\n        zIndex: 9999,\n        pointerEvents: 'none'\n      },\n      children: /*#__PURE__*/_jsxDEV(Suspense, {\n        fallback: /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            position: 'fixed',\n            top: '50%',\n            left: '50%',\n            transform: 'translate(-50%, -50%)',\n            background: 'rgba(0,0,0,0.8)',\n            padding: '20px',\n            borderRadius: '8px',\n            color: 'white',\n            pointerEvents: 'auto'\n          },\n          children: /*#__PURE__*/_jsxDEV(\"h2\", {\n            children: \"Loading Component...\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 2331,\n            columnNumber: 15\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2320,\n          columnNumber: 13\n        }, this),\n        children: [overlayComponent.type === 'USBSpectrometer' && /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            pointerEvents: 'auto'\n          },\n          children: /*#__PURE__*/_jsxDEV(USBSpectrometer, {\n            ...overlayComponent.props\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 2336,\n            columnNumber: 17\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2335,\n          columnNumber: 15\n        }, this), overlayComponent.type === 'MQTTSpectrometer' && /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            pointerEvents: 'auto'\n          },\n          children: /*#__PURE__*/_jsxDEV(SpectrometerMQTT, {\n            ...overlayComponent.props,\n            graphRef: graphRefs.current[overlayComponent.props.detector.id]\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 2341,\n            columnNumber: 17\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2340,\n          columnNumber: 15\n        }, this), overlayComponent.type === 'PumpPanel' && /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            pointerEvents: 'auto'\n          },\n          children: /*#__PURE__*/_jsxDEV(PumpPanel, {\n            ...overlayComponent.props\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 2349,\n            columnNumber: 17\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2348,\n          columnNumber: 15\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 2319,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 2310,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 1755,\n    columnNumber: 5\n  }, this);\n};\n_s(Simulation, \"CpoCBrE9dcWkinZ5MUDGpJrTK/s=\", false, function () {\n  return [useButtonStyles];\n});\n_c = Simulation;\nexport default Simulation;\nvar _c;\n$RefreshReg$(_c, \"Simulation\");","map":{"version":3,"names":["React","useState","useEffect","useCallback","useRef","Suspense","ReactFlowProvider","useNodesState","useEdgesState","PumpActions","DraggablePanel","convertToHardwareValuesPump","useButtonStyles","backgroundVariants","findOutletNode","findFurthestNode","orderNodesByDistance","calculateEdgeVolume","getVolumeBetweenNodes","findConnectedPump","getPumpSpeed","getPumpsBetweenPositions","cleanAndSortEventList","getPumpSpeedAtTime","sendEventsToDevices","setOfMainLineNodes","setOfSecondaryLineNodes","SvgDefs","calculateEdgePoints","createLabels","USBSpectrometer","SpectrometerMQTT","PumpPanel","jsxDEV","_jsxDEV","Fragment","_Fragment","Simulation","nodes","edges","droplets","selectedCarrierPumps","onBack","onNext","_s","_dropletHistory$curre","_selectedNode$data","_selectedNode$data2","_selectedNode$data3","buttonVariants","graphData","setGraphData","links","simulationDroplets","setSimulationDroplets","isSimulationRunning","setIsSimulationRunning","key","setKey","currentTime","setCurrentTime","timeScale","setTimeScale","animationFrameRef","lastFrameTimeRef","currentBlockDroplets","setCurrentBlockDroplets","dropletHistory","setDropletHistory","currentTimepoint","setCurrentTimepoint","pumpEvents","setPumpEvents","detectorEvents","setDetectorEvents","displayPumpSpeeds","setDisplayPumpSpeeds","displayNodeIds","setDisplayNodeIds","displayDropletInfo","setDisplayDropletInfo","displayDropletGaps","setDisplayDropletGaps","displayEdgeLabels","setDisplayEdgeLabels","isDisplayMenuOpen","setDisplayMenuOpen","displayTimelineDropletInfo","setDisplayTimelineDropletInfo","displayDetectorEvents","setDisplayDetectorEvents","displayMenuRef","selectedNode","setSelectedNode","ws","setWs","pumpPanelPosition","setPumpPanelPosition","x","window","innerWidth","y","visiblePumpPanel","setVisiblePumpPanel","isSendingEvents","setIsSendingEvents","graphRefs","overlayComponent","setOverlayComponent","console","log","length","map","node","_node$data","id","type","dataType","data","websocket","WebSocket","onopen","onerror","error","close","sendingEventsToDevices","generateEventList","Object","values","current","forEach","graphRef","addToMemory","eventType","calculateVolumesBetweenThermostats","outletNode","visited","Set","queue","thermostatVolumes","currentNodeId","accumulatedVolume","thermostatPath","shift","currentNode","find","n","has","add","updatedPath","push","startThermostatId","endThermostatId","volume","connectedEdges","filter","link","source","target","edge","nextNodeId","nextNode","edgeVolume","divideDropletsIntoBlocks","thermostatId","totalVolume","reduce","acc","droplet","actualVolume","temperature","time","furthestNode","volumeToFurthestNode","blocks","currentBlock","finalizeBlock","lastDroplet","surfixParam","parameters","p","name","value","Math","max","i","_droplet$parameters$f","_droplet$parameters$f2","_droplet$parameters$f3","_droplet$parameters$f4","_droplet$parameters$f5","relevantVolume","tv","dropletVolume","printDropletFrontPositionsAndSpeeds","frontVolumetricPosition","frontTimeToReachNextNode","frontVolumetricDistanceToNextNode","rearVolumetricPosition","rearTimeToReachNextNode","rearVolumetricDistanceToNextNode","frontNextNodeID","rearNextNodeID","extractPumpEvents","eventList","flat","event","sort","a","b","extractDetectorEvents","recalculateEventListForDevices","deviceEventMap","Map","convertPumpEvent","deviceProperties","_deviceProperties$fin","_deviceProperties$fin2","_deviceProperties$fin3","_deviceProperties$fin4","syringeDiameter","default","syringeLength","stepsPerRevolution","lead","syringeArea","PI","pow","linearSpeed","abs","stepsPerMm","stepsPerSecond","delayMicroseconds","round","delay","convertThermostatEvent","convertLedEvent","intensity","convertDetectorEvent","setting","deviceEventList","targetId","deviceNode","deviceEvents","properties","warn","Boolean","set","Array","from","isArray","orderedNodes","dropletSnapshot","dropletWithParams","d","volumetricSpeedParam","commonVolumetricSpeed","inletVolumetricSpeed","outletVolumetricSpeed","pump","connectedPump","connectedPumpRatio","connectedPumpSpeedAtPause","pumpSpeedMultiplier","pauseLevel","carrierPumpConnector","connectorNode","position","_droplet$parameters$f6","_droplet$parameters$f7","prefixVolume","surfixVolume","frontVolumetricSpeed","rearVolumetricSpeed","frontVolumetricSpeedAtPause","rearVolumetricSpeedAtPause","stoppingDroplet","initialPumping","lastDropletRearPosition","outletNodePosition","volumetricPosition","timePassed","newTimePassed","smallestFrontTime","Infinity","smallestRearTime","smallestFrontTimeDroplet","smallestRearTimeDroplet","min","reachedNode","reachedNodeDistance","distance","index","indexOf","dropletsOlder","slice","dropletsNewer","ds","drops","JSON","parse","stringify","snappedNode","existingSnapshotIndex","findIndex","snapshot","nextEdge","_smallestFrontTimeDro","_smallestFrontTimeDro2","pumpRatio","param","nodeId","dropletDesiredVolume","_smallestFrontTimeDro3","_smallestFrontTimeDro4","rearTimeLeft","totalTimeLeft","thispumpspeed","accumulatedSpeed","reverse","editedNode","pumpBoost","_smallestRearTimeDrop","detectorEndEvent","dropletId","eventSubtype","dropletData","speedDifference","accumulatedSpeedDecrease","pumpBreak","isFarthestThermostatOrLED","every","_smallestRearTimeDrop2","waitTime","carrierPumpEvent","_smallestRearTimeDrop3","dropletState","_droplet$parameters$f8","prev","graphNodes","label","graphLinks","_edge$data","_edge$data$properties","_edge$data2","_edge$data2$propertie","diameter","nodesLength","linksLength","dropletsLength","mainLineNodes","includes","secondaryLineNodes","mainLineY","secondaryLineY","pumpSpacing","currentX","currentVolumetricPosition","graphNode","e","nodesByDistance","pumpOffset","entries","connectedEdge","connectedNodeId","connectedMainNode","thermoVol","dropletsCopy","eventListForDevices","startSimulation","stopSimulation","cancelAnimationFrame","restartSimulation","prevKey","getNodeColor","volumetricToXPosition","_graphData$nodes$find","_graphData$nodes$find2","outletX","furthestX","isNaN","undefined","clampedPosition","scaledX","isFinite","updateDropletPositions","timestamp","requestAnimationFrame","deltaTime","simulationDeltaTime","prevTime","newTime","lastHistoryTime","currentState","interpolateDropletState","updatedDroplets","frontX","rearX","frontPosition","rearPosition","speed","state","beforeState","afterState","fraction","beforeDroplet","afterDroplet","jumpToTimepoint","nextTimepoint","previousTimepoint","handleNodeClick","_node$data2","_node$data3","nodeType","createRef","handleNodeAction","action","togglePumpSpeeds","toggleNodeIds","toggleDropletInfo","toggleDropletGaps","toggleEdgeLabels","toggleDisplayMenu","toggleTimelineDropletInfo","toggleDetectorEvents","handleClickOutside","contains","document","addEventListener","removeEventListener","togglePumpPanel","pumpId","styles","container","mainBackground","padding","minHeight","dropletInfo","borderRadius","fontSize","panelBackground","color","minWidth","timelineContainer","display","flexDirection","gap","marginBottom","timeInput","width","inputBackground","marginLeft","buttonGroup","marginTop","timelineControls","timeControls","sliderContainer","alignItems","borderBottom","paddingBottom","timeStepButtons","justifyContent","timeScaleContainer","borderTop","paddingTop","svgContainer","background","navigationButtons","timeSlider","height","WebkitAppearance","appearance","outline","opacity","transition","cursor","displayMenuButton","infoButton","displayMenu","top","right","backgroundColor","border","zIndex","boxShadow","menuItem","checkmark","fontWeight","sliderStyle","style","children","onChange","Number","disabled","className","fileName","_jsxFileName","lineNumber","columnNumber","flexWrap","_graphData$nodes$find3","_graphData$nodes$find4","onClick","secondaryButton","marginRight","toFixed","primaryButton","ref","sourceNode","targetNode","midX","midY","x1","y1","x2","y2","stroke","strokeWidth","textAnchor","fill","cx","cy","r","centerX","distanceInfo","nextDropletFront","distanceLabelX","strokeLinecap","strokeDasharray","_dropletHistory","currentSpeed","maxTime","pumpSpecificEvents","transform","arr","nextEvent","timePosition","nextTimePosition","maxSpeed","normalizedHeight","initialPosition","title","onAction","detector","detectorId","detectorName","onClose","isVisible","left","bottom","pointerEvents","fallback","props","_c","$RefreshReg$"],"sources":["E:/flow chemistry/fluidicGUI/frontend/fluidicgui/src/components/Simulation/Simulation.js"],"sourcesContent":["import React, { useState, useEffect, useCallback, useRef, Suspense } from 'react';\r\nimport { ReactFlowProvider, useNodesState, useEdgesState } from 'react-flow-renderer';\r\nimport PumpActions from './NodeActions/PumpActions';\r\nimport DraggablePanel from './DraggablePanel';\r\nimport { convertToHardwareValuesPump } from '../../utils/pumpCalculations';\r\nimport { useButtonStyles } from '../../styles/ButtonStyleProvider';\r\nimport { backgroundVariants } from '../../styles/backgroundStyles';\r\nimport {\r\n  findOutletNode,\r\n  findFurthestNode,\r\n  orderNodesByDistance,\r\n  calculateEdgeVolume,\r\n  getVolumeBetweenNodes,\r\n  findConnectedPump,\r\n  getPumpSpeed,\r\n  getPumpsBetweenPositions,\r\n  cleanAndSortEventList,\r\n  getPumpSpeedAtTime,\r\n  sendEventsToDevices,\r\n  setOfMainLineNodes,\r\n  setOfSecondaryLineNodes\r\n} from '../../utils/simulationUtils';\r\nimport './simulation.css'; // We'll create this CSS file\r\nimport SvgDefs from './SvgDefs';\r\nimport { calculateEdgePoints, createLabels } from '../../utils/flowchartUtils';\r\nimport USBSpectrometer from './USBSpectrometer';\r\nimport SpectrometerMQTT from './SpectrometerMQTT';\r\nimport PumpPanel from './PumpPanel';\r\n\r\nconst Simulation = ({ nodes = [], edges = [], droplets = [], selectedCarrierPumps = [], onBack, onNext }) => {\r\n  const buttonVariants = useButtonStyles();\r\n  const [graphData, setGraphData] = useState({ nodes: [], links: [] });\r\n  const [simulationDroplets, setSimulationDroplets] = useState([]);\r\n  const [isSimulationRunning, setIsSimulationRunning] = useState(false);\r\n  const [key, setKey] = useState(0);\r\n  const [currentTime, setCurrentTime] = useState(0);\r\n  const [timeScale, setTimeScale] = useState(1); // Default 1x speed\r\n  const animationFrameRef = useRef();\r\n  const lastFrameTimeRef = useRef();\r\n  const [currentBlockDroplets, setCurrentBlockDroplets] = useState([]);\r\n  const [dropletHistory, setDropletHistory] = useState([]);\r\n  const [currentTimepoint, setCurrentTimepoint] = useState(0);\r\n  const [pumpEvents, setPumpEvents] = useState([]);\r\n  const [detectorEvents, setDetectorEvents] = useState([]);\r\n  const [displayPumpSpeeds, setDisplayPumpSpeeds] = useState(false);\r\n  const [displayNodeIds, setDisplayNodeIds] = useState(false);\r\n  const [displayDropletInfo, setDisplayDropletInfo] = useState(false);\r\n  const [displayDropletGaps, setDisplayDropletGaps] = useState(true);\r\n  const [displayEdgeLabels, setDisplayEdgeLabels] = useState(false);\r\n  const [isDisplayMenuOpen, setDisplayMenuOpen] = useState(false);\r\n  const [displayTimelineDropletInfo, setDisplayTimelineDropletInfo] = useState(false);\r\n  const [displayDetectorEvents, setDisplayDetectorEvents] = useState(false);\r\n  const displayMenuRef = useRef(null);\r\n  const [selectedNode, setSelectedNode] = useState(null);\r\n  const [ws, setWs] = useState(null);\r\n  const [pumpPanelPosition, setPumpPanelPosition] = useState({ x: window.innerWidth - 300, y: 100 });\r\n  const [visiblePumpPanel, setVisiblePumpPanel] = useState(null);\r\n  const [isSendingEvents, setIsSendingEvents] = useState(false);\r\n  const graphRefs = useRef({});\r\n  const [overlayComponent, setOverlayComponent] = useState(null);\r\n\r\n  // Add at the beginning of the component, after the state initialization\r\n  useEffect(() => {\r\n    // Log all nodes and their types for debugging\r\n    console.log('All nodes:', nodes);\r\n    if (nodes && nodes.length > 0) {\r\n      console.log('Node types in simulation:', nodes.map(node => ({\r\n        id: node.id,\r\n        type: node.type,\r\n        dataType: node.data?.type\r\n      })));\r\n    }\r\n  }, [nodes]);\r\n\r\n  useEffect(() => {\r\n    // Create WebSocket connection\r\n    const websocket = new WebSocket('ws://localhost:4000');\r\n    \r\n    websocket.onopen = () => {\r\n      console.log('Connected to WebSocket server');\r\n    };\r\n\r\n    websocket.onerror = (error) => {\r\n      console.error('WebSocket error:', error);\r\n    };\r\n\r\n    setWs(websocket);\r\n\r\n    // Cleanup on unmount\r\n    return () => {\r\n      if (websocket) {\r\n        websocket.close();\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  const sendingEventsToDevices = () => {\r\n    setIsSendingEvents(true);\r\n    sendEventsToDevices(pumpEvents, ws, nodes);\r\n    // Reset simulation state\r\n    setCurrentTime(0);\r\n    setCurrentTimepoint(0);\r\n    setIsSimulationRunning(true);\r\n    setDropletHistory([]);\r\n    // Generate new event list\r\n    generateEventList([{ droplets: droplets }]);\r\n  };\r\n\r\n  // Add effect to handle automatic memory addition when events are being sent\r\n  useEffect(() => {\r\n    if (isSendingEvents) {\r\n      // Get all graph refs and add data to memory\r\n      Object.values(graphRefs.current).forEach(graphRef => {\r\n        if (graphRef && graphRef.current && graphRef.current.addToMemory) {\r\n          graphRef.current.addToMemory();\r\n        }\r\n      });\r\n    }\r\n  }, [isSendingEvents]);\r\n\r\n  const eventType = ['setPumpSpeed', 'setThermostatTemperature', 'setLedIntensity', 'wait', 'blockEnd'];\r\n\r\n  const calculateVolumesBetweenThermostats = (graphData) => {\r\n  \r\n    // Find outlet node first\r\n    const outletNode = findOutletNode(graphData.nodes);\r\n  \r\n    const visited = new Set();\r\n    const queue = [[outletNode.id, 0, []]]; // [nodeId, accumulated volume, path of thermostats]\r\n    const thermostatVolumes = [];\r\n  \r\n    while (queue.length > 0) {\r\n      let [currentNodeId, accumulatedVolume, thermostatPath] = queue.shift();\r\n      const currentNode = graphData.nodes.find(n => n.id === currentNodeId);\r\n  \r\n      if (!currentNode) continue;\r\n      \r\n      // Track all visited nodes to prevent infinite loops\r\n      if (visited.has(currentNodeId)) continue;\r\n      visited.add(currentNodeId);\r\n  \r\n      // If we found a thermostat, add it to the path\r\n      let updatedPath = [...thermostatPath];\r\n      if (currentNode.type === 'thermostat') {\r\n        if (thermostatPath.length > 0) {\r\n          thermostatVolumes.push({\r\n            startThermostatId: thermostatPath[thermostatPath.length - 1],\r\n            endThermostatId: currentNodeId,\r\n            volume: accumulatedVolume\r\n          });\r\n        }\r\n        updatedPath.push(currentNodeId);\r\n        // Reset accumulated volume after finding a thermostat\r\n        accumulatedVolume = 0;\r\n      }\r\n  \r\n      // Find all connected edges and nodes\r\n      const connectedEdges = graphData.links.filter(link => \r\n        link.source === currentNodeId || link.target === currentNodeId\r\n      );\r\n  \r\n      for (const edge of connectedEdges) {\r\n        const nextNodeId = edge.source === currentNodeId ? edge.target : edge.source;\r\n        const nextNode = graphData.nodes.find(n => n.id === nextNodeId);\r\n        \r\n        // Skip paths to pumps\r\n        if (nextNode && nextNode.type !== 'pump') {\r\n          const edgeVolume = calculateEdgeVolume(edge);\r\n          queue.push([nextNodeId, accumulatedVolume + edgeVolume, updatedPath]);\r\n        }\r\n      }\r\n    }\r\n  \r\n    return thermostatVolumes;\r\n  };\r\n//add something to handle lack of thermostat\r\n  const divideDropletsIntoBlocks = (droplets, thermostatVolumes) => {\r\n\r\n    if (thermostatVolumes.length === 0) {\r\n      return [{\r\n        droplets: droplets,\r\n        thermostatId: null,\r\n        totalVolume: droplets.reduce((acc, droplet) => acc + droplet.actualVolume, 0),\r\n        temperature: null,\r\n        time: null\r\n      }];\r\n    }\r\n\r\n    const furthestNode = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links);\r\n\r\n    const volumeToFurthestNode = getVolumeBetweenNodes(thermostatVolumes[0].endThermostatId, furthestNode.id, graphData.nodes, graphData.links);\r\n    \r\n    if (!droplets.length || !thermostatVolumes.length) return [];\r\n\r\n    const blocks = [];\r\n    let currentBlock = {\r\n      droplets: [],\r\n      thermostatId: thermostatVolumes[0].endThermostatId,\r\n      totalVolume: 0,\r\n      temperature: null,\r\n      time: null\r\n    };\r\n\r\n    // Helper to finalize a block and start a new one\r\n    const finalizeBlock = (thermostatId, temperature, time) => {\r\n      if (currentBlock.droplets.length > 0) {\r\n        // Add volumeToFurthestNode to the surfixVolume of the last droplet in the block\r\n        const lastDroplet = currentBlock.droplets[currentBlock.droplets.length - 1];\r\n        const surfixParam = lastDroplet.parameters.find(p => p.name === 'surfixVolume');\r\n        if (surfixParam) {\r\n          surfixParam.value = Math.max(volumeToFurthestNode, surfixParam.value);\r\n        } else {\r\n          lastDroplet.parameters.push({\r\n            name: 'surfixVolume',\r\n            value: volumeToFurthestNode\r\n          });\r\n        }\r\n        \r\n        blocks.push({ ...currentBlock });\r\n      }\r\n      currentBlock = {\r\n        droplets: [],\r\n        thermostatId: thermostatId,\r\n        totalVolume: 0,\r\n        temperature: temperature,\r\n        time: time\r\n      };\r\n    };\r\n\r\n    // Process droplets in order\r\n    for (let i = 0; i < droplets.length; i++) {\r\n      const droplet = droplets[i];\r\n      const temperature = droplet.parameters.find(p => p.name === 'temperature')?.value;\r\n      const time = droplet.parameters.find(p => p.name === 'time')?.value;\r\n\r\n      // Start new block if temperature or time changes, or if volume limit exceeded\r\n      const relevantVolume = thermostatVolumes.find(tv => \r\n        tv.startThermostatId === currentBlock.thermostatId || \r\n        tv.endThermostatId === currentBlock.thermostatId\r\n      );\r\n\r\n      let dropletVolume = droplet.parameters.find(p => p.name === 'volume')?.value;\r\n      dropletVolume += droplet.parameters.find(p => p.name === 'prefixVolume')?.value;\r\n      \r\n\r\n      if (\r\n        currentBlock.temperature !== temperature ||\r\n        currentBlock.time !== time ||\r\n        (relevantVolume && currentBlock.totalVolume + dropletVolume > relevantVolume.volume)\r\n      ) {\r\n        finalizeBlock(thermostatVolumes[0].endThermostatId, temperature, time);\r\n      }\r\n      dropletVolume += droplet.parameters.find(p => p.name === 'surfixVolume')?.value;\r\n      // Add droplet to current block\r\n      currentBlock.droplets.push(droplet);\r\n      currentBlock.totalVolume += dropletVolume;\r\n      currentBlock.temperature = temperature;\r\n      currentBlock.time = time;\r\n    }\r\n\r\n    // Finalize last block\r\n    finalizeBlock(null, null, null);\r\n\r\n    return blocks;\r\n  };\r\n\r\n  function printDropletFrontPositionsAndSpeeds(droplets) {\r\n    droplets.forEach(droplet => {\r\n      console.log(`Droplet ID: ${droplet.id}, Front Volumetric Position: ${droplet.frontVolumetricPosition}, Front time to next node  : ${droplet.frontTimeToReachNextNode}, Front Volumetric Distance to next node: ${droplet.frontVolumetricDistanceToNextNode}, Rear Volumetric Position: ${droplet.rearVolumetricPosition}, Rear time to next node: ${droplet.rearTimeToReachNextNode}, Rear Volumetric Distance to next node: ${droplet.rearVolumetricDistanceToNextNode}, frontNextNodeID: ${droplet.frontNextNodeID}, rearNextNodeID: ${droplet.rearNextNodeID}`);\r\n    });\r\n  }\r\n\r\n  const extractPumpEvents = (eventList) => {\r\n    // eventList is now an array of arrays, where each inner array contains events for a specific pump\r\n    return eventList\r\n      .flat() // Flatten the array of arrays\r\n      .filter(event => event.type === 'setPumpSpeed')\r\n      .sort((a, b) => a.time - b.time);\r\n  };\r\n\r\n  const extractDetectorEvents = (eventList) => {\r\n    // Extract detector/spectrometer measurement events\r\n    return eventList\r\n      .flat() // Flatten the array of arrays\r\n      .filter(event => event.type === 'setDetectorMeasurement')\r\n      .sort((a, b) => a.time - b.time);\r\n  };\r\n\r\n  const recalculateEventListForDevices = (eventList) => {\r\n    const deviceEventMap = new Map();\r\n\r\n    const convertPumpEvent = (event, deviceProperties) => {\r\n      // Find properties by name from the properties array\r\n      const syringeDiameter = deviceProperties.find(p => p.name === 'diameter')?.default || 0;\r\n      const syringeLength = deviceProperties.find(p => p.name === 'length')?.default || 0;\r\n      const stepsPerRevolution = deviceProperties.find(p => p.name === 'steps per revolution')?.default || 0;\r\n      const lead = deviceProperties.find(p => p.name === 'lead')?.default || 0;\r\n\r\n      const syringeArea = Math.PI * Math.pow(syringeDiameter / 2, 2);\r\n      const linearSpeed = Math.abs(event.value) / syringeArea;\r\n      const stepsPerMm = stepsPerRevolution / lead;\r\n      const stepsPerSecond = linearSpeed * stepsPerMm;\r\n      const delayMicroseconds = stepsPerSecond > 0 ? \r\n        Math.round(1000000 / stepsPerSecond) : \r\n        0;\r\n\r\n      return {\r\n        target: event.target,\r\n        time: Math.round(event.time * 1000000),\r\n        delay: delayMicroseconds\r\n      };\r\n    };\r\n\r\n    const convertThermostatEvent = (event, deviceProperties) => {\r\n      // Placeholder for thermostat conversion logic\r\n      return {\r\n        target: event.target,\r\n        time: Math.round(event.time * 1000000),\r\n        temperature: event.value,\r\n        // Add other thermostat-specific parameters here\r\n      };\r\n    };\r\n\r\n    const convertLedEvent = (event, deviceProperties) => {\r\n      // Placeholder for LED conversion logic\r\n      return {\r\n        target: event.target,\r\n        time: Math.round(event.time * 1000000),\r\n        intensity: event.value,\r\n        // Add other LED-specific parameters here\r\n      };\r\n    };\r\n\r\n    const convertDetectorEvent = (event, deviceProperties) => {\r\n      // Placeholder for detector conversion logic\r\n      return {\r\n        target: event.target,\r\n        time: Math.round(event.time * 1000000),\r\n        setting: event.value,\r\n        // Add other detector-specific parameters here\r\n      };\r\n    };\r\n\r\n    eventList.forEach(deviceEventList => {\r\n      if (!deviceEventList.length) return;\r\n\r\n      const targetId = deviceEventList[0].target;\r\n      const deviceNode = nodes.find(node => node.id === targetId);\r\n      \r\n      if (!deviceNode || !deviceNode.data) {\r\n        console.error(`Device node or data not found for ID: ${targetId}`);\r\n        return;\r\n      }\r\n\r\n      const deviceEvents = deviceEventList.map(event => {\r\n        switch (event.type) {\r\n          case 'setPumpSpeed':\r\n            return convertPumpEvent(event, deviceNode.data.properties);\r\n          \r\n          case 'setThermostatTemperature':\r\n            return convertThermostatEvent(event, deviceNode.data.properties);\r\n          \r\n          case 'setLedIntensity':\r\n            return convertLedEvent(event, deviceNode.data.properties);\r\n          \r\n          case 'setDetectorSetting':\r\n            return convertDetectorEvent(event, deviceNode.data.properties);\r\n          \r\n          default:\r\n            console.warn(`Unknown event type: ${event.type}`);\r\n            return null;\r\n        }\r\n      }).filter(Boolean); // Remove any null events\r\n\r\n      if (deviceEvents.length > 0) {\r\n        deviceEventMap.set(targetId, deviceEvents);\r\n      }\r\n    });\r\n    console.log('deviceEventMap: ', Array.from(deviceEventMap.values()));\r\n    return Array.from(deviceEventMap.values());\r\n  };\r\n\r\n  const generateEventList = (blocks) => {\r\n    // Early exit if blocks array is invalid\r\n    if (!blocks || !Array.isArray(blocks) || blocks.length === 0) {\r\n      console.warn('No valid blocks found for event generation');\r\n      return [];\r\n    }\r\n\r\n    const orderedNodes = orderNodesByDistance(findOutletNode(graphData.nodes), graphData.nodes, graphData.links);\r\n    console.log('orderedNodes: ', orderedNodes);\r\n    \r\n    // Early exit if no ordered nodes\r\n    if (!orderedNodes || orderedNodes.length === 0) {\r\n      console.warn('No ordered nodes found for event generation');\r\n      return [];\r\n    }\r\n    \r\n    let eventList = [];\r\n    let dropletSnapshot = [];\r\n    \r\n    // Validate block droplets\r\n    if (!blocks[0] || !blocks[0].droplets || !Array.isArray(blocks[0].droplets) || blocks[0].droplets.length === 0) {\r\n      console.warn('No valid droplets found in blocks for event generation');\r\n      return [];\r\n    }\r\n    \r\n    const i = 0;\r\n    const currentBlockDroplets = blocks[i].droplets;\r\n    \r\n    // Add fallback for volumetricSpeed in case it's not found\r\n    const dropletWithParams = currentBlockDroplets.find(d => d && d.parameters && Array.isArray(d.parameters));\r\n    if (!dropletWithParams) {\r\n      console.warn('No droplet with valid parameters found');\r\n      return [];\r\n    }\r\n    \r\n    // Make sure we can find the volumetricSpeed parameter or use a default\r\n    const volumetricSpeedParam = dropletWithParams.parameters.find(p => p && p.name === 'volumetricSpeed');\r\n    const commonVolumetricSpeed = volumetricSpeedParam?.value || 1;\r\n    console.log('Using volumetricSpeed:', commonVolumetricSpeed);\r\n    \r\n    //adds some parameters to nodes\r\n    orderedNodes.forEach(node => {\r\n      node.inletVolumetricSpeed = commonVolumetricSpeed;\r\n      node.outletVolumetricSpeed = commonVolumetricSpeed;\r\n      const pump = findConnectedPump(node.node.id, graphData.nodes, graphData.links);\r\n      if (pump) {\r\n        node.connectedPump = pump;\r\n      }\r\n      else {\r\n        node.connectedPump = 0;\r\n      }\r\n      node.connectedPumpRatio = 0;\r\n      node.connectedPumpSpeedAtPause = 0;\r\n      node.pumpSpeedMultiplier = 1;\r\n      //node.requestedRatio = 0;\r\n      node.pauseLevel = 0;\r\n\r\n    });\r\n    //ustawia carrier pump na odpowiednią predkość\r\n    const carrierPumpConnector = graphData.links.find(link => link.source === selectedCarrierPumps[0]).target;\r\n    if (carrierPumpConnector) {\r\n      const connectorNode = orderedNodes.find(node => node.node.id === carrierPumpConnector);\r\n      connectorNode.inletVolumetricSpeed = commonVolumetricSpeed;\r\n      connectorNode.outletVolumetricSpeed = commonVolumetricSpeed;\r\n      connectorNode.connectedPump = graphData.nodes.find(node => node.id === selectedCarrierPumps[0]);\r\n      connectorNode.connectedPumpRatio = 1;\r\n      connectorNode.connectedPumpSpeedAtPause = commonVolumetricSpeed;\r\n      //connectorNode.requestedRatio = 0;\r\n      connectorNode.pauseLevel = 0;\r\n    }\r\n    let event = { //it is ok\r\n      type: 'setPumpSpeed',\r\n      target: selectedCarrierPumps[0],\r\n      time: 0,\r\n      value: commonVolumetricSpeed\r\n    };\r\n    eventList.push(event);\r\n\r\n    orderedNodes.filter(node => node.node.type === 'pump' && node.node.id !== selectedCarrierPumps[0]).forEach(pump => {\r\n      event = {//it is ok\r\n        type: 'setPumpSpeed',\r\n        target: pump.node.id,\r\n        time: 0,\r\n        value: 0\r\n      };\r\n      eventList.push(event);\r\n      \r\n    });\r\n\r\n    \r\n    let position = -0.001;\r\n    //prepares all droplets in block and calculates some parameters\r\n    currentBlockDroplets.forEach(droplet => {\r\n      const prefixVolume = droplet.parameters.find(p => p.name === 'prefixVolume')?.value;\r\n      const surfixVolume = droplet.parameters.find(p => p.name === 'surfixVolume')?.value;\r\n\r\n      droplet.frontVolumetricSpeed = commonVolumetricSpeed;\r\n      droplet.rearVolumetricSpeed = commonVolumetricSpeed;\r\n      droplet.frontVolumetricPosition = position - prefixVolume;\r\n      droplet.rearVolumetricPosition = droplet.frontVolumetricPosition;\r\n      droplet.frontVolumetricDistanceToNextNode = Math.abs(droplet.frontVolumetricPosition);\r\n      droplet.rearVolumetricDistanceToNextNode = Math.abs(droplet.rearVolumetricPosition); \r\n      droplet.frontTimeToReachNextNode = 0;\r\n      droplet.rearTimeToReachNextNode = 0;\r\n      droplet.frontNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\r\n      droplet.rearNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\r\n      droplet.pumpSpeedMultiplier = 1;\r\n      droplet.pauseLevel = 0;\r\n      droplet.frontVolumetricSpeedAtPause = 0;\r\n      droplet.rearVolumetricSpeedAtPause = 0;\r\n      droplet.stoppingDroplet = false;\r\n      droplet.initialPumping = false;\r\n\r\n      position -= ( prefixVolume + surfixVolume);\r\n    });\r\n    console.log('findFurthestNode: ', findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id);\r\n    console.log('Droplet positions initialized, nodes ready');\r\n\r\n    let lastDropletRearPosition = currentBlockDroplets[currentBlockDroplets.length - 1].rearVolumetricPosition;\r\n    let outletNodePosition = orderedNodes[0].node.volumetricPosition; \r\n    let timePassed = 0; //in s\r\n    let newTimePassed = 0;\r\n\r\n    // Simulate the movement of droplets in the current block\r\n    currentBlockDroplets.forEach(droplet => {\r\n      droplet.frontTimeToReachNextNode = Math.abs(droplet.frontVolumetricDistanceToNextNode / droplet.frontVolumetricSpeed);\r\n      droplet.rearTimeToReachNextNode = Math.abs(droplet.rearVolumetricDistanceToNextNode / droplet.rearVolumetricSpeed);\r\n    });\r\n\r\n    while (lastDropletRearPosition < outletNodePosition) {\r\n      \r\n      let smallestFrontTime = Infinity;\r\n      let smallestRearTime = Infinity;\r\n      let smallestFrontTimeDroplet = [];\r\n      let smallestRearTimeDroplet = [];\r\n\r\n      currentBlockDroplets.forEach(droplet => {// Update the smallest front and rear times and associated droplet(s) based on the current droplet's front and rear times to reach the next node.\r\n        \r\n        if (Math.abs(droplet.frontTimeToReachNextNode) < smallestFrontTime) {\r\n          smallestFrontTime = Math.abs(droplet.frontTimeToReachNextNode);\r\n          smallestFrontTimeDroplet = [droplet];\r\n        }\r\n        else if (Math.abs(droplet.frontTimeToReachNextNode) === smallestFrontTime) {\r\n          smallestFrontTimeDroplet.push(droplet);\r\n        }\r\n        if (Math.abs(droplet.rearTimeToReachNextNode) < smallestRearTime) {\r\n          smallestRearTime = Math.abs(droplet.rearTimeToReachNextNode);\r\n          smallestRearTimeDroplet = [droplet];\r\n        }\r\n        else if (Math.abs(droplet.rearTimeToReachNextNode) === smallestRearTime) {\r\n          smallestRearTimeDroplet.push(droplet);\r\n        }\r\n      });\r\n\r\n      newTimePassed += Math.min(Math.abs(smallestFrontTime), Math.abs(smallestRearTime));\r\n\r\n      if (smallestFrontTime === smallestRearTime) {//przypadek w ktorym wiele kropel ma ten sam czas do przejścia do nastepnego noda, rzadki\r\n        \r\n        if (smallestFrontTimeDroplet.length > 1 || smallestRearTimeDroplet.length > 1) {//sprawdź czy wśród nich jest kropla z rear i front\r\n          console.log('Multiple droplets have reached the next node simultaneously');\r\n          console.log('smallestFrontTimeDroplet: ', smallestFrontTimeDroplet);\r\n          console.log('smallestRearTimeDroplet: ', smallestRearTimeDroplet);\r\n          \r\n        }\r\n        else if (smallestFrontTimeDroplet[0] === smallestRearTimeDroplet[0]) {//przypadek gdy kropla ma 0 objętości\r\n          console.log('Both front and rear times are for the same droplet');\r\n          const reachedNode = orderedNodes.find(n => n.node.id === smallestFrontTimeDroplet[0].frontNextNodeID);\r\n          const reachedNodeDistance = orderedNodes.find(node => node.node.id === reachedNode.node.id).distance;\r\n          if (reachedNode.node.type === 'connector') {\r\n\r\n\r\n            const index = currentBlockDroplets.indexOf(smallestFrontTimeDroplet[0]);\r\n            const dropletsOlder = currentBlockDroplets.slice(0, index);\r\n            const dropletsNewer = currentBlockDroplets.slice(index + 1);\r\n\r\n            const ds = [];\r\n            ds.drops = JSON.parse(JSON.stringify(dropletsNewer)); // Create deep copy\r\n            ds.snappedNode = smallestFrontTimeDroplet[0].frontNextNodeID;\r\n            const existingSnapshotIndex = dropletSnapshot.findIndex(snapshot => snapshot.snappedNode === ds.snappedNode);\r\n            if (existingSnapshotIndex !== -1) {\r\n              dropletSnapshot[existingSnapshotIndex] = ds;\r\n            } else {\r\n              dropletSnapshot.push(ds);\r\n            }\r\n\r\n            //aktualizuje starsze krople\r\n            dropletsOlder.forEach(droplet => {\r\n              droplet.frontTimeToReachNextNode -= smallestFrontTime;\r\n              droplet.rearTimeToReachNextNode -= smallestFrontTime;\r\n              droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n              droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n              droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n              droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n            });\r\n\r\n            //aktualizuje kroplę\r\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n            const nextEdge = graphData.links.find(link => link.source === smallestFrontTimeDroplet[0].frontNextNodeID && link.target === nextNode.node.id);\r\n\r\n            if (reachedNode.connectedPump !== null){\r\n              const pumpRatio = smallestFrontTimeDroplet[0].parameters.find(param => param.nodeId === reachedNode.connectedPump.id && param.name === 'ratio')?.value || 0;\r\n              const dropletDesiredVolume = smallestFrontTimeDroplet[0].parameters.find(param => param.name === 'volume')?.value || 0;\r\n              \r\n              reachedNode.connectedPumpRatio = pumpRatio;\r\n              //reachedNode.inletVolumetricSpeed = 0;\r\n              //smallestFrontTimeDroplet[0].frontVolumetricSpeed = reachedNode.outletVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].frontVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].rearVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].rearVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].rearVolumetricSpeed = 0;\r\n              smallestFrontTimeDroplet[0].frontVolumetricPosition = reachedNode.node.volumetricPosition;\r\n              smallestFrontTimeDroplet[0].rearVolumetricPosition = reachedNode.node.volumetricPosition;\r\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n              smallestFrontTimeDroplet[0].rearVolumetricDistanceToNextNode = 0; \r\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode/smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].rearTimeToReachNextNode = dropletDesiredVolume*pumpRatio/smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\r\n              //smallestFrontTimeDroplet[0].rearNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\r\n              smallestFrontTimeDroplet[0].pumpSpeedMultiplier = 1;\r\n              //smallestFrontTimeDroplet[0].pauseLevel = 0;\r\n              smallestFrontTimeDroplet[0].stoppingDroplet = true;\r\n              smallestFrontTimeDroplet[0].initialPumping = true;\r\n              if (reachedNode.connectedPump.id !==selectedCarrierPumps[0]) {\r\n                event={\r\n                  type: 'setPumpSpeed',\r\n                  target: reachedNode.connectedPump.id,\r\n                  time: newTimePassed,\r\n                  value: smallestFrontTimeDroplet[0].frontVolumetricSpeed\r\n                };\r\n                eventList.push(event);\r\n              }\r\n\r\n              //update newer droplets\r\n              dropletsNewer.forEach(droplet => {\r\n                droplet.pauseLevel += 1;\r\n                if (droplet.pauseLevel===1){\r\n                  droplet.frontVolumetricSpeedAtPause = droplet.frontVolumetricSpeed;\r\n                  if (droplet.stoppingDroplet !== true){\r\n                    droplet.rearVolumetricSpeedAtPause = droplet.rearVolumetricSpeed;\r\n                  }\r\n                }\r\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricSpeed = 0;\r\n                droplet.rearVolumetricSpeed = 0;\r\n                droplet.frontTimeToReachNextNode += smallestFrontTimeDroplet[0].rearTimeToReachNextNode-smallestFrontTime;\r\n                droplet.rearTimeToReachNextNode += smallestFrontTimeDroplet[0].rearTimeToReachNextNode-smallestFrontTime;\r\n              });\r\n              getPumpsBetweenPositions(smallestFrontTimeDroplet[0].frontVolumetricPosition,-1, graphData.nodes, graphData.links).filter(pump => pump.id !== reachedNode.connectedPump.id, ).forEach(pump => {\r\n                \r\n                event={\r\n                  type: 'setPumpSpeed',\r\n                  target: pump.id,\r\n                  time: newTimePassed,\r\n                  value: 0\r\n                };\r\n                eventList.push(event);\r\n              });\r\n            }\r\n            \r\n          }\r\n          else if (reachedNode.type === 'thermostat' || reachedNode.type === 'LED') {\r\n            console.log('reachedNode is thermostat');\r\n          }\r\n          else if (reachedNode.type === 'outlet') {\r\n            console.log('reachedNode is outlet');\r\n          }\r\n          else if (reachedNode.type === 'detector' || reachedNode.type === 'USBSpectrometer' || reachedNode.type === 'MQTTSpectrometer') {\r\n            console.log('reachedNode is detector');\r\n          }\r\n        } \r\n        else {\r\n          console.log('Front and rear times are for different droplets');\r\n        }\r\n      } \r\n\r\n      else if (smallestFrontTime < smallestRearTime) { //przypadek gdzie przód jest przed tyłem\r\n        console.log('Front time is smaller than rear time');\r\n        if (smallestFrontTimeDroplet.length > 1) {\r\n          console.log(`Multiple droplets have reached the next node simultaneously`);\r\n          smallestFrontTimeDroplet.forEach(droplet => {\r\n            // Perform some action for each droplet in smallestFrontTimeDroplet\r\n          });\r\n        }\r\n        else { //przypadek gdy przód jednej kropelki dochodzi do noda\r\n          console.log(`Single droplet front has reached the next node`);\r\n          const reachedNode = orderedNodes.find(n => n.node.id === smallestFrontTimeDroplet[0].frontNextNodeID);\r\n          const reachedNodeDistance = orderedNodes.find(node => node.node.id === reachedNode.node.id).distance;\r\n\r\n          if (reachedNode.node.type === 'connector') { //przypadek gdy dochodzi do connectora\r\n            console.log('reachedNode is connector');\r\n\r\n            const index = currentBlockDroplets.indexOf(smallestFrontTimeDroplet[0]);\r\n            const dropletsOlder = currentBlockDroplets.slice(0, index);\r\n            const dropletsNewer = currentBlockDroplets.slice(index + 1);\r\n\r\n            //aktualizuje kroplę\r\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n            const nextEdge = graphData.links.find(link => link.source === reachedNode.node.id && link.target === nextNode.node.id);\r\n\r\n            if (reachedNode.connectedPump.id !== null){\r\n\r\n              const pumpRatio = smallestFrontTimeDroplet[0].parameters.find(param => param.nodeId === reachedNode.connectedPump.id && param.name === 'ratio')?.value || 0;\r\n              const dropletDesiredVolume = smallestFrontTimeDroplet[0].parameters.find(param => param.name === 'volume')?.value || 0;\r\n              smallestFrontTimeDroplet[0].frontVolumetricPosition = reachedNode.node.volumetricPosition;\r\n              smallestFrontTimeDroplet[0].rearVolumetricPosition += smallestFrontTime * smallestFrontTimeDroplet[0].rearVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].actualVolume =smallestFrontTimeDroplet[0].frontVolumetricPosition-smallestFrontTimeDroplet[0].rearVolumetricPosition;\r\n              reachedNode.inletVolumetricSpeed = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              reachedNode.connectedPumpRatio = pumpRatio;\r\n              smallestFrontTimeDroplet[0].rearTimeToReachNextNode -= smallestFrontTime;\r\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n              smallestFrontTimeDroplet[0].rearVolumetricDistanceToNextNode -= smallestFrontTime * smallestFrontTimeDroplet[0].rearVolumetricSpeed; \r\n\r\n              if (smallestFrontTimeDroplet[0].initialPumping === true){ //przypadek gdy kropla jest w pierwszej fazie pompowania (od 0uL)\r\n                console.log('Kropla jest w pierwszej fazie pompowania');\r\n                //smallestFrontTimeDroplet[0].initialPumping = false;\r\n                const rearTimeLeft = smallestFrontTimeDroplet[0].rearTimeToReachNextNode;\r\n                const totalTimeLeft = rearTimeLeft + smallestFrontTimeDroplet[0].actualVolume/commonVolumetricSpeed;\r\n                console.log('commonVolumetricSpeed: ', commonVolumetricSpeed);\r\n                console.log('smallestFrontTimeDroplet[0].actualVolume: ', smallestFrontTimeDroplet[0].actualVolume);\r\n                console.log('rearTimeLeft: ', rearTimeLeft);\r\n                console.log('totalTimeLeft: ', totalTimeLeft);\r\n                const thispumpspeed = pumpRatio*dropletDesiredVolume/totalTimeLeft;\r\n                console.log('thispumpspeed: ', thispumpspeed);\r\n                reachedNode.connectedPumpSpeedAtPause = thispumpspeed;\r\n              }\r\n\r\n              else {\r\n                console.log('Normalne pompowanie');\r\n                reachedNode.connectedPumpSpeedAtPause = (dropletDesiredVolume*pumpRatio) / (smallestFrontTimeDroplet[0].actualVolume / reachedNode.inletVolumetricSpeed);\r\n              }\r\n\r\n              reachedNode.outletVolumetricSpeed = reachedNode.inletVolumetricSpeed+reachedNode.connectedPumpSpeedAtPause;\r\n              smallestFrontTimeDroplet[0].frontVolumetricSpeed += reachedNode.connectedPumpSpeedAtPause;\r\n              //smallestFrontTimeDroplet[0].rearVolumetricSpeed = 0;\r\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode/smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\r\n              //smallestFrontTimeDroplet[0].rearNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\r\n              //smallestFrontTimeDroplet[0].pumpSpeedMultiplier = 1;\r\n              //smallestFrontTimeDroplet[0].pauseLevel = 0;\r\n              //smallestFrontTimeDroplet[0].frontVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              //smallestFrontTimeDroplet[0].rearVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              //smallestFrontTimeDroplet[0].stoppingDroplet = true;\r\n              event={\r\n                type: 'setPumpSpeed',\r\n                target: reachedNode.connectedPump.id,\r\n                time: newTimePassed,\r\n                value: reachedNode.connectedPumpSpeedAtPause \r\n              };\r\n              eventList.push(event);\r\n              //update newer droplets\r\n              dropletsNewer.forEach(droplet => {\r\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontTimeToReachNextNode -= smallestFrontTime;\r\n                droplet.rearTimeToReachNextNode -= smallestFrontTime;\r\n              });\r\n              //aktualizuje starsze krople\r\n              let accumulatedSpeed = reachedNode.connectedPumpSpeedAtPause;\r\n              dropletsOlder.reverse().forEach(droplet => {\r\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.rearVolumetricSpeed += accumulatedSpeed; \r\n                getPumpsBetweenPositions(droplet.frontVolumetricPosition,droplet.rearVolumetricPosition, graphData.nodes, graphData.links).forEach(pump => {\r\n                  const editedNode = orderedNodes.find(node => node.connectedPump.id === pump.id);\r\n                  //editedNode.pumpSpeedMultiplier = 1;\r\n                  const pumpBoost = editedNode.connectedPumpSpeedAtPause * accumulatedSpeed/editedNode.inletVolumetricSpeed;\r\n                  editedNode.connectedPumpSpeedAtPause += pumpBoost;\r\n                  editedNode.inletVolumetricSpeed += accumulatedSpeed;\r\n                  accumulatedSpeed += pumpBoost;\r\n                  editedNode.outletVolumetricSpeed += accumulatedSpeed;\r\n                  event={\r\n                    type: 'setPumpSpeed',\r\n                    target: pump.id,\r\n                    time: newTimePassed,\r\n                    value: editedNode.connectedPumpSpeedAtPause\r\n                  };\r\n                  eventList.push(event);\r\n                });\r\n                droplet.frontVolumetricSpeed += accumulatedSpeed;\r\n                droplet.frontTimeToReachNextNode = droplet.frontVolumetricDistanceToNextNode/droplet.frontVolumetricSpeed;\r\n                droplet.rearTimeToReachNextNode = droplet.rearVolumetricDistanceToNextNode/droplet.rearVolumetricSpeed;\r\n\r\n              });\r\n            }\r\n          }\r\n          else if (reachedNode.node.type === 'thermostat' || reachedNode.type === 'LED') {//przypadek gdy dochodzi do termostatu\r\n            console.log('reachedNode (thermostat, LED): ', reachedNode);\r\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n            if (nextNode) {\r\n              const nextEdge = graphData.links.find(link => link.source === smallestFrontTimeDroplet[0].frontNextNodeID && link.target === nextNode.node.id);\r\n              //aktualizuje krople\r\n              currentBlockDroplets.forEach(droplet => {\r\n                droplet.frontTimeToReachNextNode -= smallestFrontTime;\r\n                droplet.rearTimeToReachNextNode -= smallestFrontTime;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n              });\r\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\r\n            }\r\n          }\r\n          else if (reachedNode.node.type === 'outlet') { //jeśli ostatni node osiągnięty\r\n            console.log('reachedNode (outlet): ', reachedNode);\r\n            //typowe zaktualizowanie czasu do następnego noda dla reszty kropel i zestallowanie frontu\r\n            currentBlockDroplets.forEach(droplet => {\r\n              droplet.frontTimeToReachNextNode -= smallestFrontTime;\r\n              droplet.rearTimeToReachNextNode -= smallestFrontTime;\r\n              droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n              droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n              droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n              droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n            });\r\n            smallestFrontTimeDroplet[0].frontTimeToReachNextNode = Infinity;\r\n            smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = Infinity;\r\n            smallestFrontTimeDroplet[0].frontNextNodeID = null;\r\n          }\r\n          else if (reachedNode.node.type === 'detector' || reachedNode.node.type === 'USBSpectrometer' || reachedNode.node.type === 'MQTTSpectrometer') { //przypadek gdy dochodzi do detektora\r\n            console.log('reachedNode (detector): ', reachedNode);\r\n            \r\n            // Create detector measurement end event when droplet rear reaches detector\r\n            const detectorEndEvent = {\r\n              type: 'setDetectorMeasurement',\r\n              target: reachedNode.node.id,\r\n              time: newTimePassed,\r\n              dropletId: smallestRearTimeDroplet[0].id,\r\n              eventSubtype: 'dropletRearPassed',\r\n              dropletData: {\r\n                volume: smallestRearTimeDroplet[0].parameters.find(p => p.name === 'volume')?.value || 0,\r\n                frontVolumetricPosition: smallestRearTimeDroplet[0].frontVolumetricPosition,\r\n                rearVolumetricPosition: smallestRearTimeDroplet[0].rearVolumetricPosition,\r\n                rearVolumetricSpeed: smallestRearTimeDroplet[0].rearVolumetricSpeed,\r\n                parameters: smallestRearTimeDroplet[0].parameters\r\n              }\r\n            };\r\n            eventList.push(detectorEndEvent);\r\n            \r\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n            if (nextNode) {\r\n              const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\r\n              //aktualizuje krople\r\n              currentBlockDroplets.forEach(droplet => {\r\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n              });\r\n              smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n              smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n              smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\r\n            }\r\n          }\r\n        }\r\n      } \r\n      \r\n      else {//przypadek gdzie tył jest przed przodem\r\n        console.log('Rear time is smaller than front time');\r\n        if (smallestRearTimeDroplet.length > 1) { //przypadek gdy dochodzi do noda wiele kropel\r\n          console.log(`Multiple droplets ends have reached the next node simultaneously`);\r\n          smallestRearTimeDroplet.forEach(droplet => {\r\n            // Perform some action for each droplet in smallestRearTimeDroplet\r\n          });\r\n        } \r\n        else { //przypadek gdy tył jednej kropelki dochodzi do noda\r\n          const reachedNode = orderedNodes.find(n => n.node.id === smallestRearTimeDroplet[0].rearNextNodeID);\r\n          const reachedNodeDistance = orderedNodes.find(node => node.node.id === reachedNode.node.id).distance;\r\n          \r\n          if (reachedNode.node.type === 'connector') { //przypadek gdy dochodzi do connectora\r\n            console.log('reachedNode is connector');\r\n\r\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n            const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\r\n            const index = currentBlockDroplets.indexOf(smallestRearTimeDroplet[0]);\r\n            const dropletsOlder = currentBlockDroplets.slice(0, index);\r\n            const dropletsNewer = currentBlockDroplets.slice(index + 1);\r\n            if (smallestRearTimeDroplet[0].stoppingDroplet === true){ //wznawia jeśli była zatrzymana\r\n              //aktualizuje starsze krople\r\n              dropletsOlder.forEach(droplet => {\r\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n              });\r\n\r\n              //aktualizuje nowsze krople\r\n              dropletsNewer.forEach(droplet => {\r\n                if (droplet.pauseLevel === 1){//\r\n                  droplet.pauseLevel = 0;\r\n                  droplet.frontVolumetricSpeed = droplet.frontVolumetricSpeedAtPause;\r\n                  droplet.rearVolumetricSpeed = droplet.rearVolumetricSpeedAtPause;\r\n                  getPumpsBetweenPositions(droplet.frontVolumetricPosition,droplet.rearVolumetricPosition, graphData.nodes, graphData.links).forEach(pump => {\r\n                    \r\n                    event={\r\n                      type: 'setPumpSpeed',\r\n                      target: pump.id,\r\n                      time: newTimePassed,\r\n                      value: orderedNodes.find(node => node.node.id === pump.id).connectedPumpSpeedAtPause\r\n                    };\r\n                    eventList.push(event);\r\n                  });\r\n                }\r\n                else {\r\n                  droplet.pauseLevel -= 1;\r\n                }\r\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n              });\r\n\r\n              reachedNode.connectedPumpRatio = 0; \r\n              //reachedNode.inletVolumetricSpeed = 0;\r\n              //smallestRearTimeDroplet[0].frontVolumetricSpeed = reachedNode.outletVolumetricSpeed;\r\n              smallestRearTimeDroplet[0].rearVolumetricSpeed = smallestRearTimeDroplet[0].rearVolumetricSpeedAtPause;\r\n              smallestRearTimeDroplet[0].frontVolumetricPosition += smallestRearTimeDroplet[0].frontVolumetricSpeed*smallestRearTime;\r\n              smallestRearTimeDroplet[0].rearVolumetricPosition = reachedNode.node.volumetricPosition;\r\n              smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode -= smallestRearTimeDroplet[0].frontVolumetricSpeed*smallestRearTime;\r\n              smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge); \r\n              smallestRearTimeDroplet[0].frontTimeToReachNextNode = smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode/smallestRearTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode/smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n              //smallestRearTimeDroplet[0].frontNextNodeID = nextNode.id;\r\n              smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\r\n              //smallestRearTimeDroplet[0].pumpSpeedMultiplier = 1;\r\n              //smallestRearTimeDroplet[0].pauseLevel = 0;\r\n              smallestRearTimeDroplet[0].frontVolumetricSpeedAtPause = smallestRearTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestRearTimeDroplet[0].rearVolumetricSpeedAtPause = smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n              smallestRearTimeDroplet[0].stoppingDroplet = false;\r\n              smallestRearTimeDroplet[0].initialPumping = false;\r\n\r\n              reachedNode.connectedPumpRatio = 0;\r\n              event = {\r\n                type: 'setPumpSpeed',\r\n                target: reachedNode.connectedPump.id,\r\n                time: newTimePassed,\r\n                value: 0\r\n              };\r\n              eventList.push(event);\r\n              event = {\r\n                type: 'setPumpSpeed',\r\n                target: selectedCarrierPumps[0],\r\n                time: newTimePassed,\r\n                value: commonVolumetricSpeed\r\n              };\r\n              eventList.push(event);\r\n\r\n            }\r\n            else {\r\n              console.log('it is not stopper');\r\n              if (reachedNode.connectedPump.id !== null){\r\n                \r\n                const speedDifference = reachedNode.outletVolumetricSpeed - reachedNode.inletVolumetricSpeed;\r\n                //reachedNode.inletVolumetricSpeed = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n                reachedNode.outletVolumetricSpeed = reachedNode.inletVolumetricSpeed;\r\n                reachedNode.connectedPumpRatio = 0;\r\n                reachedNode.connectedPumpSpeedAtPause = 0;\r\n                smallestRearTimeDroplet[0].frontVolumetricPosition += smallestRearTime * smallestRearTimeDroplet[0].frontVolumetricSpeed;\r\n                smallestRearTimeDroplet[0].rearVolumetricPosition = reachedNode.node.volumetricPosition;\r\n                smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode -= smallestRearTime * smallestRearTimeDroplet[0].frontVolumetricSpeed;\r\n                smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge); \r\n                //smallestRearTimeDroplet[0].frontNextNodeID = nextNode.id;\r\n                smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\r\n                //smallestRearTimeDroplet[0].pumpSpeedMultiplier = 1;\r\n                //smallestRearTimeDroplet[0].pauseLevel = 0; \r\n                //smallestRearTimeDroplet[0].stoppingDroplet = true;\r\n                smallestRearTimeDroplet[0].frontVolumetricSpeed = smallestRearTimeDroplet[0].frontVolumetricSpeed-speedDifference;\r\n                //smallestRearTimeDroplet[0].rearVolumetricSpeed = 0;\r\n                smallestRearTimeDroplet[0].frontVolumetricSpeedAtPause = smallestRearTimeDroplet[0].frontVolumetricSpeed;\r\n                //smallestRearTimeDroplet[0].rearVolumetricSpeedAtPause = smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n                smallestRearTimeDroplet[0].frontTimeToReachNextNode = smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].frontVolumetricSpeed;\r\n                smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n                event={\r\n                  type: 'setPumpSpeed',\r\n                  target: reachedNode.connectedPump.id,\r\n                  time: newTimePassed,\r\n                  value: reachedNode.connectedPumpSpeedAtPause \r\n                };\r\n                eventList.push(event);\r\n                //updte newer droplets\r\n                dropletsNewer.forEach(droplet => {\r\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                  droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n                  droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n                });\r\n                //aktualizuje starsze krople\r\n                let accumulatedSpeedDecrease = speedDifference;\r\n                dropletsOlder.reverse().forEach(droplet => {\r\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                  droplet.rearVolumetricSpeed -= accumulatedSpeedDecrease;\r\n                  getPumpsBetweenPositions(droplet.frontVolumetricPosition,droplet.rearVolumetricPosition, graphData.nodes, graphData.links).forEach(pump => {\r\n                    const editedNode = orderedNodes.find(node => node.connectedPump.id === pump.id);\r\n                    const pumpBreak = editedNode.connectedPumpSpeedAtPause * accumulatedSpeedDecrease/editedNode.inletVolumetricSpeed;\r\n                    editedNode.connectedPumpSpeedAtPause -= pumpBreak;\r\n                    editedNode.inletVolumetricSpeed -= accumulatedSpeedDecrease;\r\n                    accumulatedSpeedDecrease += pumpBreak;\r\n                    editedNode.outletVolumetricSpeed -= accumulatedSpeedDecrease;\r\n                    event={\r\n                      type: 'setPumpSpeed',\r\n                      target: pump.id,\r\n                      time: newTimePassed,\r\n                      value: editedNode.connectedPumpSpeedAtPause\r\n                    };\r\n                    eventList.push(event);\r\n                  });\r\n                  droplet.frontVolumetricSpeed -= accumulatedSpeedDecrease;\r\n                  droplet.frontTimeToReachNextNode = droplet.frontVolumetricDistanceToNextNode/droplet.frontVolumetricSpeed;\r\n                  droplet.rearTimeToReachNextNode = droplet.rearVolumetricDistanceToNextNode/droplet.rearVolumetricSpeed;\r\n  \r\n                });\r\n              }\r\n            }\r\n\r\n          }\r\n          else if (reachedNode.node.type === 'thermostat' || reachedNode.node.type === 'LED') {//przypadek gdy dochodzi do termostatu\r\n            console.log('reachedNode thermostat: ', reachedNode);\r\n            \r\n            const isFarthestThermostatOrLED = orderedNodes.filter(node => node.node.type === 'thermostat' || node.node.type === 'LED').every(node => node.distance <= reachedNodeDistance);\r\n            \r\n            // This line checks if the smallestRearTimeDroplet is the last droplet in the currentBlockDroplets array.\r\n            if (isFarthestThermostatOrLED && currentBlockDroplets.length === currentBlockDroplets.indexOf(smallestRearTimeDroplet[0])+1) {\r\n              console.log('This is the farthest thermostat or LED node. Also, last droplet just passed through it.');\r\n              const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n              const waitTime = smallestRearTimeDroplet[0].parameters.find(param => param.nodeId === reachedNode.node.id && param.name === 'time')?.value || 0;\r\n              if (nextNode) {\r\n                const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\r\n                smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n                smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode/smallestRearTimeDroplet[0].rearVolumetricSpeed + smallestRearTime;\r\n                smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\r\n                //aktualizuje resztę kropli\r\n                currentBlockDroplets.forEach(droplet => {\r\n                  droplet.frontTimeToReachNextNode += waitTime - smallestRearTime;\r\n                  droplet.rearTimeToReachNextNode += waitTime - smallestRearTime;\r\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed-waitTime * droplet.frontVolumetricSpeed;//to jest zrobione na razie aby czas się zgadzał\r\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed-waitTime * droplet.rearVolumetricSpeed;\r\n                });\r\n\r\n                let carrierPumpEvent = {\r\n                  type: 'setPumpSpeed',\r\n                  target: selectedCarrierPumps[0], // Assuming 'carrierPumpId' is the ID of the carrier pump\r\n                  time: newTimePassed,\r\n                  value: 0\r\n                };\r\n                eventList.push(carrierPumpEvent);\r\n                carrierPumpEvent = {\r\n                  type: 'setPumpSpeed',\r\n                  target: selectedCarrierPumps[0], // Assuming 'carrierPumpId' is the ID of the carrier pump\r\n                  time: newTimePassed+waitTime,\r\n                  value: commonVolumetricSpeed\r\n                };\r\n                eventList.push(carrierPumpEvent);\r\n              }\r\n            }\r\n            else { //droplet wasnt the last one\r\n              console.log('smallestRearTimeDroplet is not the last droplet in the currentBlockDroplets array');\r\n              const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n              if (nextNode) {\r\n                const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\r\n                //aktualizuje krople\r\n                currentBlockDroplets.forEach(droplet => {\r\n                  droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n                  droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n                });\r\n                smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n                smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n                smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\r\n              }\r\n            }\r\n          }\r\n          else if (reachedNode.node.type === 'outlet') { //jeśli ostatni node osiągnięty\r\n            //typowe zaktualizowanie czasu do następnego noda dla reszty kropel i zestallowanie reara\r\n            //aktualizuje resztę kropli\r\n            currentBlockDroplets.forEach(droplet => {\r\n              droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n              droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n              droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n              droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n              droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n              droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n            });\r\n            smallestRearTimeDroplet[0].frontTimeToReachNextNode = Infinity;\r\n            smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode = Infinity;\r\n            smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = Infinity;\r\n            smallestRearTimeDroplet[0].rearNextNodeID = null;\r\n            smallestRearTimeDroplet[0].rearTimeToReachNextNode = Infinity;\r\n          }\r\n          else if (reachedNode.node.type === 'detector' || reachedNode.node.type === 'USBSpectrometer' || reachedNode.node.type === 'MQTTSpectrometer') { //przypadek gdy dochodzi do detektora\r\n            console.log('reachedNode (detector): ', reachedNode);\r\n            \r\n            // Create detector measurement end event when droplet rear reaches detector\r\n            const detectorEndEvent = {\r\n              type: 'setDetectorMeasurement',\r\n              target: reachedNode.node.id,\r\n              time: newTimePassed,\r\n              dropletId: smallestRearTimeDroplet[0].id,\r\n              eventSubtype: 'dropletRearPassed',\r\n              dropletData: {\r\n                volume: smallestRearTimeDroplet[0].parameters.find(p => p.name === 'volume')?.value || 0,\r\n                frontVolumetricPosition: smallestRearTimeDroplet[0].frontVolumetricPosition,\r\n                rearVolumetricPosition: smallestRearTimeDroplet[0].rearVolumetricPosition,\r\n                rearVolumetricSpeed: smallestRearTimeDroplet[0].rearVolumetricSpeed,\r\n                parameters: smallestRearTimeDroplet[0].parameters\r\n              }\r\n            };\r\n            eventList.push(detectorEndEvent);\r\n            \r\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n            if (nextNode) {\r\n              const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\r\n              //aktualizuje krople\r\n              currentBlockDroplets.forEach(droplet => {\r\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n              });\r\n              smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n              smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n              smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      timePassed = newTimePassed;\r\n      // Update last droplet rear position\r\n      lastDropletRearPosition = currentBlockDroplets[currentBlockDroplets.length - 1].rearVolumetricPosition;\r\n\r\n      //add code that preserves droplets positions and speeds for visualization\r\n      const dropletState = {\r\n        time: timePassed,\r\n        droplets: currentBlockDroplets.map(droplet => ({\r\n          id: droplet.id,\r\n          frontVolumetricPosition: droplet.frontVolumetricPosition,\r\n          rearVolumetricPosition: droplet.rearVolumetricPosition,\r\n          frontVolumetricSpeed: droplet.frontVolumetricSpeed,\r\n          rearVolumetricSpeed: droplet.rearVolumetricSpeed,\r\n          pumpSpeedMultiplier: droplet.pumpSpeedMultiplier,\r\n          frontTimeToReachNextNode: droplet.frontTimeToReachNextNode,\r\n          rearTimeToReachNextNode: droplet.rearTimeToReachNextNode,\r\n          frontVolumetricDistanceToNextNode: droplet.frontVolumetricDistanceToNextNode,\r\n          rearVolumetricDistanceToNextNode: droplet.rearVolumetricDistanceToNextNode,\r\n          volume: droplet.parameters.find(p => p.name === 'volume')?.value || 0,\r\n          frontNextNodeID: droplet.frontNextNodeID,\r\n          rearNextNodeID: droplet.rearNextNodeID\r\n        }))\r\n      };\r\n      setDropletHistory(prev => [...prev, dropletState]);\r\n\r\n      \r\n\r\n      //if (timePassed > 9999) {//here for testing, preventing infinite loop\r\n      //  lastDropletRearPosition = 88100;\r\n      //}\r\n\r\n    }\r\n    event = {//it is ok\r\n      type: 'setPumpSpeed',\r\n      target: selectedCarrierPumps[0],\r\n      time: timePassed,\r\n      value: 0\r\n    };\r\n    eventList.push(event);\r\n\r\n    eventList = cleanAndSortEventList(eventList);\r\n    console.log('dropletHistory in event generator: ', dropletHistory);\r\n    console.log('eventList: ', eventList.sort((a, b) => a.time - b.time));\r\n    setPumpEvents(extractPumpEvents(eventList));\r\n    setDetectorEvents(extractDetectorEvents(eventList));\r\n    console.log('Detector events:', extractDetectorEvents(eventList));\r\n    return eventList;\r\n  }\r\n  // First useEffect to set initial graphData\r\n  useEffect(() => {\r\n    setDropletHistory([]);\r\n    if (nodes.length > 0 && edges.length > 0) {\r\n      const graphNodes = nodes.map(node => ({\r\n        id: node.id,\r\n        label: node.data.label,\r\n        type: node.data.type,\r\n        x: 0,\r\n        y: 0,\r\n        volumetricPosition: 0\r\n      }));\r\n\r\n      const graphLinks = edges.map(edge => ({\r\n        source: edge.source,\r\n        target: edge.target,\r\n        length: edge.data?.properties?.length || 100,\r\n        diameter: edge.data?.properties?.diameter || 1,\r\n      }));\r\n\r\n      setGraphData({ nodes: graphNodes, links: graphLinks });\r\n    }\r\n    \r\n  }, [nodes, edges]);\r\n\r\n  // Second useEffect to calculate nodes positions and set up simulation data\r\n  useEffect(() => {\r\n    if (!graphData.nodes.length || !graphData.links.length || !droplets.length) {\r\n      console.log('Missing required data for simulation setup:', {\r\n        nodesLength: graphData.nodes.length,\r\n        linksLength: graphData.links.length,\r\n        dropletsLength: droplets.length\r\n      });\r\n      return;\r\n    }\r\n\r\n    const graphNodes = [...graphData.nodes];\r\n    \r\n    // Find outlet node first\r\n    const outletNode = findOutletNode(graphData.nodes);\r\n    if (!outletNode) {\r\n      console.error('No outlet node found. Cannot set up simulation.');\r\n      return;\r\n    }\r\n\r\n    // Get ordered nodes from outlet\r\n    const orderedNodes = orderNodesByDistance(outletNode, graphData.nodes, graphData.links);\r\n    \r\n    // Separate nodes into main line and secondary line\r\n    const mainLineNodes = orderedNodes\r\n      .filter(({node}) => \r\n        setOfMainLineNodes.includes(node.type))\r\n      .reverse();\r\n      \r\n    const secondaryLineNodes = orderedNodes\r\n      .filter(({node}) => setOfSecondaryLineNodes.includes(node.type))\r\n      .sort((a, b) => b.distance - a.distance);\r\n\r\n    // Position settings\r\n    const mainLineY = 300;\r\n    const secondaryLineY = 150;\r\n    const pumpSpacing = 100; // Increased horizontal spacing between pumps\r\n    let currentX = 100;\r\n\r\n    // Position main line nodes\r\n    let currentVolumetricPosition = 0;\r\n    mainLineNodes.forEach(({node}, index) => {\r\n      const graphNode = graphNodes.find(n => n.id === node.id);\r\n      if (!graphNode) return;\r\n\r\n      graphNode.x = currentX;\r\n      graphNode.y = mainLineY;\r\n      graphNode.volumetricPosition = currentVolumetricPosition;\r\n      \r\n      if (index < mainLineNodes.length - 1) {\r\n        const nextNode = mainLineNodes[index + 1];\r\n        const edge = graphData.links.find(e => \r\n          (e.source === graphNode.id && e.target === nextNode.node.id) ||\r\n          (e.target === graphNode.id && e.source === nextNode.node.id)\r\n        );\r\n        \r\n        if (edge && edge.length) {\r\n          currentX += edge.length * 2;\r\n          // Use existing calculateEdgeVolume function\r\n          const edgeVolume = calculateEdgeVolume(edge);\r\n          currentVolumetricPosition += edgeVolume;\r\n        } else {\r\n          currentX += 200;\r\n          currentVolumetricPosition += 150;\r\n        }\r\n      }\r\n    });\r\n\r\n    // Group secondary nodes by distance\r\n    const nodesByDistance = {};\r\n    secondaryLineNodes.forEach(({node, distance}) => {\r\n      if (!nodesByDistance[distance]) {\r\n        nodesByDistance[distance] = [];\r\n      }\r\n      nodesByDistance[distance].push(node);\r\n    });\r\n\r\n    // Position secondary nodes based on their connected main line nodes\r\n    const pumpOffset = 50; // Add this constant for pump spacing\r\n    Object.entries(nodesByDistance).forEach(([distance, nodes]) => {\r\n      nodes.forEach((node, index) => {\r\n        const graphNode = graphNodes.find(n => n.id === node.id);\r\n        if (!graphNode) return;\r\n\r\n        // Find connected main line node through edges\r\n        const connectedEdge = edges.find(e => \r\n          e.source === node.id || e.target === node.id\r\n        );\r\n        \r\n        if (connectedEdge) {\r\n          const connectedNodeId = connectedEdge.source === node.id ? connectedEdge.target : connectedEdge.source;\r\n          const connectedMainNode = graphNodes.find(n => n.id === connectedNodeId);\r\n          \r\n          if (connectedMainNode) {\r\n            // Position pump above its connected main line node with offset if needed\r\n            graphNode.x = connectedMainNode.x + (index * pumpOffset) - ((nodes.length - 1) * pumpOffset / 2);\r\n            graphNode.y = secondaryLineY;\r\n          }\r\n        }\r\n      });\r\n    });\r\n\r\n    setGraphData(prev => ({ ...prev, nodes: graphNodes }));\r\n    \r\n    // Only calculate volumes and blocks if not already done\r\n    if (currentBlockDroplets.length === 0) {\r\n      console.log('Calculating thermostat volumes and blocks for droplets:', droplets.length);\r\n      const thermoVol = calculateVolumesBetweenThermostats(graphData);\r\n      \r\n      // Create deep copy of droplets to avoid mutation issues\r\n      const dropletsCopy = JSON.parse(JSON.stringify(droplets));\r\n      const blocks = divideDropletsIntoBlocks(dropletsCopy, thermoVol);\r\n      \r\n      if (blocks.length > 0) {\r\n        setCurrentBlockDroplets(blocks[0].droplets);\r\n        // Generate event list only once when initializing\r\n        const eventList = generateEventList(blocks);\r\n        const eventListForDevices = recalculateEventListForDevices(eventList);\r\n      }\r\n    }\r\n    \r\n    // Important: the dependency array includes currentBlockDroplets.length to prevent infinite recalculations\r\n  }, [graphData.nodes.length, graphData.links.length, droplets, edges, currentBlockDroplets.length]);\r\n\r\n  const startSimulation = useCallback(() => {\r\n    setIsSimulationRunning(true);\r\n    lastFrameTimeRef.current = null; // Reset the last frame time\r\n  }, []);\r\n\r\n  const stopSimulation = useCallback(() => {\r\n    setIsSimulationRunning(false);\r\n    if (animationFrameRef.current) {\r\n      cancelAnimationFrame(animationFrameRef.current);\r\n      animationFrameRef.current = null;\r\n    }\r\n  }, []);\r\n\r\n  const restartSimulation = useCallback(() => {\r\n    stopSimulation();\r\n    setKey(prevKey => prevKey + 1);\r\n    setCurrentTime(0);\r\n    startSimulation();\r\n  }, [stopSimulation, startSimulation]);\r\n\r\n\r\n  const getNodeColor = (node) => {\r\n    switch (node.type) {\r\n      case 'pump': return '#4CAF50';\r\n      case 'connector': return '#2196F3';\r\n      case 'outlet': return '#F44336';\r\n      default: return '#FFA000'; // Default color for unknown types\r\n    }\r\n  };\r\n\r\n  // Update volumetricToXPosition function\r\n  const volumetricToXPosition = useCallback((volumetricPosition) => {\r\n    const outletNode = findOutletNode(graphData.nodes);\r\n    const furthestNode = findFurthestNode(outletNode, graphData.nodes, graphData.links);\r\n    \r\n    if (!outletNode || !furthestNode) return 0;\r\n\r\n    const totalVolume = getVolumeBetweenNodes(furthestNode.id, outletNode.id, graphData.nodes, graphData.links);\r\n    const outletX = graphData.nodes.find(n => n.id === outletNode.id)?.x || 0;\r\n    const furthestX = graphData.nodes.find(n => n.id === furthestNode.id)?.x || 0;\r\n    \r\n    // Handle edge cases\r\n    if (!totalVolume || totalVolume === 0 || isNaN(totalVolume)) {\r\n      console.warn('Total volume is invalid:', totalVolume);\r\n      return furthestX;\r\n    }\r\n\r\n    if (volumetricPosition === undefined || volumetricPosition === null || isNaN(volumetricPosition)) {\r\n      console.warn('Volumetric position is invalid:', volumetricPosition);\r\n      return furthestX;\r\n    }\r\n\r\n    // Clamp the position to valid range\r\n    const clampedPosition = Math.max(-totalVolume, Math.min(totalVolume, volumetricPosition));\r\n    \r\n    // Apply scaling factor to the position calculation\r\n    const scaledX = furthestX + ((clampedPosition / totalVolume) * (outletX - furthestX));\r\n    \r\n    // Ensure the returned value is a valid number\r\n    if (!isFinite(scaledX) || isNaN(scaledX)) {\r\n      console.warn('Invalid scaled position calculated:', {\r\n        scaledX,\r\n        clampedPosition,\r\n        totalVolume,\r\n        outletX,\r\n        furthestX\r\n      });\r\n      return furthestX;\r\n    }\r\n    \r\n    return scaledX;\r\n  }, [graphData.nodes]);    \r\n\r\n  // Update the updateDropletPositions function\r\n  const updateDropletPositions = useCallback((timestamp) => {\r\n    if (!isSimulationRunning || dropletHistory.length === 0) return;\r\n\r\n    if (!lastFrameTimeRef.current) {\r\n      lastFrameTimeRef.current = timestamp;\r\n      animationFrameRef.current = requestAnimationFrame(updateDropletPositions);\r\n      return;\r\n    }\r\n\r\n    const deltaTime = (timestamp - lastFrameTimeRef.current) / 1000; // Convert to seconds\r\n    const simulationDeltaTime = deltaTime * timeScale;\r\n    \r\n    setCurrentTime(prevTime => {\r\n      const newTime = prevTime + simulationDeltaTime;\r\n      \r\n      // Get the time range of our history\r\n      const lastHistoryTime = dropletHistory[dropletHistory.length - 1].time;\r\n      \r\n      // If we've reached the end, loop back to start\r\n      if (newTime >= lastHistoryTime) {\r\n        setCurrentTime(0);\r\n        return 0;\r\n      }\r\n\r\n      // Find the appropriate states to interpolate between\r\n      const currentState = interpolateDropletState(newTime);\r\n      // Update droplet visualization\r\n      const updatedDroplets = currentState.map(droplet => {\r\n        const frontX = volumetricToXPosition(droplet.frontVolumetricPosition);\r\n        const rearX = volumetricToXPosition(droplet.rearVolumetricPosition);\r\n\r\n        if (isNaN(frontX) || isNaN(rearX)) {\r\n          console.warn('Invalid droplet position calculated:', {\r\n            dropletId: droplet.id,\r\n            frontPosition: droplet.frontVolumetricPosition,\r\n            rearPosition: droplet.rearVolumetricPosition,\r\n            frontX,\r\n            rearX\r\n          });\r\n          return null;\r\n        }\r\n\r\n        return {\r\n          id: droplet.id,\r\n          frontX,\r\n          rearX,\r\n          y: 300,\r\n          volume: droplet.frontVolumetricPosition-droplet.rearVolumetricPosition,\r\n          speed: droplet.frontVolumetricSpeed\r\n        };\r\n      }).filter(Boolean);\r\n\r\n      setSimulationDroplets(updatedDroplets);\r\n      return newTime;\r\n    });\r\n\r\n    lastFrameTimeRef.current = timestamp;\r\n    animationFrameRef.current = requestAnimationFrame(updateDropletPositions);\r\n  }, [isSimulationRunning, timeScale, volumetricToXPosition, dropletHistory]);\r\n\r\n  // Add animation effect\r\n  useEffect(() => {\r\n    if (isSimulationRunning) {\r\n      lastFrameTimeRef.current = null;\r\n      animationFrameRef.current = requestAnimationFrame(updateDropletPositions);\r\n    }\r\n    return () => {\r\n      if (animationFrameRef.current) {\r\n        cancelAnimationFrame(animationFrameRef.current);\r\n      }\r\n    };\r\n  }, [isSimulationRunning, updateDropletPositions]);\r\n\r\n  // Add this helper function for interpolation\r\n  const interpolateDropletState = (time) => {\r\n    if (!dropletHistory.length) return [];\r\n    \r\n    // Find the two closest states\r\n    const index = dropletHistory.findIndex(state => state.time > time);\r\n    if (index === -1) return dropletHistory[dropletHistory.length - 1].droplets;\r\n    if (index === 0) return dropletHistory[0].droplets;\r\n    \r\n    const beforeState = dropletHistory[index - 1];\r\n    const afterState = dropletHistory[index];\r\n    const fraction = (time - beforeState.time) / (afterState.time - beforeState.time);\r\n    \r\n    return beforeState.droplets.map(beforeDroplet => {\r\n      const afterDroplet = afterState.droplets.find(d => d.id === beforeDroplet.id);\r\n      if (!afterDroplet) return beforeDroplet;\r\n      \r\n      return {\r\n        ...beforeDroplet,\r\n        frontVolumetricPosition: beforeDroplet.frontVolumetricPosition + \r\n          (afterDroplet.frontVolumetricPosition - beforeDroplet.frontVolumetricPosition) * fraction,\r\n        rearVolumetricPosition: beforeDroplet.rearVolumetricPosition + \r\n          (afterDroplet.rearVolumetricPosition - beforeDroplet.rearVolumetricPosition) * fraction,\r\n      };\r\n    });\r\n  };\r\n\r\n  // Add navigation functions\r\n  const jumpToTimepoint = useCallback((index) => {\r\n    if (index >= 0 && index < dropletHistory.length) {\r\n      setCurrentTimepoint(index);\r\n      setCurrentTime(dropletHistory[index].time);\r\n    }\r\n  }, [dropletHistory]);\r\n\r\n  const nextTimepoint = useCallback(() => {\r\n    jumpToTimepoint(currentTimepoint + 1);\r\n  }, [currentTimepoint, jumpToTimepoint]);\r\n\r\n  const previousTimepoint = useCallback(() => {\r\n    jumpToTimepoint(currentTimepoint - 1);\r\n  }, [currentTimepoint, jumpToTimepoint]);\r\n\r\n\r\n\r\n  const handleNodeClick = (node) => {\r\n    console.log('Node clicked:', node);\r\n    console.log('Node type:', node.type);\r\n    console.log('Node data type:', node.data?.type);\r\n    \r\n    // Check both node.type and node.data.type\r\n    const nodeType = node.type || node.data?.type;\r\n    console.log('Determined node type:', nodeType);\r\n    \r\n    if (nodeType === 'pump' || nodeType === 'USBSpectrometer' || nodeType === 'MQTTSpectrometer') {\r\n      setSelectedNode(node);\r\n      console.log('Selected node set:', node.id, nodeType);\r\n    }\r\n    if (node.type === 'detector' || node.type === 'USBSpectrometer' || node.type === 'MQTTSpectrometer') {\r\n      // Store the graph ref when opening a spectrometer\r\n      const graphRef = React.createRef();\r\n      graphRefs.current[node.id] = graphRef;\r\n      \r\n      // ... rest of the existing handleNodeClick code ...\r\n    }\r\n  };\r\n\r\n  const handleNodeAction = (action) => {\r\n    console.log('Node action:', action);\r\n    // Here you would implement the actual device communication\r\n    // based on the action type and parameters\r\n  };\r\n\r\n  const togglePumpSpeeds = () => {\r\n    setDisplayPumpSpeeds(!displayPumpSpeeds);\r\n  };\r\n\r\n  // Toggle functions for each display option\r\n  const toggleNodeIds = () => {\r\n    setDisplayNodeIds(!displayNodeIds);\r\n  };\r\n  \r\n  const toggleDropletInfo = () => {\r\n    setDisplayDropletInfo(!displayDropletInfo);\r\n  };\r\n  \r\n  const toggleDropletGaps = () => {\r\n    setDisplayDropletGaps(!displayDropletGaps);\r\n  };\r\n  \r\n  const toggleEdgeLabels = () => {\r\n    setDisplayEdgeLabels(!displayEdgeLabels);\r\n  };\r\n  \r\n  const toggleDisplayMenu = () => {\r\n    setDisplayMenuOpen(!isDisplayMenuOpen);\r\n  };\r\n  \r\n  const toggleTimelineDropletInfo = () => {\r\n    setDisplayTimelineDropletInfo(!displayTimelineDropletInfo);\r\n  };\r\n  \r\n  const toggleDetectorEvents = () => {\r\n    setDisplayDetectorEvents(!displayDetectorEvents);\r\n  };\r\n  \r\n  // Close menu when clicking outside\r\n  useEffect(() => {\r\n    const handleClickOutside = (event) => {\r\n      if (displayMenuRef.current && !displayMenuRef.current.contains(event.target)) {\r\n        setDisplayMenuOpen(false);\r\n      }\r\n    };\r\n    \r\n    document.addEventListener('mousedown', handleClickOutside);\r\n    return () => {\r\n      document.removeEventListener('mousedown', handleClickOutside);\r\n    };\r\n  }, []);\r\n\r\n  // Function to toggle pump panel visibility\r\n  const togglePumpPanel = (pumpId) => {\r\n    setVisiblePumpPanel((prev) => (prev === pumpId ? null : pumpId));\r\n  };\r\n\r\n  // Add styles for the display menu\r\n  const styles = {\r\n    container: {\r\n      ...backgroundVariants.mainBackground,\r\n      padding: '20px',\r\n      minHeight: '100vh'\r\n    },\r\n    dropletInfo: {\r\n      padding: '8px',\r\n      borderRadius: '4px',\r\n      fontSize: '12px',\r\n      ...backgroundVariants.panelBackground,\r\n      color: '#fff',\r\n      minWidth: '150px'\r\n    },\r\n    timelineContainer: {\r\n      display: 'flex',\r\n      flexDirection: 'column',\r\n      gap: '10px',\r\n      marginBottom: '20px'\r\n    },\r\n    timeInput: {\r\n      width: '100px',\r\n      ...backgroundVariants.inputBackground,\r\n      padding: '5px',\r\n      borderRadius: '4px',\r\n      marginLeft: '8px'\r\n    },\r\n    buttonGroup: {\r\n      display: 'flex',\r\n      gap: '10px',\r\n      marginTop: '20px',\r\n      marginBottom: '20px'\r\n    },\r\n    timelineControls: {\r\n      display: 'flex',\r\n      flexDirection: 'column',\r\n      gap: '15px',\r\n      marginBottom: '20px',\r\n      ...backgroundVariants.panelBackground,\r\n      padding: '15px',\r\n      borderRadius: '4px'\r\n    },\r\n    timeControls: {\r\n      display: 'flex',\r\n      flexDirection: 'column',\r\n      gap: '15px'\r\n    },\r\n    sliderContainer: {\r\n      display: 'flex',\r\n      gap: '10px',\r\n      alignItems: 'center',\r\n      borderBottom: '1px solid rgba(255,255,255,0.1)',\r\n      paddingBottom: '15px'\r\n    },\r\n    timeStepButtons: {\r\n      display: 'flex',\r\n      gap: '5px',\r\n      alignItems: 'center',\r\n      justifyContent: 'flex-start'\r\n    },\r\n    timeScaleContainer: {\r\n      display: 'flex',\r\n      alignItems: 'center',\r\n      gap: '15px',\r\n      justifyContent: 'flex-start',\r\n      borderTop: '1px solid rgba(255,255,255,0.1)',\r\n      paddingTop: '15px'\r\n    },\r\n    svgContainer: {\r\n      background: backgroundVariants.panelBackground.background,\r\n      borderRadius: '4px',\r\n      padding: '10px'\r\n    },\r\n    navigationButtons: {\r\n      display: 'flex',\r\n      justifyContent: 'space-between',\r\n      marginBottom: '20px'\r\n    },\r\n    timeSlider: {\r\n      width: '33%',\r\n      ...backgroundVariants.inputBackground,\r\n      height: '20px',\r\n      borderRadius: '10px',\r\n      WebkitAppearance: 'none',\r\n      appearance: 'none',\r\n      background: backgroundVariants.inputBackground.background,\r\n      outline: 'none',\r\n      opacity: '0.7',\r\n      transition: 'opacity .2s',\r\n      '&:hover': {\r\n        opacity: '1'\r\n      },\r\n      '&::-webkit-slider-thumb': {\r\n        WebkitAppearance: 'none',\r\n        appearance: 'none',\r\n        width: '20px',\r\n        height: '20px',\r\n        background: '#4CAF50',\r\n        cursor: 'pointer',\r\n        borderRadius: '50%'\r\n      },\r\n      '&::-moz-range-thumb': {\r\n        width: '20px',\r\n        height: '20px',\r\n        background: '#4CAF50',\r\n        cursor: 'pointer',\r\n        borderRadius: '50%'\r\n      }\r\n    },\r\n    // Add styles for display menu\r\n    displayMenuButton: {\r\n      ...buttonVariants.infoButton,\r\n      position: 'relative'\r\n    },\r\n    displayMenu: {\r\n      position: 'absolute',\r\n      top: '100%',\r\n      right: 0,\r\n      backgroundColor: '#333',\r\n      border: '1px solid #555',\r\n      borderRadius: '4px',\r\n      padding: '8px 0',\r\n      zIndex: 1000,\r\n      width: '220px',\r\n      boxShadow: '0 2px 10px rgba(0, 0, 0, 0.3)'\r\n    },\r\n    menuItem: {\r\n      padding: '8px 16px',\r\n      cursor: 'pointer',\r\n      display: 'flex',\r\n      alignItems: 'center',\r\n      justifyContent: 'space-between',\r\n      color: 'white',\r\n      transition: 'background-color 0.2s',\r\n      '&:hover': {\r\n        backgroundColor: '#444'\r\n      }\r\n    },\r\n    checkmark: {\r\n      color: '#4CAF50',\r\n      fontWeight: 'bold'\r\n    }\r\n  };\r\n\r\n  const sliderStyle = {\r\n    width: '100%',\r\n    height: '10px',\r\n    borderRadius: '5px', \r\n    background: '#333',\r\n    outline: 'none',\r\n    opacity: '0.7',\r\n    transition: 'opacity .2s'\r\n    // Remove all pseudo-element styles that were here\r\n  };\r\n\r\n  return (\r\n    <div style={styles.container}>\r\n      <div style={styles.timelineControls}>\r\n        <div style={styles.timeControls}>\r\n          <div style={styles.sliderContainer}>\r\n            <input\r\n              type=\"range\"\r\n              min={0}\r\n              max={Math.max(0, dropletHistory.length - 1)}\r\n              value={currentTimepoint}\r\n              onChange={(e) => jumpToTimepoint(Number(e.target.value))}\r\n              disabled={isSimulationRunning}\r\n              style={styles.timeSlider}\r\n              className=\"time-slider\" // Add this className\r\n            />\r\n            {displayTimelineDropletInfo && (\r\n              <div style={{ display: 'flex', gap: '10px', flexWrap: 'wrap' }}>\r\n                {dropletHistory.length > 0 && dropletHistory[currentTimepoint]?.droplets.map((droplet, index) => (\r\n                  <div key={droplet.id} style={styles.dropletInfo}>\r\n                    <div>Droplet {index + 1}:</div>\r\n                    {droplet.frontNextNodeID && (\r\n                      <div>Front → {graphData.nodes.find(n => n.id === droplet.frontNextNodeID)?.label || droplet.frontNextNodeID}</div>\r\n                    )}\r\n                    {droplet.rearNextNodeID && (\r\n                      <div>Rear → {graphData.nodes.find(n => n.id === droplet.rearNextNodeID)?.label || droplet.rearNextNodeID}</div>\r\n                    )}\r\n                  </div>\r\n                ))}\r\n              </div>\r\n            )}\r\n          </div>\r\n\r\n          <div style={styles.timeStepButtons}>\r\n            <button\r\n              onClick={() => jumpToTimepoint(0)}\r\n              disabled={currentTimepoint === 0 || isSimulationRunning}\r\n              style={{ ...buttonVariants.secondaryButton, padding: '4px 8px' }}\r\n            >\r\n              ⏮️ Start\r\n            </button>\r\n            <button\r\n              onClick={() => jumpToTimepoint(currentTimepoint - 1)}\r\n              disabled={currentTimepoint === 0 || isSimulationRunning}\r\n              style={{ ...buttonVariants.secondaryButton, padding: '4px 8px' }}\r\n            >\r\n              ⏪ Previous\r\n            </button>\r\n            <button\r\n              onClick={() => jumpToTimepoint(currentTimepoint + 1)}\r\n              disabled={currentTimepoint >= dropletHistory.length - 1 || isSimulationRunning}\r\n              style={{ ...buttonVariants.secondaryButton, padding: '4px 8px' }}\r\n            >\r\n              Next ⏩\r\n            </button>\r\n            <button\r\n              onClick={() => jumpToTimepoint(dropletHistory.length - 1)}\r\n              disabled={currentTimepoint >= dropletHistory.length - 1 || isSimulationRunning}\r\n              style={{ ...buttonVariants.secondaryButton, padding: '4px 8px' }}\r\n            >\r\n              End ⏭️\r\n            </button>\r\n          </div>\r\n\r\n          <div style={styles.timeScaleContainer}>\r\n            <label style={{ color: '#fff', marginRight: '10px' }}>\r\n              Time Scale:\r\n              <select\r\n                value={timeScale}\r\n                onChange={(e) => setTimeScale(Number(e.target.value))}\r\n                style={styles.timeInput}\r\n              >\r\n                <option value={0.0625}>1/16x</option>\r\n                <option value={0.25}>1/4x</option>\r\n                <option value={1}>1x</option>\r\n                <option value={4}>4x</option>\r\n                <option value={16}>16x</option>\r\n                <option value={64}>64x</option>\r\n                <option value={256}>256x</option>\r\n                <option value={1024}>1024x</option>\r\n              </select>\r\n            </label>\r\n            <label style={{ color: '#fff', marginRight: '10px' }}>\r\n              Current Time: {currentTime.toFixed(2)}s\r\n            </label>\r\n            <label style={{ color: '#fff' }}>\r\n              Step: {currentTimepoint + 1}/{dropletHistory.length}\r\n            </label>\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      <div style={styles.buttonGroup}>\r\n        <button \r\n          onClick={isSimulationRunning ? stopSimulation : startSimulation} \r\n          style={{ ...buttonVariants.primaryButton }}\r\n        >\r\n          {isSimulationRunning ? 'Stop Simulation' : 'Start Simulation'}\r\n        </button>\r\n        <button \r\n          onClick={restartSimulation} \r\n          style={{ ...buttonVariants.secondaryButton }}\r\n        >\r\n          Restart simulation\r\n        </button>\r\n        <button \r\n          onClick={sendingEventsToDevices} \r\n          style={{ ...buttonVariants.primaryButton }}\r\n        >\r\n          Send Events to Devices\r\n        </button>\r\n        <div ref={displayMenuRef} style={{ position: 'relative', display: 'inline-block' }}>\r\n          <button \r\n            onClick={toggleDisplayMenu} \r\n            style={styles.displayMenuButton}\r\n          >\r\n            Display Settings\r\n          </button>\r\n          {isDisplayMenuOpen && (\r\n            <div style={styles.displayMenu}>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={toggleNodeIds}\r\n              >\r\n                <span>Show Node IDs</span>\r\n                <span style={styles.checkmark}>{displayNodeIds ? '✓' : ''}</span>\r\n              </div>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={toggleDropletInfo}\r\n              >\r\n                <span>Show Droplet Info</span>\r\n                <span style={styles.checkmark}>{displayDropletInfo ? '✓' : ''}</span>\r\n              </div>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={toggleDropletGaps}\r\n              >\r\n                <span>Show Droplet Gaps</span>\r\n                <span style={styles.checkmark}>{displayDropletGaps ? '✓' : ''}</span>\r\n              </div>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={toggleEdgeLabels}\r\n              >\r\n                <span>Show Tube Dimensions</span>\r\n                <span style={styles.checkmark}>{displayEdgeLabels ? '✓' : ''}</span>\r\n              </div>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={togglePumpSpeeds}\r\n              >\r\n                <span>Show Pump Speeds</span>\r\n                <span style={styles.checkmark}>{displayPumpSpeeds ? '✓' : ''}</span>\r\n              </div>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={toggleTimelineDropletInfo}\r\n              >\r\n                <span>Show Timeline Droplet Info</span>\r\n                <span style={styles.checkmark}>{displayTimelineDropletInfo ? '✓' : ''}</span>\r\n              </div>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={toggleDetectorEvents}\r\n              >\r\n                <span>Show Detector Events</span>\r\n                <span style={styles.checkmark}>{displayDetectorEvents ? '✓' : ''}</span>\r\n              </div>\r\n            </div>\r\n          )}\r\n        </div>\r\n      </div>\r\n\r\n      {/* Rest of the SVG rendering code */}\r\n      {graphData.nodes.length > 0 && (\r\n        <div style={styles.svgContainer}>\r\n          <svg width=\"2000\" height=\"400\">\r\n            {/* Render edges first (background) */}\r\n            {graphData.links.map((link, index) => {\r\n              const sourceNode = graphData.nodes.find(node => node.id === link.source);\r\n              const targetNode = graphData.nodes.find(node => node.id === link.target);\r\n              if (!sourceNode || !targetNode) return null;\r\n              \r\n              const midX = (sourceNode.x + targetNode.x) / 2;\r\n              const midY = (sourceNode.y + targetNode.y) / 2;\r\n              \r\n              return (\r\n                <g key={`edge-${index}`}>\r\n                  <line\r\n                    x1={sourceNode.x}\r\n                    y1={sourceNode.y}\r\n                    x2={targetNode.x}\r\n                    y2={targetNode.y}\r\n                    stroke=\"#999\"\r\n                    strokeWidth={2}\r\n                  />\r\n                  <text\r\n                    x={midX}\r\n                    y={midY - 20}\r\n                    textAnchor=\"middle\"\r\n                    fill=\"#fff\"\r\n                    fontSize=\"12px\"\r\n                    style={{ display: displayEdgeLabels ? 'block' : 'none' }}\r\n                  >\r\n                    {`${link.length} mm (Ø ${link.diameter} mm)`}\r\n                  </text>\r\n                </g>\r\n              );\r\n            })}\r\n\r\n            {/* Render nodes (on top) */}\r\n            {graphData.nodes.map((node, index) => (\r\n              <g key={`node-${index}`}>\r\n                <circle\r\n                  cx={node.x}\r\n                  cy={node.y}\r\n                  r={15}\r\n                  fill={getNodeColor(node)}\r\n                  stroke={selectedNode && selectedNode.id === node.id ? '#FFA500' : 'none'}\r\n                  strokeWidth={selectedNode && selectedNode.id === node.id ? '3' : '0'}\r\n                  onClick={() => handleNodeClick(node)}\r\n                  style={{ cursor: 'pointer' }}\r\n                />\r\n                <text\r\n                  x={node.x}\r\n                  y={node.y - 25}\r\n                  textAnchor=\"middle\"\r\n                  fill=\"#fff\"\r\n                  fontSize=\"12px\"\r\n                >\r\n                  {node.label}\r\n                </text>\r\n                <text\r\n                  x={node.x}\r\n                  y={node.y - 10}\r\n                  textAnchor=\"middle\"\r\n                  fill=\"#fff\"\r\n                  fontSize=\"10px\"\r\n                  style={{ display: displayNodeIds ? 'block' : 'none' }}\r\n                >\r\n                  {`ID: ${node.id}`}\r\n                </text>\r\n              </g>\r\n            ))}\r\n\r\n            {/* Render droplets and distances between them */}\r\n            {interpolateDropletState(currentTime).map((droplet, index, droplets) => {\r\n              const frontX = volumetricToXPosition(droplet.frontVolumetricPosition);\r\n              const rearX = volumetricToXPosition(droplet.rearVolumetricPosition);\r\n              const centerX = (frontX + rearX) / 2;\r\n              \r\n              // Calculate distance to next droplet if this isn't the last droplet\r\n              const distanceInfo = index < droplets.length - 1 ? {\r\n                nextDropletFront: droplets[index + 1].frontVolumetricPosition,\r\n                distance: Math.abs(droplets[index + 1].frontVolumetricPosition - droplet.rearVolumetricPosition)\r\n              } : null;\r\n              \r\n              // Calculate midpoint for distance label\r\n              const distanceLabelX = distanceInfo ? \r\n                (volumetricToXPosition(droplet.rearVolumetricPosition) + \r\n                 volumetricToXPosition(distanceInfo.nextDropletFront)) / 2 : null;\r\n\r\n              return (\r\n                <g key={`droplet-${droplet.id}`}>\r\n                  {/* Droplet body */}\r\n                  <line\r\n                    x1={rearX}\r\n                    y1={300}\r\n                    x2={frontX}\r\n                    y2={300}\r\n                    stroke=\"rgba(255, 100, 100, 0.9)\"\r\n                    strokeWidth={8}\r\n                    strokeLinecap=\"butt\"\r\n                  />\r\n                  \r\n                  {/* Distance to next droplet */}\r\n                  {distanceInfo && displayDropletGaps && (\r\n                    <g>\r\n                      {/* Distance line */}\r\n                      <line\r\n                        x1={rearX}\r\n                        y1={320}\r\n                        x2={volumetricToXPosition(distanceInfo.nextDropletFront)}\r\n                        y2={320}\r\n                        stroke=\"#fff\"\r\n                        strokeWidth={1}\r\n                        strokeDasharray=\"5,5\"\r\n                      />\r\n                      {/* Distance arrows */}\r\n                      <line\r\n                        x1={rearX}\r\n                        y1={315}\r\n                        x2={rearX}\r\n                        y2={325}\r\n                        stroke=\"#fff\"\r\n                        strokeWidth={1}\r\n                      />\r\n                      <line\r\n                        x1={volumetricToXPosition(distanceInfo.nextDropletFront)}\r\n                        y1={315}\r\n                        x2={volumetricToXPosition(distanceInfo.nextDropletFront)}\r\n                        y2={325}\r\n                        stroke=\"#666\"\r\n                        strokeWidth={1}\r\n                      />\r\n                      {/* Distance label */}\r\n                      <text\r\n                        x={distanceLabelX}\r\n                        y={335}\r\n                        textAnchor=\"middle\"\r\n                        fill=\"#666\"\r\n                        fontSize=\"12px\"\r\n                      >\r\n                        {`${distanceInfo.distance.toFixed(2)} μL`}\r\n                      </text>\r\n                    </g>\r\n                  )}\r\n                  \r\n                  {/* Droplet info - wrap all info texts in conditional rendering */}\r\n                  {displayDropletInfo && (\r\n                    <>\r\n                      <text\r\n                        x={centerX}\r\n                        y={270}\r\n                        textAnchor=\"middle\"\r\n                        fill=\"#6f6\"\r\n                        fontSize=\"12px\"\r\n                      >\r\n                        {`Vol: ${(droplet.frontVolumetricPosition-droplet.rearVolumetricPosition).toFixed(2)} μL`}\r\n                      </text>\r\n                      <text\r\n                        x={centerX}\r\n                        y={255}\r\n                        textAnchor=\"middle\"\r\n                        fill=\"#6f6\"\r\n                        fontSize=\"12px\"\r\n                      >\r\n                        {`Spd f: ${droplet.frontVolumetricSpeed.toFixed(2)} μL/s`}\r\n                      </text>\r\n                      <text\r\n                        x={centerX}\r\n                        y={240}\r\n                        textAnchor=\"middle\"\r\n                        fill=\"#6f6\"\r\n                        fontSize=\"12px\"\r\n                      >\r\n                        {`Spd r: ${droplet.rearVolumetricSpeed.toFixed(2)} μL/s`}\r\n                      </text>\r\n                      <text\r\n                        x={centerX}\r\n                        y={225}\r\n                        textAnchor=\"middle\"\r\n                        fill=\"#6f6\"\r\n                        fontSize=\"12px\"\r\n                      >\r\n                        {`mlt: ${droplet.pumpSpeedMultiplier.toFixed(2)}`}\r\n                      </text>\r\n                    </>\r\n                  )}\r\n                </g>\r\n              );\r\n            })}\r\n\r\n            {displayPumpSpeeds && graphData.nodes.map((node, index) => {\r\n              if (node.type === 'pump') {\r\n                const currentSpeed = getPumpSpeedAtTime(node.id, pumpEvents, currentTime);\r\n                const maxTime = dropletHistory[dropletHistory.length - 1]?.time || 1;\r\n                const pumpSpecificEvents = pumpEvents.filter(event => event.target === node.id);\r\n                \r\n                return (\r\n                  <g key={`pump-speed-${node.id}`}>\r\n                    {/* Current pump speed value */}\r\n                    <text\r\n                      x={node.x}\r\n                      y={node.y - 35}\r\n                      textAnchor=\"middle\"\r\n                      fill=\"#4CAF50\"\r\n                      fontSize=\"12px\"\r\n                    >\r\n                      {`${currentSpeed.toFixed(2)} μL/s`}\r\n                    </text>\r\n                    \r\n                    {/* Speed history visualization */}\r\n                    <g transform={`translate(${node.x - 40}, ${node.y - 65})`}>\r\n                      {pumpSpecificEvents.map((event, i, arr) => {\r\n                        const nextEvent = arr[i + 1];\r\n                        const width = 80;\r\n                        const x = 0;\r\n                        const y = 0;\r\n                        \r\n                        // Calculate position based on time\r\n                        const timePosition = (event.time / maxTime) * width;\r\n                        const nextTimePosition = nextEvent \r\n                          ? (nextEvent.time / maxTime) * width\r\n                          : width;\r\n                        \r\n                        // Calculate height based on speed value (normalized)\r\n                        const maxSpeed = Math.max(...pumpSpecificEvents.map(e => e.value));\r\n                        const normalizedHeight = event.value / (maxSpeed || 1) * 20;\r\n                        \r\n                        return (\r\n                          <g key={`pump-event-${i}`}>\r\n                            {/* Speed segment */}\r\n                            <line\r\n                              x1={x + timePosition}\r\n                              y1={y - normalizedHeight}\r\n                              x2={x + nextTimePosition}\r\n                              y2={y - normalizedHeight}\r\n                              stroke=\"#4CAF50\"\r\n                              strokeWidth={2}\r\n                            />\r\n                            {/* Event point */}\r\n                            <circle\r\n                              cx={x + timePosition}\r\n                              cy={y - normalizedHeight}\r\n                              r={2}\r\n                              fill=\"#4CAF50\"\r\n                            />\r\n                            {/* Time marker */}\r\n                            <text\r\n                              x={x + timePosition}\r\n                              y={y + 12}\r\n                              textAnchor=\"middle\"\r\n                              fill=\"#666\"\r\n                              fontSize=\"10px\"\r\n                            >\r\n                              {event.time.toFixed(1)}s\r\n                            </text>\r\n                            {/* Speed value */}\r\n                            <text\r\n                              x={x + timePosition}\r\n                              y={y - normalizedHeight - 5}\r\n                              textAnchor=\"middle\"\r\n                              fill=\"#4CAF50\"\r\n                              fontSize=\"8px\"\r\n                            >\r\n                              {event.value.toFixed(1)}\r\n                            </text>\r\n                          </g>\r\n                        );\r\n                      })}\r\n                      {/* Current time indicator */}\r\n                      <line\r\n                        x1={(currentTime / maxTime) * 80}\r\n                        y1={-25}\r\n                        x2={(currentTime / maxTime) * 80}\r\n                        y2={15}\r\n                        stroke=\"red\"\r\n                        strokeWidth={1}\r\n                        strokeDasharray=\"2,2\"\r\n                      />\r\n                    </g>\r\n                  </g>\r\n                );\r\n              }\r\n              return null;\r\n            })}\r\n          </svg>\r\n        </div>\r\n      )}\r\n      \r\n      {selectedNode && (selectedNode.type === 'pump' || selectedNode.data?.type === 'pump') && (\r\n        <DraggablePanel \r\n          initialPosition={pumpPanelPosition}\r\n          title={`Pump Controls - ${selectedNode.label || selectedNode.id}`}\r\n        >\r\n          <PumpActions\r\n            node={selectedNode}\r\n            nodes={nodes}\r\n            edges={edges}\r\n            onAction={handleNodeAction}\r\n          />\r\n        </DraggablePanel>\r\n      )}\r\n      {selectedNode && (selectedNode.type === 'USBSpectrometer' || selectedNode.data?.type === 'USBSpectrometer') && (\r\n        <>\r\n          {console.log('Rendering USBSpectrometer component for node:', selectedNode)}\r\n          <USBSpectrometer\r\n            detector={selectedNode}\r\n            detectorId={selectedNode.id}\r\n            detectorName={selectedNode.label || selectedNode.id}\r\n            onClose={() => setSelectedNode(null)}\r\n            initialPosition={{ x: 150, y: 100 }}\r\n            isVisible={true}\r\n          />\r\n        </>\r\n      )}\r\n      {selectedNode && (selectedNode.type === 'MQTTSpectrometer' || selectedNode.data?.type === 'MQTTSpectrometer') && (\r\n        <>\r\n          {console.log('Rendering SpectrometerMQTT component for node:', selectedNode)}\r\n          <SpectrometerMQTT\r\n            detector={selectedNode}\r\n            detectorId={selectedNode.id}\r\n            detectorName={selectedNode.label || selectedNode.id}\r\n            onClose={() => setSelectedNode(null)}\r\n            initialPosition={{ x: 150, y: 100 }}\r\n            isVisible={true}\r\n          />\r\n        </>\r\n      )}\r\n      {/* Add styles for PumpActions */}\r\n      <style>\r\n        {`\r\n          .node-actions {\r\n            position: fixed;\r\n            top: 20px;\r\n            right: 20px;\r\n            background: black;\r\n            padding: 20px;\r\n            border: 1px solid #ccc;\r\n            border-radius: 5px;\r\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\r\n          }\r\n          .node-actions h3 {\r\n            margin: 0 0 15px 0;\r\n            color: #333;\r\n          }\r\n          .node-actions button {\r\n            margin: 5px;\r\n            padding: 8px 16px;\r\n            background: #4CAF50;\r\n            color: white;\r\n            border: none;\r\n            border-radius: 4px;\r\n            cursor: pointer;\r\n          }\r\n          .node-actions button:disabled {\r\n            background: #ccc;\r\n            cursor: not-allowed;\r\n          }\r\n          .node-actions input {\r\n            margin: 5px;\r\n            padding: 8px;\r\n            border: 1px solid #ccc;\r\n            border-radius: 4px;\r\n            width: 80px;\r\n          }\r\n          .move-controls {\r\n            display: flex;\r\n            flex-direction: column;\r\n            gap: 10px;\r\n            margin-top: 10px;\r\n          }\r\n          .input-group {\r\n            display: flex;\r\n            align-items: center;\r\n            gap: 10px;\r\n          }\r\n          .input-group label {\r\n            min-width: 100px;\r\n            text-align: right;\r\n            color: #666;\r\n          }\r\n        `}\r\n      </style>\r\n      {overlayComponent && (\r\n        <div style={{\r\n          position: 'fixed',\r\n          top: 0,\r\n          left: 0,\r\n          right: 0,\r\n          bottom: 0,\r\n          zIndex: 9999,\r\n          pointerEvents: 'none'\r\n        }}>\r\n          <Suspense fallback={\r\n            <div style={{\r\n              position: 'fixed',\r\n              top: '50%',\r\n              left: '50%',\r\n              transform: 'translate(-50%, -50%)',\r\n              background: 'rgba(0,0,0,0.8)',\r\n              padding: '20px',\r\n              borderRadius: '8px',\r\n              color: 'white',\r\n              pointerEvents: 'auto'\r\n            }}>\r\n              <h2>Loading Component...</h2>\r\n            </div>\r\n          }>\r\n            {overlayComponent.type === 'USBSpectrometer' && (\r\n              <div style={{ pointerEvents: 'auto' }}>\r\n                <USBSpectrometer {...overlayComponent.props} />\r\n              </div>\r\n            )}\r\n            {overlayComponent.type === 'MQTTSpectrometer' && (\r\n              <div style={{ pointerEvents: 'auto' }}>\r\n                <SpectrometerMQTT \r\n                  {...overlayComponent.props} \r\n                  graphRef={graphRefs.current[overlayComponent.props.detector.id]}\r\n                />\r\n              </div>\r\n            )}\r\n            {overlayComponent.type === 'PumpPanel' && (\r\n              <div style={{ pointerEvents: 'auto' }}>\r\n                <PumpPanel {...overlayComponent.props} />\r\n              </div>\r\n            )}\r\n          </Suspense>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Simulation;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}