{"ast":null,"code":"var _jsxFileName = \"E:\\\\flow chemistry\\\\fluidicGUI\\\\frontend\\\\fluidicgui\\\\src\\\\components\\\\Simulation\\\\Simulation.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useCallback, useRef, Suspense } from 'react';\nimport { ReactFlowProvider, useNodesState, useEdgesState } from 'react-flow-renderer';\nimport PumpActions from './NodeActions/PumpActions';\nimport DraggablePanel from './DraggablePanel';\nimport { convertToHardwareValuesPump } from '../../utils/pumpCalculations';\nimport { useButtonStyles } from '../../styles/ButtonStyleProvider';\nimport { backgroundVariants } from '../../styles/backgroundStyles';\nimport { findOutletNode, findFurthestNode, orderNodesByDistance, calculateEdgeVolume, getVolumeBetweenNodes, findConnectedPump, getPumpSpeed, getPumpsBetweenPositions, cleanAndSortEventList, getPumpSpeedAtTime, sendEventsToDevices, setOfMainLineNodes, setOfSecondaryLineNodes } from '../../utils/simulationUtils';\nimport './simulation.css'; // We'll create this CSS file\nimport SvgDefs from './SvgDefs';\nimport { calculateEdgePoints, createLabels } from '../../utils/flowchartUtils';\nimport USBSpectrometer from './USBSpectrometer';\nimport SpectrometerMQTT from './SpectrometerMQTT';\nimport PumpPanel from './PumpPanel';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst Simulation = ({\n  nodes = [],\n  edges = [],\n  droplets = [],\n  selectedCarrierPumps = [],\n  onBack,\n  onNext\n}) => {\n  _s();\n  var _dropletHistory$curre, _selectedNode$data, _selectedNode$data2, _selectedNode$data3;\n  const buttonVariants = useButtonStyles();\n  const [graphData, setGraphData] = useState({\n    nodes: [],\n    links: []\n  });\n  const [simulationDroplets, setSimulationDroplets] = useState([]);\n  const [isSimulationRunning, setIsSimulationRunning] = useState(false);\n  const [key, setKey] = useState(0);\n  const [currentTime, setCurrentTime] = useState(0);\n  const [timeScale, setTimeScale] = useState(1); // Default 1x speed\n  const animationFrameRef = useRef();\n  const lastFrameTimeRef = useRef();\n  const [currentBlockDroplets, setCurrentBlockDroplets] = useState([]);\n  const [dropletHistory, setDropletHistory] = useState([]);\n  const [currentTimepoint, setCurrentTimepoint] = useState(0);\n  const [pumpEvents, setPumpEvents] = useState([]);\n  const [detectorEvents, setDetectorEvents] = useState([]);\n  const [displayPumpSpeeds, setDisplayPumpSpeeds] = useState(false);\n  const [displayNodeIds, setDisplayNodeIds] = useState(false);\n  const [displayDropletInfo, setDisplayDropletInfo] = useState(false);\n  const [displayDropletGaps, setDisplayDropletGaps] = useState(true);\n  const [displayEdgeLabels, setDisplayEdgeLabels] = useState(false);\n  const [isDisplayMenuOpen, setDisplayMenuOpen] = useState(false);\n  const [displayTimelineDropletInfo, setDisplayTimelineDropletInfo] = useState(false);\n  const [displayDetectorEvents, setDisplayDetectorEvents] = useState(false);\n  const displayMenuRef = useRef(null);\n  const [selectedNode, setSelectedNode] = useState(null);\n  const [ws, setWs] = useState(null);\n  const [pumpPanelPosition, setPumpPanelPosition] = useState({\n    x: window.innerWidth - 300,\n    y: 100\n  });\n  const [visiblePumpPanel, setVisiblePumpPanel] = useState(null);\n  const [isSendingEvents, setIsSendingEvents] = useState(false);\n  const graphRefs = useRef({});\n  const [overlayComponent, setOverlayComponent] = useState(null);\n\n  // Add at the beginning of the component, after the state initialization\n  useEffect(() => {\n    // Log all nodes and their types for debugging\n    console.log('All nodes:', nodes);\n    if (nodes && nodes.length > 0) {\n      console.log('Node types in simulation:', nodes.map(node => {\n        var _node$data;\n        return {\n          id: node.id,\n          type: node.type,\n          dataType: (_node$data = node.data) === null || _node$data === void 0 ? void 0 : _node$data.type\n        };\n      }));\n    }\n  }, [nodes]);\n  useEffect(() => {\n    // Create WebSocket connection\n    const websocket = new WebSocket('ws://localhost:4000');\n    websocket.onopen = () => {\n      console.log('Connected to WebSocket server');\n    };\n    websocket.onerror = error => {\n      console.error('WebSocket error:', error);\n    };\n    setWs(websocket);\n\n    // Cleanup on unmount\n    return () => {\n      if (websocket) {\n        websocket.close();\n      }\n    };\n  }, []);\n  const sendingEventsToDevices = () => {\n    setIsSendingEvents(true);\n    sendEventsToDevices(pumpEvents, ws, nodes);\n    // Send measurement timepoints to spectrometers\n    sendMeasurementTimepointsToSpectrometers(detectorEvents, ws, nodes);\n    // Reset simulation state\n    setCurrentTime(0);\n    setCurrentTimepoint(0);\n    setIsSimulationRunning(true);\n    setDropletHistory([]);\n    // Generate new event list\n    generateEventList([{\n      droplets: droplets\n    }]);\n  };\n\n  // Add function to send measurement timepoints to spectrometers via MQTT\n  const sendMeasurementTimepointsToSpectrometers = (detectorEvents, websocket, nodes) => {\n    if (!websocket || !detectorEvents || !nodes) {\n      console.warn('Missing required parameters for sending measurement timepoints');\n      return;\n    }\n\n    // Group detector events by detector/spectrometer ID\n    const eventsByDetector = detectorEvents.reduce((acc, event) => {\n      if (!acc[event.target]) {\n        acc[event.target] = [];\n      }\n      acc[event.target].push(event);\n      return acc;\n    }, {});\n\n    // Send timepoints to each spectrometer\n    Object.entries(eventsByDetector).forEach(([detectorId, events]) => {\n      var _detectorNode$data;\n      const detectorNode = nodes.find(node => node.id === detectorId);\n\n      // Check if this is an MQTT spectrometer\n      if (detectorNode && (detectorNode.type === 'MQTTSpectrometer' || ((_detectorNode$data = detectorNode.data) === null || _detectorNode$data === void 0 ? void 0 : _detectorNode$data.type) === 'MQTTSpectrometer')) {\n        var _detectorNode$data2, _detectorNode$data2$p, _detectorNode$data2$p2, _detectorNode$data3, _detectorNode$data3$p, _detectorNode$data3$p2;\n        // Extract MQTT name from detector properties\n        const mqttName = ((_detectorNode$data2 = detectorNode.data) === null || _detectorNode$data2 === void 0 ? void 0 : (_detectorNode$data2$p = _detectorNode$data2.properties) === null || _detectorNode$data2$p === void 0 ? void 0 : (_detectorNode$data2$p2 = _detectorNode$data2$p.find(prop => prop.name === 'mqttName')) === null || _detectorNode$data2$p2 === void 0 ? void 0 : _detectorNode$data2$p2.value) || ((_detectorNode$data3 = detectorNode.data) === null || _detectorNode$data3 === void 0 ? void 0 : (_detectorNode$data3$p = _detectorNode$data3.properties) === null || _detectorNode$data3$p === void 0 ? void 0 : (_detectorNode$data3$p2 = _detectorNode$data3$p.find(prop => prop.name === 'mqtt_name')) === null || _detectorNode$data3$p2 === void 0 ? void 0 : _detectorNode$data3$p2.value) || detectorId; // fallback to detector ID\n\n        // Extract timepoints from events (convert to milliseconds)\n        const timepoints = events.map(event => Math.round(event.time * 1000));\n\n        // Create MQTT message\n        const mqttMessage = {\n          type: 'mqtt_publish',\n          topic: `${mqttName}/request/measurement_timepoints`,\n          payload: {\n            timepoints: timepoints,\n            timestamp: Date.now(),\n            detectorId: detectorId\n          }\n        };\n\n        // Send via WebSocket\n        try {\n          websocket.send(JSON.stringify(mqttMessage));\n          console.log(`Sent measurement timepoints to ${mqttName}:`, timepoints);\n        } catch (error) {\n          console.error(`Failed to send measurement timepoints to ${mqttName}:`, error);\n        }\n      }\n    });\n  };\n\n  // Add effect to handle automatic memory addition when events are being sent\n  useEffect(() => {\n    if (isSendingEvents) {\n      // Get all graph refs and add data to memory\n      Object.values(graphRefs.current).forEach(graphRef => {\n        if (graphRef && graphRef.current && graphRef.current.addToMemory) {\n          graphRef.current.addToMemory();\n        }\n      });\n    }\n  }, [isSendingEvents]);\n  const eventType = ['setPumpSpeed', 'setThermostatTemperature', 'setLedIntensity', 'wait', 'blockEnd'];\n  const calculateVolumesBetweenThermostats = graphData => {\n    // Find outlet node first\n    const outletNode = findOutletNode(graphData.nodes);\n    const visited = new Set();\n    const queue = [[outletNode.id, 0, []]]; // [nodeId, accumulated volume, path of thermostats]\n    const thermostatVolumes = [];\n    while (queue.length > 0) {\n      let [currentNodeId, accumulatedVolume, thermostatPath] = queue.shift();\n      const currentNode = graphData.nodes.find(n => n.id === currentNodeId);\n      if (!currentNode) continue;\n\n      // Track all visited nodes to prevent infinite loops\n      if (visited.has(currentNodeId)) continue;\n      visited.add(currentNodeId);\n\n      // If we found a thermostat, add it to the path\n      let updatedPath = [...thermostatPath];\n      if (currentNode.type === 'thermostat') {\n        if (thermostatPath.length > 0) {\n          thermostatVolumes.push({\n            startThermostatId: thermostatPath[thermostatPath.length - 1],\n            endThermostatId: currentNodeId,\n            volume: accumulatedVolume\n          });\n        }\n        updatedPath.push(currentNodeId);\n        // Reset accumulated volume after finding a thermostat\n        accumulatedVolume = 0;\n      }\n\n      // Find all connected edges and nodes\n      const connectedEdges = graphData.links.filter(link => link.source === currentNodeId || link.target === currentNodeId);\n      for (const edge of connectedEdges) {\n        const nextNodeId = edge.source === currentNodeId ? edge.target : edge.source;\n        const nextNode = graphData.nodes.find(n => n.id === nextNodeId);\n\n        // Skip paths to pumps\n        if (nextNode && nextNode.type !== 'pump') {\n          const edgeVolume = calculateEdgeVolume(edge);\n          queue.push([nextNodeId, accumulatedVolume + edgeVolume, updatedPath]);\n        }\n      }\n    }\n    return thermostatVolumes;\n  };\n  //add something to handle lack of thermostat\n  const divideDropletsIntoBlocks = (droplets, thermostatVolumes) => {\n    if (thermostatVolumes.length === 0) {\n      return [{\n        droplets: droplets,\n        thermostatId: null,\n        totalVolume: droplets.reduce((acc, droplet) => acc + droplet.actualVolume, 0),\n        temperature: null,\n        time: null\n      }];\n    }\n    const furthestNode = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links);\n    const volumeToFurthestNode = getVolumeBetweenNodes(thermostatVolumes[0].endThermostatId, furthestNode.id, graphData.nodes, graphData.links);\n    if (!droplets.length || !thermostatVolumes.length) return [];\n    const blocks = [];\n    let currentBlock = {\n      droplets: [],\n      thermostatId: thermostatVolumes[0].endThermostatId,\n      totalVolume: 0,\n      temperature: null,\n      time: null\n    };\n\n    // Helper to finalize a block and start a new one\n    const finalizeBlock = (thermostatId, temperature, time) => {\n      if (currentBlock.droplets.length > 0) {\n        // Add volumeToFurthestNode to the surfixVolume of the last droplet in the block\n        const lastDroplet = currentBlock.droplets[currentBlock.droplets.length - 1];\n        const surfixParam = lastDroplet.parameters.find(p => p.name === 'surfixVolume');\n        if (surfixParam) {\n          surfixParam.value = Math.max(volumeToFurthestNode, surfixParam.value);\n        } else {\n          lastDroplet.parameters.push({\n            name: 'surfixVolume',\n            value: volumeToFurthestNode\n          });\n        }\n        blocks.push({\n          ...currentBlock\n        });\n      }\n      currentBlock = {\n        droplets: [],\n        thermostatId: thermostatId,\n        totalVolume: 0,\n        temperature: temperature,\n        time: time\n      };\n    };\n\n    // Process droplets in order\n    for (let i = 0; i < droplets.length; i++) {\n      var _droplet$parameters$f, _droplet$parameters$f2, _droplet$parameters$f3, _droplet$parameters$f4, _droplet$parameters$f5;\n      const droplet = droplets[i];\n      const temperature = (_droplet$parameters$f = droplet.parameters.find(p => p.name === 'temperature')) === null || _droplet$parameters$f === void 0 ? void 0 : _droplet$parameters$f.value;\n      const time = (_droplet$parameters$f2 = droplet.parameters.find(p => p.name === 'time')) === null || _droplet$parameters$f2 === void 0 ? void 0 : _droplet$parameters$f2.value;\n\n      // Start new block if temperature or time changes, or if volume limit exceeded\n      const relevantVolume = thermostatVolumes.find(tv => tv.startThermostatId === currentBlock.thermostatId || tv.endThermostatId === currentBlock.thermostatId);\n      let dropletVolume = (_droplet$parameters$f3 = droplet.parameters.find(p => p.name === 'volume')) === null || _droplet$parameters$f3 === void 0 ? void 0 : _droplet$parameters$f3.value;\n      dropletVolume += (_droplet$parameters$f4 = droplet.parameters.find(p => p.name === 'prefixVolume')) === null || _droplet$parameters$f4 === void 0 ? void 0 : _droplet$parameters$f4.value;\n      if (currentBlock.temperature !== temperature || currentBlock.time !== time || relevantVolume && currentBlock.totalVolume + dropletVolume > relevantVolume.volume) {\n        finalizeBlock(thermostatVolumes[0].endThermostatId, temperature, time);\n      }\n      dropletVolume += (_droplet$parameters$f5 = droplet.parameters.find(p => p.name === 'surfixVolume')) === null || _droplet$parameters$f5 === void 0 ? void 0 : _droplet$parameters$f5.value;\n      // Add droplet to current block\n      currentBlock.droplets.push(droplet);\n      currentBlock.totalVolume += dropletVolume;\n      currentBlock.temperature = temperature;\n      currentBlock.time = time;\n    }\n\n    // Finalize last block\n    finalizeBlock(null, null, null);\n    return blocks;\n  };\n  function printDropletFrontPositionsAndSpeeds(droplets) {\n    droplets.forEach(droplet => {\n      console.log(`Droplet ID: ${droplet.id}, Front Volumetric Position: ${droplet.frontVolumetricPosition}, Front time to next node  : ${droplet.frontTimeToReachNextNode}, Front Volumetric Distance to next node: ${droplet.frontVolumetricDistanceToNextNode}, Rear Volumetric Position: ${droplet.rearVolumetricPosition}, Rear time to next node: ${droplet.rearTimeToReachNextNode}, Rear Volumetric Distance to next node: ${droplet.rearVolumetricDistanceToNextNode}, frontNextNodeID: ${droplet.frontNextNodeID}, rearNextNodeID: ${droplet.rearNextNodeID}`);\n    });\n  }\n  const extractPumpEvents = eventList => {\n    // eventList is now an array of arrays, where each inner array contains events for a specific pump\n    return eventList.flat() // Flatten the array of arrays\n    .filter(event => event.type === 'setPumpSpeed').sort((a, b) => a.time - b.time);\n  };\n  const extractDetectorEvents = eventList => {\n    // Extract detector/spectrometer measurement events\n    return eventList.flat() // Flatten the array of arrays\n    .filter(event => event.type === 'setDetectorMeasurement').sort((a, b) => a.time - b.time);\n  };\n  const getDetectorEventsAtTime = (detectorId, detectorEvents, currentTime) => {\n    return detectorEvents.filter(event => event.target === detectorId && Math.abs(event.time - currentTime) < 0.1 // Within 0.1 second tolerance\n    );\n  };\n  const recalculateEventListForDevices = eventList => {\n    const deviceEventMap = new Map();\n    const convertPumpEvent = (event, deviceProperties) => {\n      var _deviceProperties$fin, _deviceProperties$fin2, _deviceProperties$fin3, _deviceProperties$fin4;\n      // Find properties by name from the properties array\n      const syringeDiameter = ((_deviceProperties$fin = deviceProperties.find(p => p.name === 'diameter')) === null || _deviceProperties$fin === void 0 ? void 0 : _deviceProperties$fin.default) || 0;\n      const syringeLength = ((_deviceProperties$fin2 = deviceProperties.find(p => p.name === 'length')) === null || _deviceProperties$fin2 === void 0 ? void 0 : _deviceProperties$fin2.default) || 0;\n      const stepsPerRevolution = ((_deviceProperties$fin3 = deviceProperties.find(p => p.name === 'steps per revolution')) === null || _deviceProperties$fin3 === void 0 ? void 0 : _deviceProperties$fin3.default) || 0;\n      const lead = ((_deviceProperties$fin4 = deviceProperties.find(p => p.name === 'lead')) === null || _deviceProperties$fin4 === void 0 ? void 0 : _deviceProperties$fin4.default) || 0;\n      const syringeArea = Math.PI * Math.pow(syringeDiameter / 2, 2);\n      const linearSpeed = Math.abs(event.value) / syringeArea;\n      const stepsPerMm = stepsPerRevolution / lead;\n      const stepsPerSecond = linearSpeed * stepsPerMm;\n      const delayMicroseconds = stepsPerSecond > 0 ? Math.round(1000000 / stepsPerSecond) : 0;\n      return {\n        target: event.target,\n        time: Math.round(event.time * 1000000),\n        delay: delayMicroseconds\n      };\n    };\n    const convertThermostatEvent = (event, deviceProperties) => {\n      // Placeholder for thermostat conversion logic\n      return {\n        target: event.target,\n        time: Math.round(event.time * 1000000),\n        temperature: event.value\n        // Add other thermostat-specific parameters here\n      };\n    };\n    const convertLedEvent = (event, deviceProperties) => {\n      // Placeholder for LED conversion logic\n      return {\n        target: event.target,\n        time: Math.round(event.time * 1000000),\n        intensity: event.value\n        // Add other LED-specific parameters here\n      };\n    };\n    const convertDetectorEvent = (event, deviceProperties) => {\n      // Placeholder for detector conversion logic\n      return {\n        target: event.target,\n        time: Math.round(event.time * 1000000),\n        setting: event.value\n        // Add other detector-specific parameters here\n      };\n    };\n    eventList.forEach(deviceEventList => {\n      if (!deviceEventList.length) return;\n      const targetId = deviceEventList[0].target;\n      const deviceNode = nodes.find(node => node.id === targetId);\n      if (!deviceNode || !deviceNode.data) {\n        console.error(`Device node or data not found for ID: ${targetId}`);\n        return;\n      }\n      const deviceEvents = deviceEventList.map(event => {\n        switch (event.type) {\n          case 'setPumpSpeed':\n            return convertPumpEvent(event, deviceNode.data.properties);\n          case 'setThermostatTemperature':\n            return convertThermostatEvent(event, deviceNode.data.properties);\n          case 'setLedIntensity':\n            return convertLedEvent(event, deviceNode.data.properties);\n          case 'setDetectorSetting':\n            return convertDetectorEvent(event, deviceNode.data.properties);\n          default:\n            console.warn(`Unknown event type: ${event.type}`);\n            return null;\n        }\n      }).filter(Boolean); // Remove any null events\n\n      if (deviceEvents.length > 0) {\n        deviceEventMap.set(targetId, deviceEvents);\n      }\n    });\n    console.log('deviceEventMap: ', Array.from(deviceEventMap.values()));\n    return Array.from(deviceEventMap.values());\n  };\n  const generateEventList = blocks => {\n    // Early exit if blocks array is invalid\n    if (!blocks || !Array.isArray(blocks) || blocks.length === 0) {\n      console.warn('No valid blocks found for event generation');\n      return [];\n    }\n    const orderedNodes = orderNodesByDistance(findOutletNode(graphData.nodes), graphData.nodes, graphData.links);\n    console.log('orderedNodes: ', orderedNodes);\n\n    // Early exit if no ordered nodes\n    if (!orderedNodes || orderedNodes.length === 0) {\n      console.warn('No ordered nodes found for event generation');\n      return [];\n    }\n    let eventList = [];\n    let dropletSnapshot = [];\n\n    // Validate block droplets\n    if (!blocks[0] || !blocks[0].droplets || !Array.isArray(blocks[0].droplets) || blocks[0].droplets.length === 0) {\n      console.warn('No valid droplets found in blocks for event generation');\n      return [];\n    }\n    const i = 0;\n    const currentBlockDroplets = blocks[i].droplets;\n\n    // Add fallback for volumetricSpeed in case it's not found\n    const dropletWithParams = currentBlockDroplets.find(d => d && d.parameters && Array.isArray(d.parameters));\n    if (!dropletWithParams) {\n      console.warn('No droplet with valid parameters found');\n      return [];\n    }\n\n    // Make sure we can find the volumetricSpeed parameter or use a default\n    const volumetricSpeedParam = dropletWithParams.parameters.find(p => p && p.name === 'volumetricSpeed');\n    const commonVolumetricSpeed = (volumetricSpeedParam === null || volumetricSpeedParam === void 0 ? void 0 : volumetricSpeedParam.value) || 1;\n    console.log('Using volumetricSpeed:', commonVolumetricSpeed);\n\n    //adds some parameters to nodes\n    orderedNodes.forEach(node => {\n      node.inletVolumetricSpeed = commonVolumetricSpeed;\n      node.outletVolumetricSpeed = commonVolumetricSpeed;\n      const pump = findConnectedPump(node.node.id, graphData.nodes, graphData.links);\n      if (pump) {\n        node.connectedPump = pump;\n      } else {\n        node.connectedPump = 0;\n      }\n      node.connectedPumpRatio = 0;\n      node.connectedPumpSpeedAtPause = 0;\n      node.pumpSpeedMultiplier = 1;\n      //node.requestedRatio = 0;\n      node.pauseLevel = 0;\n    });\n    //ustawia carrier pump na odpowiednią predkość\n    const carrierPumpConnector = graphData.links.find(link => link.source === selectedCarrierPumps[0]).target;\n    if (carrierPumpConnector) {\n      const connectorNode = orderedNodes.find(node => node.node.id === carrierPumpConnector);\n      connectorNode.inletVolumetricSpeed = commonVolumetricSpeed;\n      connectorNode.outletVolumetricSpeed = commonVolumetricSpeed;\n      connectorNode.connectedPump = graphData.nodes.find(node => node.id === selectedCarrierPumps[0]);\n      connectorNode.connectedPumpRatio = 1;\n      connectorNode.connectedPumpSpeedAtPause = commonVolumetricSpeed;\n      //connectorNode.requestedRatio = 0;\n      connectorNode.pauseLevel = 0;\n    }\n    let event = {\n      //it is ok\n      type: 'setPumpSpeed',\n      target: selectedCarrierPumps[0],\n      time: 0,\n      value: commonVolumetricSpeed\n    };\n    eventList.push(event);\n    orderedNodes.filter(node => node.node.type === 'pump' && node.node.id !== selectedCarrierPumps[0]).forEach(pump => {\n      event = {\n        //it is ok\n        type: 'setPumpSpeed',\n        target: pump.node.id,\n        time: 0,\n        value: 0\n      };\n      eventList.push(event);\n    });\n    let position = -0.001;\n    //prepares all droplets in block and calculates some parameters\n    currentBlockDroplets.forEach(droplet => {\n      var _droplet$parameters$f6, _droplet$parameters$f7;\n      const prefixVolume = (_droplet$parameters$f6 = droplet.parameters.find(p => p.name === 'prefixVolume')) === null || _droplet$parameters$f6 === void 0 ? void 0 : _droplet$parameters$f6.value;\n      const surfixVolume = (_droplet$parameters$f7 = droplet.parameters.find(p => p.name === 'surfixVolume')) === null || _droplet$parameters$f7 === void 0 ? void 0 : _droplet$parameters$f7.value;\n      droplet.frontVolumetricSpeed = commonVolumetricSpeed;\n      droplet.rearVolumetricSpeed = commonVolumetricSpeed;\n      droplet.frontVolumetricPosition = position - prefixVolume;\n      droplet.rearVolumetricPosition = droplet.frontVolumetricPosition;\n      droplet.frontVolumetricDistanceToNextNode = Math.abs(droplet.frontVolumetricPosition);\n      droplet.rearVolumetricDistanceToNextNode = Math.abs(droplet.rearVolumetricPosition);\n      droplet.frontTimeToReachNextNode = 0;\n      droplet.rearTimeToReachNextNode = 0;\n      droplet.frontNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\n      droplet.rearNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\n      droplet.pumpSpeedMultiplier = 1;\n      droplet.pauseLevel = 0;\n      droplet.frontVolumetricSpeedAtPause = 0;\n      droplet.rearVolumetricSpeedAtPause = 0;\n      droplet.stoppingDroplet = false;\n      droplet.initialPumping = false;\n      position -= prefixVolume + surfixVolume;\n    });\n    console.log('findFurthestNode: ', findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id);\n    console.log('Droplet positions initialized, nodes ready');\n    let lastDropletRearPosition = currentBlockDroplets[currentBlockDroplets.length - 1].rearVolumetricPosition;\n    let outletNodePosition = orderedNodes[0].node.volumetricPosition;\n    let timePassed = 0; //in s\n    let newTimePassed = 0;\n\n    // Simulate the movement of droplets in the current block\n    currentBlockDroplets.forEach(droplet => {\n      droplet.frontTimeToReachNextNode = Math.abs(droplet.frontVolumetricDistanceToNextNode / droplet.frontVolumetricSpeed);\n      droplet.rearTimeToReachNextNode = Math.abs(droplet.rearVolumetricDistanceToNextNode / droplet.rearVolumetricSpeed);\n    });\n    while (lastDropletRearPosition < outletNodePosition) {\n      let smallestFrontTime = Infinity;\n      let smallestRearTime = Infinity;\n      let smallestFrontTimeDroplet = [];\n      let smallestRearTimeDroplet = [];\n      currentBlockDroplets.forEach(droplet => {\n        // Update the smallest front and rear times and associated droplet(s) based on the current droplet's front and rear times to reach the next node.\n\n        if (Math.abs(droplet.frontTimeToReachNextNode) < smallestFrontTime) {\n          smallestFrontTime = Math.abs(droplet.frontTimeToReachNextNode);\n          smallestFrontTimeDroplet = [droplet];\n        } else if (Math.abs(droplet.frontTimeToReachNextNode) === smallestFrontTime) {\n          smallestFrontTimeDroplet.push(droplet);\n        }\n        if (Math.abs(droplet.rearTimeToReachNextNode) < smallestRearTime) {\n          smallestRearTime = Math.abs(droplet.rearTimeToReachNextNode);\n          smallestRearTimeDroplet = [droplet];\n        } else if (Math.abs(droplet.rearTimeToReachNextNode) === smallestRearTime) {\n          smallestRearTimeDroplet.push(droplet);\n        }\n      });\n      newTimePassed += Math.min(Math.abs(smallestFrontTime), Math.abs(smallestRearTime));\n      if (smallestFrontTime === smallestRearTime) {\n        //przypadek w ktorym wiele kropel ma ten sam czas do przejścia do nastepnego noda, rzadki\n\n        if (smallestFrontTimeDroplet.length > 1 || smallestRearTimeDroplet.length > 1) {\n          //sprawdź czy wśród nich jest kropla z rear i front\n          console.log('Multiple droplets have reached the next node simultaneously');\n          console.log('smallestFrontTimeDroplet: ', smallestFrontTimeDroplet);\n          console.log('smallestRearTimeDroplet: ', smallestRearTimeDroplet);\n        } else if (smallestFrontTimeDroplet[0] === smallestRearTimeDroplet[0]) {\n          //przypadek gdy kropla ma 0 objętości\n          console.log('Both front and rear times are for the same droplet');\n          const reachedNode = orderedNodes.find(n => n.node.id === smallestFrontTimeDroplet[0].frontNextNodeID);\n          const reachedNodeDistance = orderedNodes.find(node => node.node.id === reachedNode.node.id).distance;\n          if (reachedNode.node.type === 'connector') {\n            const index = currentBlockDroplets.indexOf(smallestFrontTimeDroplet[0]);\n            const dropletsOlder = currentBlockDroplets.slice(0, index);\n            const dropletsNewer = currentBlockDroplets.slice(index + 1);\n            const ds = [];\n            ds.drops = JSON.parse(JSON.stringify(dropletsNewer)); // Create deep copy\n            ds.snappedNode = smallestFrontTimeDroplet[0].frontNextNodeID;\n            const existingSnapshotIndex = dropletSnapshot.findIndex(snapshot => snapshot.snappedNode === ds.snappedNode);\n            if (existingSnapshotIndex !== -1) {\n              dropletSnapshot[existingSnapshotIndex] = ds;\n            } else {\n              dropletSnapshot.push(ds);\n            }\n\n            //aktualizuje starsze krople\n            dropletsOlder.forEach(droplet => {\n              droplet.frontTimeToReachNextNode -= smallestFrontTime;\n              droplet.rearTimeToReachNextNode -= smallestFrontTime;\n              droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n              droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n              droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n              droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n            });\n\n            //aktualizuje kroplę\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n            const nextEdge = graphData.links.find(link => link.source === smallestFrontTimeDroplet[0].frontNextNodeID && link.target === nextNode.node.id);\n            if (reachedNode.connectedPump !== null) {\n              var _smallestFrontTimeDro, _smallestFrontTimeDro2;\n              const pumpRatio = ((_smallestFrontTimeDro = smallestFrontTimeDroplet[0].parameters.find(param => param.nodeId === reachedNode.connectedPump.id && param.name === 'ratio')) === null || _smallestFrontTimeDro === void 0 ? void 0 : _smallestFrontTimeDro.value) || 0;\n              const dropletDesiredVolume = ((_smallestFrontTimeDro2 = smallestFrontTimeDroplet[0].parameters.find(param => param.name === 'volume')) === null || _smallestFrontTimeDro2 === void 0 ? void 0 : _smallestFrontTimeDro2.value) || 0;\n              reachedNode.connectedPumpRatio = pumpRatio;\n              //reachedNode.inletVolumetricSpeed = 0;\n              //smallestFrontTimeDroplet[0].frontVolumetricSpeed = reachedNode.outletVolumetricSpeed;\n              smallestFrontTimeDroplet[0].frontVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              smallestFrontTimeDroplet[0].rearVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].rearVolumetricSpeed;\n              smallestFrontTimeDroplet[0].rearVolumetricSpeed = 0;\n              smallestFrontTimeDroplet[0].frontVolumetricPosition = reachedNode.node.volumetricPosition;\n              smallestFrontTimeDroplet[0].rearVolumetricPosition = reachedNode.node.volumetricPosition;\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n              smallestFrontTimeDroplet[0].rearVolumetricDistanceToNextNode = 0;\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              smallestFrontTimeDroplet[0].rearTimeToReachNextNode = dropletDesiredVolume * pumpRatio / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\n              //smallestFrontTimeDroplet[0].rearNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\n              smallestFrontTimeDroplet[0].pumpSpeedMultiplier = 1;\n              //smallestFrontTimeDroplet[0].pauseLevel = 0;\n              smallestFrontTimeDroplet[0].stoppingDroplet = true;\n              smallestFrontTimeDroplet[0].initialPumping = true;\n              if (reachedNode.connectedPump.id !== selectedCarrierPumps[0]) {\n                event = {\n                  type: 'setPumpSpeed',\n                  target: reachedNode.connectedPump.id,\n                  time: newTimePassed,\n                  value: smallestFrontTimeDroplet[0].frontVolumetricSpeed\n                };\n                eventList.push(event);\n              }\n\n              //update newer droplets\n              dropletsNewer.forEach(droplet => {\n                droplet.pauseLevel += 1;\n                if (droplet.pauseLevel === 1) {\n                  droplet.frontVolumetricSpeedAtPause = droplet.frontVolumetricSpeed;\n                  if (droplet.stoppingDroplet !== true) {\n                    droplet.rearVolumetricSpeedAtPause = droplet.rearVolumetricSpeed;\n                  }\n                }\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricSpeed = 0;\n                droplet.rearVolumetricSpeed = 0;\n                droplet.frontTimeToReachNextNode += smallestFrontTimeDroplet[0].rearTimeToReachNextNode - smallestFrontTime;\n                droplet.rearTimeToReachNextNode += smallestFrontTimeDroplet[0].rearTimeToReachNextNode - smallestFrontTime;\n              });\n              getPumpsBetweenPositions(smallestFrontTimeDroplet[0].frontVolumetricPosition, -1, graphData.nodes, graphData.links).filter(pump => pump.id !== reachedNode.connectedPump.id).forEach(pump => {\n                event = {\n                  type: 'setPumpSpeed',\n                  target: pump.id,\n                  time: newTimePassed,\n                  value: 0\n                };\n                eventList.push(event);\n              });\n            }\n          } else if (reachedNode.type === 'thermostat' || reachedNode.type === 'LED') {\n            console.log('reachedNode is thermostat');\n          } else if (reachedNode.type === 'outlet') {\n            console.log('reachedNode is outlet');\n          } else if (reachedNode.type === 'detector' || reachedNode.type === 'USBSpectrometer' || reachedNode.type === 'MQTTSpectrometer') {\n            console.log('reachedNode is detector');\n          }\n        } else {\n          console.log('Front and rear times are for different droplets');\n        }\n      } else if (smallestFrontTime < smallestRearTime) {\n        //przypadek gdzie przód jest przed tyłem\n        console.log('Front time is smaller than rear time');\n        if (smallestFrontTimeDroplet.length > 1) {\n          console.log(`Multiple droplets have reached the next node simultaneously`);\n          smallestFrontTimeDroplet.forEach(droplet => {\n            // Perform some action for each droplet in smallestFrontTimeDroplet\n          });\n        } else {\n          //przypadek gdy przód jednej kropelki dochodzi do noda\n          console.log(`Single droplet front has reached the next node`);\n          const reachedNode = orderedNodes.find(n => n.node.id === smallestFrontTimeDroplet[0].frontNextNodeID);\n          const reachedNodeDistance = orderedNodes.find(node => node.node.id === reachedNode.node.id).distance;\n          if (reachedNode.node.type === 'connector') {\n            //przypadek gdy dochodzi do connectora\n            console.log('reachedNode is connector');\n            const index = currentBlockDroplets.indexOf(smallestFrontTimeDroplet[0]);\n            const dropletsOlder = currentBlockDroplets.slice(0, index);\n            const dropletsNewer = currentBlockDroplets.slice(index + 1);\n\n            //aktualizuje kroplę\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n            const nextEdge = graphData.links.find(link => link.source === reachedNode.node.id && link.target === nextNode.node.id);\n            if (reachedNode.connectedPump.id !== null) {\n              var _smallestFrontTimeDro3, _smallestFrontTimeDro4;\n              const pumpRatio = ((_smallestFrontTimeDro3 = smallestFrontTimeDroplet[0].parameters.find(param => param.nodeId === reachedNode.connectedPump.id && param.name === 'ratio')) === null || _smallestFrontTimeDro3 === void 0 ? void 0 : _smallestFrontTimeDro3.value) || 0;\n              const dropletDesiredVolume = ((_smallestFrontTimeDro4 = smallestFrontTimeDroplet[0].parameters.find(param => param.name === 'volume')) === null || _smallestFrontTimeDro4 === void 0 ? void 0 : _smallestFrontTimeDro4.value) || 0;\n              smallestFrontTimeDroplet[0].frontVolumetricPosition = reachedNode.node.volumetricPosition;\n              smallestFrontTimeDroplet[0].rearVolumetricPosition += smallestFrontTime * smallestFrontTimeDroplet[0].rearVolumetricSpeed;\n              smallestFrontTimeDroplet[0].actualVolume = smallestFrontTimeDroplet[0].frontVolumetricPosition - smallestFrontTimeDroplet[0].rearVolumetricPosition;\n              reachedNode.inletVolumetricSpeed = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              reachedNode.connectedPumpRatio = pumpRatio;\n              smallestFrontTimeDroplet[0].rearTimeToReachNextNode -= smallestFrontTime;\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n              smallestFrontTimeDroplet[0].rearVolumetricDistanceToNextNode -= smallestFrontTime * smallestFrontTimeDroplet[0].rearVolumetricSpeed;\n              if (smallestFrontTimeDroplet[0].initialPumping === true) {\n                //przypadek gdy kropla jest w pierwszej fazie pompowania (od 0uL)\n                console.log('Kropla jest w pierwszej fazie pompowania');\n                //smallestFrontTimeDroplet[0].initialPumping = false;\n                const rearTimeLeft = smallestFrontTimeDroplet[0].rearTimeToReachNextNode;\n                const totalTimeLeft = rearTimeLeft + smallestFrontTimeDroplet[0].actualVolume / commonVolumetricSpeed;\n                console.log('commonVolumetricSpeed: ', commonVolumetricSpeed);\n                console.log('smallestFrontTimeDroplet[0].actualVolume: ', smallestFrontTimeDroplet[0].actualVolume);\n                console.log('rearTimeLeft: ', rearTimeLeft);\n                console.log('totalTimeLeft: ', totalTimeLeft);\n                const thispumpspeed = pumpRatio * dropletDesiredVolume / totalTimeLeft;\n                console.log('thispumpspeed: ', thispumpspeed);\n                reachedNode.connectedPumpSpeedAtPause = thispumpspeed;\n              } else {\n                console.log('Normalne pompowanie');\n                reachedNode.connectedPumpSpeedAtPause = dropletDesiredVolume * pumpRatio / (smallestFrontTimeDroplet[0].actualVolume / reachedNode.inletVolumetricSpeed);\n              }\n              reachedNode.outletVolumetricSpeed = reachedNode.inletVolumetricSpeed + reachedNode.connectedPumpSpeedAtPause;\n              smallestFrontTimeDroplet[0].frontVolumetricSpeed += reachedNode.connectedPumpSpeedAtPause;\n              //smallestFrontTimeDroplet[0].rearVolumetricSpeed = 0;\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\n              //smallestFrontTimeDroplet[0].rearNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\n              //smallestFrontTimeDroplet[0].pumpSpeedMultiplier = 1;\n              //smallestFrontTimeDroplet[0].pauseLevel = 0;\n              //smallestFrontTimeDroplet[0].frontVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              //smallestFrontTimeDroplet[0].rearVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              //smallestFrontTimeDroplet[0].stoppingDroplet = true;\n              event = {\n                type: 'setPumpSpeed',\n                target: reachedNode.connectedPump.id,\n                time: newTimePassed,\n                value: reachedNode.connectedPumpSpeedAtPause\n              };\n              eventList.push(event);\n              //update newer droplets\n              dropletsNewer.forEach(droplet => {\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontTimeToReachNextNode -= smallestFrontTime;\n                droplet.rearTimeToReachNextNode -= smallestFrontTime;\n              });\n              //aktualizuje starsze krople\n              let accumulatedSpeed = reachedNode.connectedPumpSpeedAtPause;\n              dropletsOlder.reverse().forEach(droplet => {\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.rearVolumetricSpeed += accumulatedSpeed;\n                getPumpsBetweenPositions(droplet.frontVolumetricPosition, droplet.rearVolumetricPosition, graphData.nodes, graphData.links).forEach(pump => {\n                  const editedNode = orderedNodes.find(node => node.connectedPump.id === pump.id);\n                  //editedNode.pumpSpeedMultiplier = 1;\n                  const pumpBoost = editedNode.connectedPumpSpeedAtPause * accumulatedSpeed / editedNode.inletVolumetricSpeed;\n                  editedNode.connectedPumpSpeedAtPause += pumpBoost;\n                  editedNode.inletVolumetricSpeed += accumulatedSpeed;\n                  accumulatedSpeed += pumpBoost;\n                  editedNode.outletVolumetricSpeed += accumulatedSpeed;\n                  event = {\n                    type: 'setPumpSpeed',\n                    target: pump.id,\n                    time: newTimePassed,\n                    value: editedNode.connectedPumpSpeedAtPause\n                  };\n                  eventList.push(event);\n                });\n                droplet.frontVolumetricSpeed += accumulatedSpeed;\n                droplet.frontTimeToReachNextNode = droplet.frontVolumetricDistanceToNextNode / droplet.frontVolumetricSpeed;\n                droplet.rearTimeToReachNextNode = droplet.rearVolumetricDistanceToNextNode / droplet.rearVolumetricSpeed;\n              });\n            }\n          } else if (reachedNode.node.type === 'thermostat' || reachedNode.type === 'LED') {\n            //przypadek gdy dochodzi do termostatu\n            console.log('reachedNode (thermostat, LED): ', reachedNode);\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n            if (nextNode) {\n              const nextEdge = graphData.links.find(link => link.source === smallestFrontTimeDroplet[0].frontNextNodeID && link.target === nextNode.node.id);\n              //aktualizuje krople\n              currentBlockDroplets.forEach(droplet => {\n                droplet.frontTimeToReachNextNode -= smallestFrontTime;\n                droplet.rearTimeToReachNextNode -= smallestFrontTime;\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n              });\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\n            }\n          } else if (reachedNode.node.type === 'outlet') {\n            //jeśli ostatni node osiągnięty\n            console.log('reachedNode (outlet): ', reachedNode);\n            //typowe zaktualizowanie czasu do następnego noda dla reszty kropel i zestallowanie frontu\n            currentBlockDroplets.forEach(droplet => {\n              droplet.frontTimeToReachNextNode -= smallestFrontTime;\n              droplet.rearTimeToReachNextNode -= smallestFrontTime;\n              droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n              droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n              droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n              droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n            });\n            smallestFrontTimeDroplet[0].frontTimeToReachNextNode = Infinity;\n            smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = Infinity;\n            smallestFrontTimeDroplet[0].frontNextNodeID = null;\n          } else if (reachedNode.node.type === 'detector' || reachedNode.node.type === 'USBSpectrometer' || reachedNode.node.type === 'MQTTSpectrometer') {\n            //przypadek gdy dochodzi do detektora\n            console.log('reachedNode (detector): ', reachedNode);\n            const waitTime = reachedNode.node.properties.find(property => property.name === 'wait time').value;\n            const measurementTime = reachedNode.node.properties.find(property => property.name === 'measurement time').value;\n\n            // Create detector measurement end event when droplet front reaches detector\n            event = {\n              type: 'setDetectorMeasurement',\n              target: reachedNode.node.id,\n              time: newTimePassed + waitTime,\n              value: 1\n            };\n            eventList.push(event);\n\n            // Add events to set pump speeds before and after measurement\n            graphData.nodes.forEach(node => {\n              if (node.type === 'pump') {\n                const currentSpeed = getPumpSpeedAtTime(node.id, pumpEvents, currentTime);\n                event = {\n                  type: 'setPumpSpeed',\n                  target: node.id,\n                  time: newTimePassed + waitTime + measurementTime,\n                  value: currentSpeed\n                };\n                eventList.push(event);\n                event = {\n                  type: 'setPumpSpeed',\n                  target: node.id,\n                  time: newTimePassed,\n                  value: 0\n                };\n                eventList.push(event);\n              }\n            });\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n            if (nextNode) {\n              const nextEdge = graphData.links.find(link => link.source === smallestFrontTimeDroplet[0].frontNextNodeID && link.target === nextNode.node.id);\n              //aktualizuje krople\n              currentBlockDroplets.forEach(droplet => {\n                droplet.frontTimeToReachNextNode -= smallestFrontTime - (measurementTime + waitTime);\n                droplet.rearTimeToReachNextNode -= smallestFrontTime - (measurementTime + waitTime);\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n              });\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestFrontTimeDroplet[0].frontVolumetricSpeed + (measurementTime + waitTime);\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\n            }\n          }\n        }\n      } else {\n        //przypadek gdzie tył jest przed przodem\n        console.log('Rear time is smaller than front time');\n        if (smallestRearTimeDroplet.length > 1) {\n          //przypadek gdy dochodzi do noda wiele kropel\n          console.log(`Multiple droplets ends have reached the next node simultaneously`);\n          smallestRearTimeDroplet.forEach(droplet => {\n            // Perform some action for each droplet in smallestRearTimeDroplet\n          });\n        } else {\n          //przypadek gdy tył jednej kropelki dochodzi do noda\n          const reachedNode = orderedNodes.find(n => n.node.id === smallestRearTimeDroplet[0].rearNextNodeID);\n          const reachedNodeDistance = orderedNodes.find(node => node.node.id === reachedNode.node.id).distance;\n          if (reachedNode.node.type === 'connector') {\n            //przypadek gdy dochodzi do connectora\n            console.log('reachedNode is connector');\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n            const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\n            const index = currentBlockDroplets.indexOf(smallestRearTimeDroplet[0]);\n            const dropletsOlder = currentBlockDroplets.slice(0, index);\n            const dropletsNewer = currentBlockDroplets.slice(index + 1);\n            if (smallestRearTimeDroplet[0].stoppingDroplet === true) {\n              //wznawia jeśli była zatrzymana\n              //aktualizuje starsze krople\n              dropletsOlder.forEach(droplet => {\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\n                droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n              });\n\n              //aktualizuje nowsze krople\n              dropletsNewer.forEach(droplet => {\n                if (droplet.pauseLevel === 1) {\n                  //\n                  droplet.pauseLevel = 0;\n                  droplet.frontVolumetricSpeed = droplet.frontVolumetricSpeedAtPause;\n                  droplet.rearVolumetricSpeed = droplet.rearVolumetricSpeedAtPause;\n                  getPumpsBetweenPositions(droplet.frontVolumetricPosition, droplet.rearVolumetricPosition, graphData.nodes, graphData.links).forEach(pump => {\n                    event = {\n                      type: 'setPumpSpeed',\n                      target: pump.id,\n                      time: newTimePassed,\n                      value: orderedNodes.find(node => node.node.id === pump.id).connectedPumpSpeedAtPause\n                    };\n                    eventList.push(event);\n                  });\n                } else {\n                  droplet.pauseLevel -= 1;\n                }\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\n              });\n              reachedNode.connectedPumpRatio = 0;\n              //reachedNode.inletVolumetricSpeed = 0;\n              //smallestRearTimeDroplet[0].frontVolumetricSpeed = reachedNode.outletVolumetricSpeed;\n              smallestRearTimeDroplet[0].rearVolumetricSpeed = smallestRearTimeDroplet[0].rearVolumetricSpeedAtPause;\n              smallestRearTimeDroplet[0].frontVolumetricPosition += smallestRearTimeDroplet[0].frontVolumetricSpeed * smallestRearTime;\n              smallestRearTimeDroplet[0].rearVolumetricPosition = reachedNode.node.volumetricPosition;\n              smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode -= smallestRearTimeDroplet[0].frontVolumetricSpeed * smallestRearTime;\n              smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n              smallestRearTimeDroplet[0].frontTimeToReachNextNode = smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].frontVolumetricSpeed;\n              smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\n              //smallestRearTimeDroplet[0].frontNextNodeID = nextNode.id;\n              smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\n              //smallestRearTimeDroplet[0].pumpSpeedMultiplier = 1;\n              //smallestRearTimeDroplet[0].pauseLevel = 0;\n              smallestRearTimeDroplet[0].frontVolumetricSpeedAtPause = smallestRearTimeDroplet[0].frontVolumetricSpeed;\n              smallestRearTimeDroplet[0].rearVolumetricSpeedAtPause = smallestRearTimeDroplet[0].rearVolumetricSpeed;\n              smallestRearTimeDroplet[0].stoppingDroplet = false;\n              smallestRearTimeDroplet[0].initialPumping = false;\n              reachedNode.connectedPumpRatio = 0;\n              event = {\n                type: 'setPumpSpeed',\n                target: reachedNode.connectedPump.id,\n                time: newTimePassed,\n                value: 0\n              };\n              eventList.push(event);\n              event = {\n                type: 'setPumpSpeed',\n                target: selectedCarrierPumps[0],\n                time: newTimePassed,\n                value: commonVolumetricSpeed\n              };\n              eventList.push(event);\n            } else {\n              console.log('it is not stopper');\n              if (reachedNode.connectedPump.id !== null) {\n                const speedDifference = reachedNode.outletVolumetricSpeed - reachedNode.inletVolumetricSpeed;\n                //reachedNode.inletVolumetricSpeed = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n                reachedNode.outletVolumetricSpeed = reachedNode.inletVolumetricSpeed;\n                reachedNode.connectedPumpRatio = 0;\n                reachedNode.connectedPumpSpeedAtPause = 0;\n                smallestRearTimeDroplet[0].frontVolumetricPosition += smallestRearTime * smallestRearTimeDroplet[0].frontVolumetricSpeed;\n                smallestRearTimeDroplet[0].rearVolumetricPosition = reachedNode.node.volumetricPosition;\n                smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode -= smallestRearTime * smallestRearTimeDroplet[0].frontVolumetricSpeed;\n                smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n                //smallestRearTimeDroplet[0].frontNextNodeID = nextNode.id;\n                smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\n                //smallestRearTimeDroplet[0].pumpSpeedMultiplier = 1;\n                //smallestRearTimeDroplet[0].pauseLevel = 0; \n                //smallestRearTimeDroplet[0].stoppingDroplet = true;\n                smallestRearTimeDroplet[0].frontVolumetricSpeed = smallestRearTimeDroplet[0].frontVolumetricSpeed - speedDifference;\n                //smallestRearTimeDroplet[0].rearVolumetricSpeed = 0;\n                smallestRearTimeDroplet[0].frontVolumetricSpeedAtPause = smallestRearTimeDroplet[0].frontVolumetricSpeed;\n                //smallestRearTimeDroplet[0].rearVolumetricSpeedAtPause = smallestRearTimeDroplet[0].rearVolumetricSpeed;\n                smallestRearTimeDroplet[0].frontTimeToReachNextNode = smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].frontVolumetricSpeed;\n                smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\n                event = {\n                  type: 'setPumpSpeed',\n                  target: reachedNode.connectedPump.id,\n                  time: newTimePassed,\n                  value: reachedNode.connectedPumpSpeedAtPause\n                };\n                eventList.push(event);\n                //updte newer droplets\n                dropletsNewer.forEach(droplet => {\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                  droplet.frontTimeToReachNextNode -= smallestRearTime;\n                  droplet.rearTimeToReachNextNode -= smallestRearTime;\n                });\n                //aktualizuje starsze krople\n                let accumulatedSpeedDecrease = speedDifference;\n                dropletsOlder.reverse().forEach(droplet => {\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                  droplet.rearVolumetricSpeed -= accumulatedSpeedDecrease;\n                  getPumpsBetweenPositions(droplet.frontVolumetricPosition, droplet.rearVolumetricPosition, graphData.nodes, graphData.links).forEach(pump => {\n                    const editedNode = orderedNodes.find(node => node.connectedPump.id === pump.id);\n                    const pumpBreak = editedNode.connectedPumpSpeedAtPause * accumulatedSpeedDecrease / editedNode.inletVolumetricSpeed;\n                    editedNode.connectedPumpSpeedAtPause -= pumpBreak;\n                    editedNode.inletVolumetricSpeed -= accumulatedSpeedDecrease;\n                    accumulatedSpeedDecrease += pumpBreak;\n                    editedNode.outletVolumetricSpeed -= accumulatedSpeedDecrease;\n                    event = {\n                      type: 'setPumpSpeed',\n                      target: pump.id,\n                      time: newTimePassed,\n                      value: editedNode.connectedPumpSpeedAtPause\n                    };\n                    eventList.push(event);\n                  });\n                  droplet.frontVolumetricSpeed -= accumulatedSpeedDecrease;\n                  droplet.frontTimeToReachNextNode = droplet.frontVolumetricDistanceToNextNode / droplet.frontVolumetricSpeed;\n                  droplet.rearTimeToReachNextNode = droplet.rearVolumetricDistanceToNextNode / droplet.rearVolumetricSpeed;\n                });\n              }\n            }\n          } else if (reachedNode.node.type === 'thermostat' || reachedNode.node.type === 'LED') {\n            //przypadek gdy dochodzi do termostatu\n            console.log('reachedNode thermostat: ', reachedNode);\n            const isFarthestThermostatOrLED = orderedNodes.filter(node => node.node.type === 'thermostat' || node.node.type === 'LED').every(node => node.distance <= reachedNodeDistance);\n\n            // This line checks if the smallestRearTimeDroplet is the last droplet in the currentBlockDroplets array.\n            if (isFarthestThermostatOrLED && currentBlockDroplets.length === currentBlockDroplets.indexOf(smallestRearTimeDroplet[0]) + 1) {\n              var _smallestRearTimeDrop;\n              console.log('This is the farthest thermostat or LED node. Also, last droplet just passed through it.');\n              const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n              const waitTime = ((_smallestRearTimeDrop = smallestRearTimeDroplet[0].parameters.find(param => param.nodeId === reachedNode.node.id && param.name === 'time')) === null || _smallestRearTimeDrop === void 0 ? void 0 : _smallestRearTimeDrop.value) || 0;\n              if (nextNode) {\n                const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\n                smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n                smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed + smallestRearTime;\n                smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\n                //aktualizuje resztę kropli\n                currentBlockDroplets.forEach(droplet => {\n                  droplet.frontTimeToReachNextNode += waitTime - smallestRearTime;\n                  droplet.rearTimeToReachNextNode += waitTime - smallestRearTime;\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed - waitTime * droplet.frontVolumetricSpeed; //to jest zrobione na razie aby czas się zgadzał\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed - waitTime * droplet.rearVolumetricSpeed;\n                });\n                let carrierPumpEvent = {\n                  type: 'setPumpSpeed',\n                  target: selectedCarrierPumps[0],\n                  // Assuming 'carrierPumpId' is the ID of the carrier pump\n                  time: newTimePassed,\n                  value: 0\n                };\n                eventList.push(carrierPumpEvent);\n                carrierPumpEvent = {\n                  type: 'setPumpSpeed',\n                  target: selectedCarrierPumps[0],\n                  // Assuming 'carrierPumpId' is the ID of the carrier pump\n                  time: newTimePassed + waitTime,\n                  value: commonVolumetricSpeed\n                };\n                eventList.push(carrierPumpEvent);\n              }\n            } else {\n              //droplet wasnt the last one\n              console.log('smallestRearTimeDroplet is not the last droplet in the currentBlockDroplets array');\n              const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n              if (nextNode) {\n                const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\n                //aktualizuje krople\n                currentBlockDroplets.forEach(droplet => {\n                  droplet.frontTimeToReachNextNode -= smallestRearTime;\n                  droplet.rearTimeToReachNextNode -= smallestRearTime;\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n                });\n                smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n                smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\n                smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\n              }\n            }\n          } else if (reachedNode.node.type === 'outlet') {\n            //jeśli ostatni node osiągnięty\n            //typowe zaktualizowanie czasu do następnego noda dla reszty kropel i zestallowanie reara\n            //aktualizuje resztę kropli\n            currentBlockDroplets.forEach(droplet => {\n              droplet.frontTimeToReachNextNode -= smallestRearTime;\n              droplet.rearTimeToReachNextNode -= smallestRearTime;\n              droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n              droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n              droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n              droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n            });\n            smallestRearTimeDroplet[0].frontTimeToReachNextNode = Infinity;\n            smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode = Infinity;\n            smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = Infinity;\n            smallestRearTimeDroplet[0].rearNextNodeID = null;\n            smallestRearTimeDroplet[0].rearTimeToReachNextNode = Infinity;\n          } else if (reachedNode.node.type === 'detector' || reachedNode.node.type === 'USBSpectrometer' || reachedNode.node.type === 'MQTTSpectrometer') {\n            //przypadek gdy dochodzi do detektora\n            console.log('reachedNode (detector): ', reachedNode);\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n            if (nextNode) {\n              const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\n              //aktualizuje krople\n              currentBlockDroplets.forEach(droplet => {\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\n                droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n              });\n              smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n              smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\n              smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\n            }\n          }\n        }\n      }\n      timePassed = newTimePassed;\n      // Update last droplet rear position\n      lastDropletRearPosition = currentBlockDroplets[currentBlockDroplets.length - 1].rearVolumetricPosition;\n\n      //add code that preserves droplets positions and speeds for visualization\n      const dropletState = {\n        time: timePassed,\n        droplets: currentBlockDroplets.map(droplet => {\n          var _droplet$parameters$f8;\n          return {\n            id: droplet.id,\n            frontVolumetricPosition: droplet.frontVolumetricPosition,\n            rearVolumetricPosition: droplet.rearVolumetricPosition,\n            frontVolumetricSpeed: droplet.frontVolumetricSpeed,\n            rearVolumetricSpeed: droplet.rearVolumetricSpeed,\n            pumpSpeedMultiplier: droplet.pumpSpeedMultiplier,\n            frontTimeToReachNextNode: droplet.frontTimeToReachNextNode,\n            rearTimeToReachNextNode: droplet.rearTimeToReachNextNode,\n            frontVolumetricDistanceToNextNode: droplet.frontVolumetricDistanceToNextNode,\n            rearVolumetricDistanceToNextNode: droplet.rearVolumetricDistanceToNextNode,\n            volume: ((_droplet$parameters$f8 = droplet.parameters.find(p => p.name === 'volume')) === null || _droplet$parameters$f8 === void 0 ? void 0 : _droplet$parameters$f8.value) || 0,\n            frontNextNodeID: droplet.frontNextNodeID,\n            rearNextNodeID: droplet.rearNextNodeID\n          };\n        })\n      };\n      setDropletHistory(prev => [...prev, dropletState]);\n\n      //if (timePassed > 9999) {//here for testing, preventing infinite loop\n      //  lastDropletRearPosition = 88100;\n      //}\n    }\n    event = {\n      //it is ok\n      type: 'setPumpSpeed',\n      target: selectedCarrierPumps[0],\n      time: timePassed,\n      value: 0\n    };\n    eventList.push(event);\n    eventList = cleanAndSortEventList(eventList);\n    console.log('dropletHistory in event generator: ', dropletHistory);\n    console.log('eventList: ', eventList.sort((a, b) => a.time - b.time));\n    setPumpEvents(extractPumpEvents(eventList));\n    setDetectorEvents(extractDetectorEvents(eventList));\n    console.log('Detector events:', extractDetectorEvents(eventList));\n    return eventList;\n  };\n  // First useEffect to set initial graphData\n  useEffect(() => {\n    setDropletHistory([]);\n    if (nodes.length > 0 && edges.length > 0) {\n      const graphNodes = nodes.map(node => ({\n        id: node.id,\n        label: node.data.label,\n        type: node.data.type,\n        x: 0,\n        y: 0,\n        volumetricPosition: 0\n      }));\n      const graphLinks = edges.map(edge => {\n        var _edge$data, _edge$data$properties, _edge$data2, _edge$data2$propertie;\n        return {\n          source: edge.source,\n          target: edge.target,\n          length: ((_edge$data = edge.data) === null || _edge$data === void 0 ? void 0 : (_edge$data$properties = _edge$data.properties) === null || _edge$data$properties === void 0 ? void 0 : _edge$data$properties.length) || 100,\n          diameter: ((_edge$data2 = edge.data) === null || _edge$data2 === void 0 ? void 0 : (_edge$data2$propertie = _edge$data2.properties) === null || _edge$data2$propertie === void 0 ? void 0 : _edge$data2$propertie.diameter) || 1\n        };\n      });\n      setGraphData({\n        nodes: graphNodes,\n        links: graphLinks\n      });\n    }\n  }, [nodes, edges]);\n\n  // Second useEffect to calculate nodes positions and set up simulation data\n  useEffect(() => {\n    if (!graphData.nodes.length || !graphData.links.length || !droplets.length) {\n      console.log('Missing required data for simulation setup:', {\n        nodesLength: graphData.nodes.length,\n        linksLength: graphData.links.length,\n        dropletsLength: droplets.length\n      });\n      return;\n    }\n    const graphNodes = [...graphData.nodes];\n\n    // Find outlet node first\n    const outletNode = findOutletNode(graphData.nodes);\n    if (!outletNode) {\n      console.error('No outlet node found. Cannot set up simulation.');\n      return;\n    }\n\n    // Get ordered nodes from outlet\n    const orderedNodes = orderNodesByDistance(outletNode, graphData.nodes, graphData.links);\n\n    // Separate nodes into main line and secondary line\n    const mainLineNodes = orderedNodes.filter(({\n      node\n    }) => setOfMainLineNodes.includes(node.type)).reverse();\n    const secondaryLineNodes = orderedNodes.filter(({\n      node\n    }) => setOfSecondaryLineNodes.includes(node.type)).sort((a, b) => b.distance - a.distance);\n\n    // Position settings\n    const mainLineY = 300;\n    const secondaryLineY = 150;\n    const pumpSpacing = 100; // Increased horizontal spacing between pumps\n    let currentX = 100;\n\n    // Position main line nodes\n    let currentVolumetricPosition = 0;\n    mainLineNodes.forEach(({\n      node\n    }, index) => {\n      const graphNode = graphNodes.find(n => n.id === node.id);\n      if (!graphNode) return;\n      graphNode.x = currentX;\n      graphNode.y = mainLineY;\n      graphNode.volumetricPosition = currentVolumetricPosition;\n      if (index < mainLineNodes.length - 1) {\n        const nextNode = mainLineNodes[index + 1];\n        const edge = graphData.links.find(e => e.source === graphNode.id && e.target === nextNode.node.id || e.target === graphNode.id && e.source === nextNode.node.id);\n        if (edge && edge.length) {\n          currentX += edge.length * 2;\n          // Use existing calculateEdgeVolume function\n          const edgeVolume = calculateEdgeVolume(edge);\n          currentVolumetricPosition += edgeVolume;\n        } else {\n          currentX += 200;\n          currentVolumetricPosition += 150;\n        }\n      }\n    });\n\n    // Group secondary nodes by distance\n    const nodesByDistance = {};\n    secondaryLineNodes.forEach(({\n      node,\n      distance\n    }) => {\n      if (!nodesByDistance[distance]) {\n        nodesByDistance[distance] = [];\n      }\n      nodesByDistance[distance].push(node);\n    });\n\n    // Position secondary nodes based on their connected main line nodes\n    const pumpOffset = 50; // Add this constant for pump spacing\n    Object.entries(nodesByDistance).forEach(([distance, nodes]) => {\n      nodes.forEach((node, index) => {\n        const graphNode = graphNodes.find(n => n.id === node.id);\n        if (!graphNode) return;\n\n        // Find connected main line node through edges\n        const connectedEdge = edges.find(e => e.source === node.id || e.target === node.id);\n        if (connectedEdge) {\n          const connectedNodeId = connectedEdge.source === node.id ? connectedEdge.target : connectedEdge.source;\n          const connectedMainNode = graphNodes.find(n => n.id === connectedNodeId);\n          if (connectedMainNode) {\n            // Position pump above its connected main line node with offset if needed\n            graphNode.x = connectedMainNode.x + index * pumpOffset - (nodes.length - 1) * pumpOffset / 2;\n            graphNode.y = secondaryLineY;\n          }\n        }\n      });\n    });\n    setGraphData(prev => ({\n      ...prev,\n      nodes: graphNodes\n    }));\n\n    // Only calculate volumes and blocks if not already done\n    if (currentBlockDroplets.length === 0) {\n      console.log('Calculating thermostat volumes and blocks for droplets:', droplets.length);\n      const thermoVol = calculateVolumesBetweenThermostats(graphData);\n\n      // Create deep copy of droplets to avoid mutation issues\n      const dropletsCopy = JSON.parse(JSON.stringify(droplets));\n      const blocks = divideDropletsIntoBlocks(dropletsCopy, thermoVol);\n      if (blocks.length > 0) {\n        setCurrentBlockDroplets(blocks[0].droplets);\n        // Generate event list only once when initializing\n        const eventList = generateEventList(blocks);\n        const eventListForDevices = recalculateEventListForDevices(eventList);\n      }\n    }\n\n    // Important: the dependency array includes currentBlockDroplets.length to prevent infinite recalculations\n  }, [graphData.nodes.length, graphData.links.length, droplets, edges, currentBlockDroplets.length]);\n  const startSimulation = useCallback(() => {\n    setIsSimulationRunning(true);\n    lastFrameTimeRef.current = null; // Reset the last frame time\n  }, []);\n  const stopSimulation = useCallback(() => {\n    setIsSimulationRunning(false);\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n      animationFrameRef.current = null;\n    }\n  }, []);\n  const restartSimulation = useCallback(() => {\n    stopSimulation();\n    setKey(prevKey => prevKey + 1);\n    setCurrentTime(0);\n    startSimulation();\n  }, [stopSimulation, startSimulation]);\n  const getNodeColor = node => {\n    switch (node.type) {\n      case 'pump':\n        return '#4CAF50';\n      case 'connector':\n        return '#2196F3';\n      case 'outlet':\n        return '#F44336';\n      default:\n        return '#FFA000';\n      // Default color for unknown types\n    }\n  };\n\n  // Update volumetricToXPosition function\n  const volumetricToXPosition = useCallback(volumetricPosition => {\n    var _graphData$nodes$find, _graphData$nodes$find2;\n    const outletNode = findOutletNode(graphData.nodes);\n    const furthestNode = findFurthestNode(outletNode, graphData.nodes, graphData.links);\n    if (!outletNode || !furthestNode) return 0;\n    const totalVolume = getVolumeBetweenNodes(furthestNode.id, outletNode.id, graphData.nodes, graphData.links);\n    const outletX = ((_graphData$nodes$find = graphData.nodes.find(n => n.id === outletNode.id)) === null || _graphData$nodes$find === void 0 ? void 0 : _graphData$nodes$find.x) || 0;\n    const furthestX = ((_graphData$nodes$find2 = graphData.nodes.find(n => n.id === furthestNode.id)) === null || _graphData$nodes$find2 === void 0 ? void 0 : _graphData$nodes$find2.x) || 0;\n\n    // Handle edge cases\n    if (!totalVolume || totalVolume === 0 || isNaN(totalVolume)) {\n      console.warn('Total volume is invalid:', totalVolume);\n      return furthestX;\n    }\n    if (volumetricPosition === undefined || volumetricPosition === null || isNaN(volumetricPosition)) {\n      console.warn('Volumetric position is invalid:', volumetricPosition);\n      return furthestX;\n    }\n\n    // Clamp the position to valid range\n    const clampedPosition = Math.max(-totalVolume, Math.min(totalVolume, volumetricPosition));\n\n    // Apply scaling factor to the position calculation\n    const scaledX = furthestX + clampedPosition / totalVolume * (outletX - furthestX);\n\n    // Ensure the returned value is a valid number\n    if (!isFinite(scaledX) || isNaN(scaledX)) {\n      console.warn('Invalid scaled position calculated:', {\n        scaledX,\n        clampedPosition,\n        totalVolume,\n        outletX,\n        furthestX\n      });\n      return furthestX;\n    }\n    return scaledX;\n  }, [graphData.nodes]);\n\n  // Update the updateDropletPositions function\n  const updateDropletPositions = useCallback(timestamp => {\n    if (!isSimulationRunning || dropletHistory.length === 0) return;\n    if (!lastFrameTimeRef.current) {\n      lastFrameTimeRef.current = timestamp;\n      animationFrameRef.current = requestAnimationFrame(updateDropletPositions);\n      return;\n    }\n    const deltaTime = (timestamp - lastFrameTimeRef.current) / 1000; // Convert to seconds\n    const simulationDeltaTime = deltaTime * timeScale;\n    setCurrentTime(prevTime => {\n      const newTime = prevTime + simulationDeltaTime;\n\n      // Get the time range of our history\n      const lastHistoryTime = dropletHistory[dropletHistory.length - 1].time;\n\n      // If we've reached the end, loop back to start\n      if (newTime >= lastHistoryTime) {\n        setCurrentTime(0);\n        return 0;\n      }\n\n      // Find the appropriate states to interpolate between\n      const currentState = interpolateDropletState(newTime);\n      // Update droplet visualization\n      const updatedDroplets = currentState.map(droplet => {\n        const frontX = volumetricToXPosition(droplet.frontVolumetricPosition);\n        const rearX = volumetricToXPosition(droplet.rearVolumetricPosition);\n        if (isNaN(frontX) || isNaN(rearX)) {\n          console.warn('Invalid droplet position calculated:', {\n            dropletId: droplet.id,\n            frontPosition: droplet.frontVolumetricPosition,\n            rearPosition: droplet.rearVolumetricPosition,\n            frontX,\n            rearX\n          });\n          return null;\n        }\n        return {\n          id: droplet.id,\n          frontX,\n          rearX,\n          y: 300,\n          volume: droplet.frontVolumetricPosition - droplet.rearVolumetricPosition,\n          speed: droplet.frontVolumetricSpeed\n        };\n      }).filter(Boolean);\n      setSimulationDroplets(updatedDroplets);\n      return newTime;\n    });\n    lastFrameTimeRef.current = timestamp;\n    animationFrameRef.current = requestAnimationFrame(updateDropletPositions);\n  }, [isSimulationRunning, timeScale, volumetricToXPosition, dropletHistory]);\n\n  // Add animation effect\n  useEffect(() => {\n    if (isSimulationRunning) {\n      lastFrameTimeRef.current = null;\n      animationFrameRef.current = requestAnimationFrame(updateDropletPositions);\n    }\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [isSimulationRunning, updateDropletPositions]);\n\n  // Add this helper function for interpolation\n  const interpolateDropletState = time => {\n    if (!dropletHistory.length) return [];\n\n    // Find the two closest states\n    const index = dropletHistory.findIndex(state => state.time > time);\n    if (index === -1) return dropletHistory[dropletHistory.length - 1].droplets;\n    if (index === 0) return dropletHistory[0].droplets;\n    const beforeState = dropletHistory[index - 1];\n    const afterState = dropletHistory[index];\n    const fraction = (time - beforeState.time) / (afterState.time - beforeState.time);\n    return beforeState.droplets.map(beforeDroplet => {\n      const afterDroplet = afterState.droplets.find(d => d.id === beforeDroplet.id);\n      if (!afterDroplet) return beforeDroplet;\n      return {\n        ...beforeDroplet,\n        frontVolumetricPosition: beforeDroplet.frontVolumetricPosition + (afterDroplet.frontVolumetricPosition - beforeDroplet.frontVolumetricPosition) * fraction,\n        rearVolumetricPosition: beforeDroplet.rearVolumetricPosition + (afterDroplet.rearVolumetricPosition - beforeDroplet.rearVolumetricPosition) * fraction\n      };\n    });\n  };\n\n  // Add navigation functions\n  const jumpToTimepoint = useCallback(index => {\n    if (index >= 0 && index < dropletHistory.length) {\n      setCurrentTimepoint(index);\n      setCurrentTime(dropletHistory[index].time);\n    }\n  }, [dropletHistory]);\n  const nextTimepoint = useCallback(() => {\n    jumpToTimepoint(currentTimepoint + 1);\n  }, [currentTimepoint, jumpToTimepoint]);\n  const previousTimepoint = useCallback(() => {\n    jumpToTimepoint(currentTimepoint - 1);\n  }, [currentTimepoint, jumpToTimepoint]);\n  const handleNodeClick = node => {\n    var _node$data2, _node$data3;\n    console.log('Node clicked:', node);\n    console.log('Node type:', node.type);\n    console.log('Node data type:', (_node$data2 = node.data) === null || _node$data2 === void 0 ? void 0 : _node$data2.type);\n\n    // Check both node.type and node.data.type\n    const nodeType = node.type || ((_node$data3 = node.data) === null || _node$data3 === void 0 ? void 0 : _node$data3.type);\n    console.log('Determined node type:', nodeType);\n    if (nodeType === 'pump' || nodeType === 'USBSpectrometer' || nodeType === 'MQTTSpectrometer') {\n      setSelectedNode(node);\n      console.log('Selected node set:', node.id, nodeType);\n    }\n    if (node.type === 'detector' || node.type === 'USBSpectrometer' || node.type === 'MQTTSpectrometer') {\n      // Store the graph ref when opening a spectrometer\n      const graphRef = /*#__PURE__*/React.createRef();\n      graphRefs.current[node.id] = graphRef;\n\n      // ... rest of the existing handleNodeClick code ...\n    }\n  };\n  const handleNodeAction = action => {\n    console.log('Node action:', action);\n    // Here you would implement the actual device communication\n    // based on the action type and parameters\n  };\n  const togglePumpSpeeds = () => {\n    setDisplayPumpSpeeds(!displayPumpSpeeds);\n  };\n\n  // Toggle functions for each display option\n  const toggleNodeIds = () => {\n    setDisplayNodeIds(!displayNodeIds);\n  };\n  const toggleDropletInfo = () => {\n    setDisplayDropletInfo(!displayDropletInfo);\n  };\n  const toggleDropletGaps = () => {\n    setDisplayDropletGaps(!displayDropletGaps);\n  };\n  const toggleEdgeLabels = () => {\n    setDisplayEdgeLabels(!displayEdgeLabels);\n  };\n  const toggleDisplayMenu = () => {\n    setDisplayMenuOpen(!isDisplayMenuOpen);\n  };\n  const toggleTimelineDropletInfo = () => {\n    setDisplayTimelineDropletInfo(!displayTimelineDropletInfo);\n  };\n  const toggleDetectorEvents = () => {\n    setDisplayDetectorEvents(!displayDetectorEvents);\n  };\n\n  // Close menu when clicking outside\n  useEffect(() => {\n    const handleClickOutside = event => {\n      if (displayMenuRef.current && !displayMenuRef.current.contains(event.target)) {\n        setDisplayMenuOpen(false);\n      }\n    };\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => {\n      document.removeEventListener('mousedown', handleClickOutside);\n    };\n  }, []);\n\n  // Function to toggle pump panel visibility\n  const togglePumpPanel = pumpId => {\n    setVisiblePumpPanel(prev => prev === pumpId ? null : pumpId);\n  };\n\n  // Add styles for the display menu\n  const styles = {\n    container: {\n      ...backgroundVariants.mainBackground,\n      padding: '20px',\n      minHeight: '100vh'\n    },\n    dropletInfo: {\n      padding: '8px',\n      borderRadius: '4px',\n      fontSize: '12px',\n      ...backgroundVariants.panelBackground,\n      color: '#fff',\n      minWidth: '150px'\n    },\n    timelineContainer: {\n      display: 'flex',\n      flexDirection: 'column',\n      gap: '10px',\n      marginBottom: '20px'\n    },\n    timeInput: {\n      width: '100px',\n      ...backgroundVariants.inputBackground,\n      padding: '5px',\n      borderRadius: '4px',\n      marginLeft: '8px'\n    },\n    buttonGroup: {\n      display: 'flex',\n      gap: '10px',\n      marginTop: '20px',\n      marginBottom: '20px'\n    },\n    timelineControls: {\n      display: 'flex',\n      flexDirection: 'column',\n      gap: '15px',\n      marginBottom: '20px',\n      ...backgroundVariants.panelBackground,\n      padding: '15px',\n      borderRadius: '4px'\n    },\n    timeControls: {\n      display: 'flex',\n      flexDirection: 'column',\n      gap: '15px'\n    },\n    sliderContainer: {\n      display: 'flex',\n      gap: '10px',\n      alignItems: 'center',\n      borderBottom: '1px solid rgba(255,255,255,0.1)',\n      paddingBottom: '15px'\n    },\n    timeStepButtons: {\n      display: 'flex',\n      gap: '5px',\n      alignItems: 'center',\n      justifyContent: 'flex-start'\n    },\n    timeScaleContainer: {\n      display: 'flex',\n      alignItems: 'center',\n      gap: '15px',\n      justifyContent: 'flex-start',\n      borderTop: '1px solid rgba(255,255,255,0.1)',\n      paddingTop: '15px'\n    },\n    svgContainer: {\n      background: backgroundVariants.panelBackground.background,\n      borderRadius: '4px',\n      padding: '10px'\n    },\n    navigationButtons: {\n      display: 'flex',\n      justifyContent: 'space-between',\n      marginBottom: '20px'\n    },\n    timeSlider: {\n      width: '33%',\n      ...backgroundVariants.inputBackground,\n      height: '20px',\n      borderRadius: '10px',\n      WebkitAppearance: 'none',\n      appearance: 'none',\n      background: backgroundVariants.inputBackground.background,\n      outline: 'none',\n      opacity: '0.7',\n      transition: 'opacity .2s',\n      '&:hover': {\n        opacity: '1'\n      },\n      '&::-webkit-slider-thumb': {\n        WebkitAppearance: 'none',\n        appearance: 'none',\n        width: '20px',\n        height: '20px',\n        background: '#4CAF50',\n        cursor: 'pointer',\n        borderRadius: '50%'\n      },\n      '&::-moz-range-thumb': {\n        width: '20px',\n        height: '20px',\n        background: '#4CAF50',\n        cursor: 'pointer',\n        borderRadius: '50%'\n      }\n    },\n    // Add styles for display menu\n    displayMenuButton: {\n      ...buttonVariants.infoButton,\n      position: 'relative'\n    },\n    displayMenu: {\n      position: 'absolute',\n      top: '100%',\n      right: 0,\n      backgroundColor: '#333',\n      border: '1px solid #555',\n      borderRadius: '4px',\n      padding: '8px 0',\n      zIndex: 1000,\n      width: '220px',\n      boxShadow: '0 2px 10px rgba(0, 0, 0, 0.3)'\n    },\n    menuItem: {\n      padding: '8px 16px',\n      cursor: 'pointer',\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'space-between',\n      color: 'white',\n      transition: 'background-color 0.2s',\n      '&:hover': {\n        backgroundColor: '#444'\n      }\n    },\n    checkmark: {\n      color: '#4CAF50',\n      fontWeight: 'bold'\n    }\n  };\n  const sliderStyle = {\n    width: '100%',\n    height: '10px',\n    borderRadius: '5px',\n    background: '#333',\n    outline: 'none',\n    opacity: '0.7',\n    transition: 'opacity .2s'\n    // Remove all pseudo-element styles that were here\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: styles.container,\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      style: styles.timelineControls,\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        style: styles.timeControls,\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          style: styles.sliderContainer,\n          children: [/*#__PURE__*/_jsxDEV(\"input\", {\n            type: \"range\",\n            min: 0,\n            max: Math.max(0, dropletHistory.length - 1),\n            value: currentTimepoint,\n            onChange: e => jumpToTimepoint(Number(e.target.value)),\n            disabled: isSimulationRunning,\n            style: styles.timeSlider,\n            className: \"time-slider\" // Add this className\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1820,\n            columnNumber: 13\n          }, this), displayTimelineDropletInfo && /*#__PURE__*/_jsxDEV(\"div\", {\n            style: {\n              display: 'flex',\n              gap: '10px',\n              flexWrap: 'wrap'\n            },\n            children: dropletHistory.length > 0 && ((_dropletHistory$curre = dropletHistory[currentTimepoint]) === null || _dropletHistory$curre === void 0 ? void 0 : _dropletHistory$curre.droplets.map((droplet, index) => {\n              var _graphData$nodes$find3, _graphData$nodes$find4;\n              return /*#__PURE__*/_jsxDEV(\"div\", {\n                style: styles.dropletInfo,\n                children: [/*#__PURE__*/_jsxDEV(\"div\", {\n                  children: [\"Droplet \", index + 1, \":\"]\n                }, void 0, true, {\n                  fileName: _jsxFileName,\n                  lineNumber: 1834,\n                  columnNumber: 21\n                }, this), droplet.frontNextNodeID && /*#__PURE__*/_jsxDEV(\"div\", {\n                  children: [\"Front \\u2192 \", ((_graphData$nodes$find3 = graphData.nodes.find(n => n.id === droplet.frontNextNodeID)) === null || _graphData$nodes$find3 === void 0 ? void 0 : _graphData$nodes$find3.label) || droplet.frontNextNodeID]\n                }, void 0, true, {\n                  fileName: _jsxFileName,\n                  lineNumber: 1836,\n                  columnNumber: 23\n                }, this), droplet.rearNextNodeID && /*#__PURE__*/_jsxDEV(\"div\", {\n                  children: [\"Rear \\u2192 \", ((_graphData$nodes$find4 = graphData.nodes.find(n => n.id === droplet.rearNextNodeID)) === null || _graphData$nodes$find4 === void 0 ? void 0 : _graphData$nodes$find4.label) || droplet.rearNextNodeID]\n                }, void 0, true, {\n                  fileName: _jsxFileName,\n                  lineNumber: 1839,\n                  columnNumber: 23\n                }, this)]\n              }, droplet.id, true, {\n                fileName: _jsxFileName,\n                lineNumber: 1833,\n                columnNumber: 19\n              }, this);\n            }))\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1831,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1819,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: styles.timeStepButtons,\n          children: [/*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => jumpToTimepoint(0),\n            disabled: currentTimepoint === 0 || isSimulationRunning,\n            style: {\n              ...buttonVariants.secondaryButton,\n              padding: '4px 8px'\n            },\n            children: \"\\u23EE\\uFE0F Start\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1848,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => jumpToTimepoint(currentTimepoint - 1),\n            disabled: currentTimepoint === 0 || isSimulationRunning,\n            style: {\n              ...buttonVariants.secondaryButton,\n              padding: '4px 8px'\n            },\n            children: \"\\u23EA Previous\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1855,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => jumpToTimepoint(currentTimepoint + 1),\n            disabled: currentTimepoint >= dropletHistory.length - 1 || isSimulationRunning,\n            style: {\n              ...buttonVariants.secondaryButton,\n              padding: '4px 8px'\n            },\n            children: \"Next \\u23E9\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1862,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => jumpToTimepoint(dropletHistory.length - 1),\n            disabled: currentTimepoint >= dropletHistory.length - 1 || isSimulationRunning,\n            style: {\n              ...buttonVariants.secondaryButton,\n              padding: '4px 8px'\n            },\n            children: \"End \\u23ED\\uFE0F\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1869,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1847,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: styles.timeScaleContainer,\n          children: [/*#__PURE__*/_jsxDEV(\"label\", {\n            style: {\n              color: '#fff',\n              marginRight: '10px'\n            },\n            children: [\"Time Scale:\", /*#__PURE__*/_jsxDEV(\"select\", {\n              value: timeScale,\n              onChange: e => setTimeScale(Number(e.target.value)),\n              style: styles.timeInput,\n              children: [/*#__PURE__*/_jsxDEV(\"option\", {\n                value: 0.0625,\n                children: \"1/16x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1886,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 0.25,\n                children: \"1/4x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1887,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 1,\n                children: \"1x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1888,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 4,\n                children: \"4x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1889,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 16,\n                children: \"16x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1890,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 64,\n                children: \"64x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1891,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 256,\n                children: \"256x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1892,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 1024,\n                children: \"1024x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1893,\n                columnNumber: 17\n              }, this)]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 1881,\n              columnNumber: 15\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1879,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"label\", {\n            style: {\n              color: '#fff',\n              marginRight: '10px'\n            },\n            children: [\"Current Time: \", currentTime.toFixed(2), \"s\"]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1896,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"label\", {\n            style: {\n              color: '#fff'\n            },\n            children: [\"Step: \", currentTimepoint + 1, \"/\", dropletHistory.length]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1899,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1878,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1818,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1817,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: styles.buttonGroup,\n      children: [/*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: isSimulationRunning ? stopSimulation : startSimulation,\n        style: {\n          ...buttonVariants.primaryButton\n        },\n        children: isSimulationRunning ? 'Stop Simulation' : 'Start Simulation'\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1907,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: restartSimulation,\n        style: {\n          ...buttonVariants.secondaryButton\n        },\n        children: \"Restart simulation\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1913,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: sendingEventsToDevices,\n        style: {\n          ...buttonVariants.primaryButton\n        },\n        children: \"Send Events to Devices\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1919,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        ref: displayMenuRef,\n        style: {\n          position: 'relative',\n          display: 'inline-block'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: toggleDisplayMenu,\n          style: styles.displayMenuButton,\n          children: \"Display Settings\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1926,\n          columnNumber: 11\n        }, this), isDisplayMenuOpen && /*#__PURE__*/_jsxDEV(\"div\", {\n          style: styles.displayMenu,\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: toggleNodeIds,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Node IDs\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1938,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayNodeIds ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1939,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1934,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: toggleDropletInfo,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Droplet Info\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1945,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayDropletInfo ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1946,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1941,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: toggleDropletGaps,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Droplet Gaps\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1952,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayDropletGaps ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1953,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1948,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: toggleEdgeLabels,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Tube Dimensions\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1959,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayEdgeLabels ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1960,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1955,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: togglePumpSpeeds,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Pump Speeds\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1966,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayPumpSpeeds ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1967,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1962,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: toggleTimelineDropletInfo,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Timeline Droplet Info\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1973,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayTimelineDropletInfo ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1974,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1969,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: toggleDetectorEvents,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Detector Events\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1980,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayDetectorEvents ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1981,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1976,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1933,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1925,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1906,\n      columnNumber: 7\n    }, this), graphData.nodes.length > 0 && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: styles.svgContainer,\n      children: /*#__PURE__*/_jsxDEV(\"svg\", {\n        width: \"2000\",\n        height: \"400\",\n        children: [graphData.links.map((link, index) => {\n          const sourceNode = graphData.nodes.find(node => node.id === link.source);\n          const targetNode = graphData.nodes.find(node => node.id === link.target);\n          if (!sourceNode || !targetNode) return null;\n          const midX = (sourceNode.x + targetNode.x) / 2;\n          const midY = (sourceNode.y + targetNode.y) / 2;\n          return /*#__PURE__*/_jsxDEV(\"g\", {\n            children: [/*#__PURE__*/_jsxDEV(\"line\", {\n              x1: sourceNode.x,\n              y1: sourceNode.y,\n              x2: targetNode.x,\n              y2: targetNode.y,\n              stroke: \"#999\",\n              strokeWidth: 2\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 2003,\n              columnNumber: 19\n            }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n              x: midX,\n              y: midY - 20,\n              textAnchor: \"middle\",\n              fill: \"#fff\",\n              fontSize: \"12px\",\n              style: {\n                display: displayEdgeLabels ? 'block' : 'none'\n              },\n              children: `${link.length} mm (Ø ${link.diameter} mm)`\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 2011,\n              columnNumber: 19\n            }, this)]\n          }, `edge-${index}`, true, {\n            fileName: _jsxFileName,\n            lineNumber: 2002,\n            columnNumber: 17\n          }, this);\n        }), graphData.nodes.map((node, index) => /*#__PURE__*/_jsxDEV(\"g\", {\n          children: [/*#__PURE__*/_jsxDEV(\"circle\", {\n            cx: node.x,\n            cy: node.y,\n            r: 15,\n            fill: getNodeColor(node),\n            stroke: selectedNode && selectedNode.id === node.id ? '#FFA500' : 'none',\n            strokeWidth: selectedNode && selectedNode.id === node.id ? '3' : '0',\n            onClick: () => handleNodeClick(node),\n            style: {\n              cursor: 'pointer'\n            }\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 2028,\n            columnNumber: 17\n          }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n            x: node.x,\n            y: node.y - 25,\n            textAnchor: \"middle\",\n            fill: \"#fff\",\n            fontSize: \"12px\",\n            children: node.label\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 2038,\n            columnNumber: 17\n          }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n            x: node.x,\n            y: node.y - 10,\n            textAnchor: \"middle\",\n            fill: \"#fff\",\n            fontSize: \"10px\",\n            style: {\n              display: displayNodeIds ? 'block' : 'none'\n            },\n            children: `ID: ${node.id}`\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 2047,\n            columnNumber: 17\n          }, this)]\n        }, `node-${index}`, true, {\n          fileName: _jsxFileName,\n          lineNumber: 2027,\n          columnNumber: 15\n        }, this)), interpolateDropletState(currentTime).map((droplet, index, droplets) => {\n          const frontX = volumetricToXPosition(droplet.frontVolumetricPosition);\n          const rearX = volumetricToXPosition(droplet.rearVolumetricPosition);\n          const centerX = (frontX + rearX) / 2;\n\n          // Calculate distance to next droplet if this isn't the last droplet\n          const distanceInfo = index < droplets.length - 1 ? {\n            nextDropletFront: droplets[index + 1].frontVolumetricPosition,\n            distance: Math.abs(droplets[index + 1].frontVolumetricPosition - droplet.rearVolumetricPosition)\n          } : null;\n\n          // Calculate midpoint for distance label\n          const distanceLabelX = distanceInfo ? (volumetricToXPosition(droplet.rearVolumetricPosition) + volumetricToXPosition(distanceInfo.nextDropletFront)) / 2 : null;\n          return /*#__PURE__*/_jsxDEV(\"g\", {\n            children: [/*#__PURE__*/_jsxDEV(\"line\", {\n              x1: rearX,\n              y1: 300,\n              x2: frontX,\n              y2: 300,\n              stroke: \"rgba(255, 100, 100, 0.9)\",\n              strokeWidth: 8,\n              strokeLinecap: \"butt\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 2080,\n              columnNumber: 19\n            }, this), distanceInfo && displayDropletGaps && /*#__PURE__*/_jsxDEV(\"g\", {\n              children: [/*#__PURE__*/_jsxDEV(\"line\", {\n                x1: rearX,\n                y1: 320,\n                x2: volumetricToXPosition(distanceInfo.nextDropletFront),\n                y2: 320,\n                stroke: \"#fff\",\n                strokeWidth: 1,\n                strokeDasharray: \"5,5\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2094,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"line\", {\n                x1: rearX,\n                y1: 315,\n                x2: rearX,\n                y2: 325,\n                stroke: \"#fff\",\n                strokeWidth: 1\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2104,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"line\", {\n                x1: volumetricToXPosition(distanceInfo.nextDropletFront),\n                y1: 315,\n                x2: volumetricToXPosition(distanceInfo.nextDropletFront),\n                y2: 325,\n                stroke: \"#666\",\n                strokeWidth: 1\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2112,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                x: distanceLabelX,\n                y: 335,\n                textAnchor: \"middle\",\n                fill: \"#666\",\n                fontSize: \"12px\",\n                children: `${distanceInfo.distance.toFixed(2)} μL`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2121,\n                columnNumber: 23\n              }, this)]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 2092,\n              columnNumber: 21\n            }, this), displayDropletInfo && /*#__PURE__*/_jsxDEV(_Fragment, {\n              children: [/*#__PURE__*/_jsxDEV(\"text\", {\n                x: centerX,\n                y: 270,\n                textAnchor: \"middle\",\n                fill: \"#6f6\",\n                fontSize: \"12px\",\n                children: `Vol: ${(droplet.frontVolumetricPosition - droplet.rearVolumetricPosition).toFixed(2)} μL`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2136,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                x: centerX,\n                y: 255,\n                textAnchor: \"middle\",\n                fill: \"#6f6\",\n                fontSize: \"12px\",\n                children: `Spd f: ${droplet.frontVolumetricSpeed.toFixed(2)} μL/s`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2145,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                x: centerX,\n                y: 240,\n                textAnchor: \"middle\",\n                fill: \"#6f6\",\n                fontSize: \"12px\",\n                children: `Spd r: ${droplet.rearVolumetricSpeed.toFixed(2)} μL/s`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2154,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                x: centerX,\n                y: 225,\n                textAnchor: \"middle\",\n                fill: \"#6f6\",\n                fontSize: \"12px\",\n                children: `mlt: ${droplet.pumpSpeedMultiplier.toFixed(2)}`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2163,\n                columnNumber: 23\n              }, this)]\n            }, void 0, true)]\n          }, `droplet-${droplet.id}`, true, {\n            fileName: _jsxFileName,\n            lineNumber: 2078,\n            columnNumber: 17\n          }, this);\n        }), displayPumpSpeeds && graphData.nodes.map((node, index) => {\n          if (node.type === 'pump') {\n            var _dropletHistory;\n            const currentSpeed = getPumpSpeedAtTime(node.id, pumpEvents, currentTime);\n            const maxTime = ((_dropletHistory = dropletHistory[dropletHistory.length - 1]) === null || _dropletHistory === void 0 ? void 0 : _dropletHistory.time) || 1;\n            const pumpSpecificEvents = pumpEvents.filter(event => event.target === node.id);\n            return /*#__PURE__*/_jsxDEV(\"g\", {\n              children: [/*#__PURE__*/_jsxDEV(\"text\", {\n                x: node.x,\n                y: node.y - 35,\n                textAnchor: \"middle\",\n                fill: \"#4CAF50\",\n                fontSize: \"12px\",\n                children: `${currentSpeed.toFixed(2)} μL/s`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2187,\n                columnNumber: 21\n              }, this), /*#__PURE__*/_jsxDEV(\"g\", {\n                transform: `translate(${node.x - 40}, ${node.y - 65})`,\n                children: [pumpSpecificEvents.map((event, i, arr) => {\n                  const nextEvent = arr[i + 1];\n                  const width = 80;\n                  const x = 0;\n                  const y = 0;\n\n                  // Calculate position based on time\n                  const timePosition = event.time / maxTime * width;\n                  const nextTimePosition = nextEvent ? nextEvent.time / maxTime * width : width;\n\n                  // Calculate height based on speed value (normalized)\n                  const maxSpeed = Math.max(...pumpSpecificEvents.map(e => e.value));\n                  const normalizedHeight = event.value / (maxSpeed || 1) * 20;\n                  return /*#__PURE__*/_jsxDEV(\"g\", {\n                    children: [/*#__PURE__*/_jsxDEV(\"line\", {\n                      x1: x + timePosition,\n                      y1: y - normalizedHeight,\n                      x2: x + nextTimePosition,\n                      y2: y - normalizedHeight,\n                      stroke: \"#4CAF50\",\n                      strokeWidth: 2\n                    }, void 0, false, {\n                      fileName: _jsxFileName,\n                      lineNumber: 2218,\n                      columnNumber: 29\n                    }, this), /*#__PURE__*/_jsxDEV(\"circle\", {\n                      cx: x + timePosition,\n                      cy: y - normalizedHeight,\n                      r: 2,\n                      fill: \"#4CAF50\"\n                    }, void 0, false, {\n                      fileName: _jsxFileName,\n                      lineNumber: 2227,\n                      columnNumber: 29\n                    }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                      x: x + timePosition,\n                      y: y + 12,\n                      textAnchor: \"middle\",\n                      fill: \"#666\",\n                      fontSize: \"10px\",\n                      children: [event.time.toFixed(1), \"s\"]\n                    }, void 0, true, {\n                      fileName: _jsxFileName,\n                      lineNumber: 2234,\n                      columnNumber: 29\n                    }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                      x: x + timePosition,\n                      y: y - normalizedHeight - 5,\n                      textAnchor: \"middle\",\n                      fill: \"#4CAF50\",\n                      fontSize: \"8px\",\n                      children: event.value.toFixed(1)\n                    }, void 0, false, {\n                      fileName: _jsxFileName,\n                      lineNumber: 2244,\n                      columnNumber: 29\n                    }, this)]\n                  }, `pump-event-${i}`, true, {\n                    fileName: _jsxFileName,\n                    lineNumber: 2216,\n                    columnNumber: 27\n                  }, this);\n                }), /*#__PURE__*/_jsxDEV(\"line\", {\n                  x1: currentTime / maxTime * 80,\n                  y1: -25,\n                  x2: currentTime / maxTime * 80,\n                  y2: 15,\n                  stroke: \"red\",\n                  strokeWidth: 1,\n                  strokeDasharray: \"2,2\"\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 2257,\n                  columnNumber: 23\n                }, this)]\n              }, void 0, true, {\n                fileName: _jsxFileName,\n                lineNumber: 2198,\n                columnNumber: 21\n              }, this)]\n            }, `pump-speed-${node.id}`, true, {\n              fileName: _jsxFileName,\n              lineNumber: 2185,\n              columnNumber: 19\n            }, this);\n          }\n          return null;\n        }), displayDetectorEvents && graphData.nodes.map((node, index) => {\n          if (node.type === 'detector' || node.type === 'USBSpectrometer' || node.type === 'MQTTSpectrometer') {\n            var _dropletHistory2;\n            const currentEvents = getDetectorEventsAtTime(node.id, detectorEvents, currentTime);\n            const detectorSpecificEvents = detectorEvents.filter(event => event.target === node.id);\n            const maxTime = ((_dropletHistory2 = dropletHistory[dropletHistory.length - 1]) === null || _dropletHistory2 === void 0 ? void 0 : _dropletHistory2.time) || 1;\n            return /*#__PURE__*/_jsxDEV(\"g\", {\n              children: [currentEvents.length > 0 && /*#__PURE__*/_jsxDEV(\"circle\", {\n                cx: node.x,\n                cy: node.y,\n                r: 20,\n                fill: \"none\",\n                stroke: \"#FF6B35\",\n                strokeWidth: 3,\n                opacity: 0.8\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2284,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                x: node.x,\n                y: node.y - 35,\n                textAnchor: \"middle\",\n                fill: \"#FF6B35\",\n                fontSize: \"12px\",\n                children: `Events: ${detectorSpecificEvents.length}`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2296,\n                columnNumber: 21\n              }, this), /*#__PURE__*/_jsxDEV(\"g\", {\n                transform: `translate(${node.x - 40}, ${node.y - 65})`,\n                children: [detectorSpecificEvents.map((event, i) => {\n                  const width = 80;\n                  const x = 0;\n                  const y = 0;\n\n                  // Calculate position based on time\n                  const timePosition = event.time / maxTime * width;\n                  return /*#__PURE__*/_jsxDEV(\"g\", {\n                    children: [/*#__PURE__*/_jsxDEV(\"circle\", {\n                      cx: x + timePosition,\n                      cy: y,\n                      r: 3,\n                      fill: event.eventSubtype === 'dropletFrontReached' ? '#FF6B35' : '#FFA500'\n                    }, void 0, false, {\n                      fileName: _jsxFileName,\n                      lineNumber: 2319,\n                      columnNumber: 29\n                    }, this), /*#__PURE__*/_jsxDEV(\"line\", {\n                      x1: x + timePosition,\n                      y1: y - 5,\n                      x2: x + timePosition,\n                      y2: y + 5,\n                      stroke: \"#FF6B35\",\n                      strokeWidth: 1\n                    }, void 0, false, {\n                      fileName: _jsxFileName,\n                      lineNumber: 2326,\n                      columnNumber: 29\n                    }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                      x: x + timePosition,\n                      y: y + 15,\n                      textAnchor: \"middle\",\n                      fill: \"#FF6B35\",\n                      fontSize: \"8px\",\n                      children: [event.time.toFixed(1), \"s\"]\n                    }, void 0, true, {\n                      fileName: _jsxFileName,\n                      lineNumber: 2335,\n                      columnNumber: 29\n                    }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                      x: x + timePosition,\n                      y: y - 10,\n                      textAnchor: \"middle\",\n                      fill: \"#FF6B35\",\n                      fontSize: \"8px\",\n                      children: [\"D\", event.dropletId]\n                    }, void 0, true, {\n                      fileName: _jsxFileName,\n                      lineNumber: 2345,\n                      columnNumber: 29\n                    }, this)]\n                  }, `detector-event-${i}`, true, {\n                    fileName: _jsxFileName,\n                    lineNumber: 2317,\n                    columnNumber: 27\n                  }, this);\n                }), /*#__PURE__*/_jsxDEV(\"line\", {\n                  x1: currentTime / maxTime * 80,\n                  y1: -25,\n                  x2: currentTime / maxTime * 80,\n                  y2: 25,\n                  stroke: \"red\",\n                  strokeWidth: 1,\n                  strokeDasharray: \"2,2\"\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 2358,\n                  columnNumber: 23\n                }, this)]\n              }, void 0, true, {\n                fileName: _jsxFileName,\n                lineNumber: 2307,\n                columnNumber: 21\n              }, this)]\n            }, `detector-events-${node.id}`, true, {\n              fileName: _jsxFileName,\n              lineNumber: 2281,\n              columnNumber: 19\n            }, this);\n          }\n          return null;\n        })]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1991,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1990,\n      columnNumber: 9\n    }, this), selectedNode && (selectedNode.type === 'pump' || ((_selectedNode$data = selectedNode.data) === null || _selectedNode$data === void 0 ? void 0 : _selectedNode$data.type) === 'pump') && /*#__PURE__*/_jsxDEV(DraggablePanel, {\n      initialPosition: pumpPanelPosition,\n      title: `Pump Controls - ${selectedNode.label || selectedNode.id}`,\n      children: /*#__PURE__*/_jsxDEV(PumpActions, {\n        node: selectedNode,\n        nodes: nodes,\n        edges: edges,\n        onAction: handleNodeAction\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 2382,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 2378,\n      columnNumber: 9\n    }, this), selectedNode && (selectedNode.type === 'USBSpectrometer' || ((_selectedNode$data2 = selectedNode.data) === null || _selectedNode$data2 === void 0 ? void 0 : _selectedNode$data2.type) === 'USBSpectrometer') && /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [console.log('Rendering USBSpectrometer component for node:', selectedNode), /*#__PURE__*/_jsxDEV(USBSpectrometer, {\n        detector: selectedNode,\n        detectorId: selectedNode.id,\n        detectorName: selectedNode.label || selectedNode.id,\n        onClose: () => setSelectedNode(null),\n        initialPosition: {\n          x: 150,\n          y: 100\n        },\n        isVisible: true\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 2393,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true), selectedNode && (selectedNode.type === 'MQTTSpectrometer' || ((_selectedNode$data3 = selectedNode.data) === null || _selectedNode$data3 === void 0 ? void 0 : _selectedNode$data3.type) === 'MQTTSpectrometer') && /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [console.log('Rendering SpectrometerMQTT component for node:', selectedNode), /*#__PURE__*/_jsxDEV(SpectrometerMQTT, {\n        detector: selectedNode,\n        detectorId: selectedNode.id,\n        detectorName: selectedNode.label || selectedNode.id,\n        onClose: () => setSelectedNode(null),\n        initialPosition: {\n          x: 150,\n          y: 100\n        },\n        isVisible: true\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 2406,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true), /*#__PURE__*/_jsxDEV(\"style\", {\n      children: `\n          .node-actions {\n            position: fixed;\n            top: 20px;\n            right: 20px;\n            background: black;\n            padding: 20px;\n            border: 1px solid #ccc;\n            border-radius: 5px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n          }\n          .node-actions h3 {\n            margin: 0 0 15px 0;\n            color: #333;\n          }\n          .node-actions button {\n            margin: 5px;\n            padding: 8px 16px;\n            background: #4CAF50;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n          }\n          .node-actions button:disabled {\n            background: #ccc;\n            cursor: not-allowed;\n          }\n          .node-actions input {\n            margin: 5px;\n            padding: 8px;\n            border: 1px solid #ccc;\n            border-radius: 4px;\n            width: 80px;\n          }\n          .move-controls {\n            display: flex;\n            flex-direction: column;\n            gap: 10px;\n            margin-top: 10px;\n          }\n          .input-group {\n            display: flex;\n            align-items: center;\n            gap: 10px;\n          }\n          .input-group label {\n            min-width: 100px;\n            text-align: right;\n            color: #666;\n          }\n        `\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 2417,\n      columnNumber: 7\n    }, this), overlayComponent && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: 'fixed',\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0,\n        zIndex: 9999,\n        pointerEvents: 'none'\n      },\n      children: /*#__PURE__*/_jsxDEV(Suspense, {\n        fallback: /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            position: 'fixed',\n            top: '50%',\n            left: '50%',\n            transform: 'translate(-50%, -50%)',\n            background: 'rgba(0,0,0,0.8)',\n            padding: '20px',\n            borderRadius: '8px',\n            color: 'white',\n            pointerEvents: 'auto'\n          },\n          children: /*#__PURE__*/_jsxDEV(\"h2\", {\n            children: \"Loading Component...\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 2493,\n            columnNumber: 15\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2482,\n          columnNumber: 13\n        }, this),\n        children: [overlayComponent.type === 'USBSpectrometer' && /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            pointerEvents: 'auto'\n          },\n          children: /*#__PURE__*/_jsxDEV(USBSpectrometer, {\n            ...overlayComponent.props\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 2498,\n            columnNumber: 17\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2497,\n          columnNumber: 15\n        }, this), overlayComponent.type === 'MQTTSpectrometer' && /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            pointerEvents: 'auto'\n          },\n          children: /*#__PURE__*/_jsxDEV(SpectrometerMQTT, {\n            ...overlayComponent.props,\n            graphRef: graphRefs.current[overlayComponent.props.detector.id]\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 2503,\n            columnNumber: 17\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2502,\n          columnNumber: 15\n        }, this), overlayComponent.type === 'PumpPanel' && /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            pointerEvents: 'auto'\n          },\n          children: /*#__PURE__*/_jsxDEV(PumpPanel, {\n            ...overlayComponent.props\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 2511,\n            columnNumber: 17\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2510,\n          columnNumber: 15\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 2481,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 2472,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 1816,\n    columnNumber: 5\n  }, this);\n};\n_s(Simulation, \"CpoCBrE9dcWkinZ5MUDGpJrTK/s=\", false, function () {\n  return [useButtonStyles];\n});\n_c = Simulation;\nexport default Simulation;\nvar _c;\n$RefreshReg$(_c, \"Simulation\");","map":{"version":3,"names":["React","useState","useEffect","useCallback","useRef","Suspense","ReactFlowProvider","useNodesState","useEdgesState","PumpActions","DraggablePanel","convertToHardwareValuesPump","useButtonStyles","backgroundVariants","findOutletNode","findFurthestNode","orderNodesByDistance","calculateEdgeVolume","getVolumeBetweenNodes","findConnectedPump","getPumpSpeed","getPumpsBetweenPositions","cleanAndSortEventList","getPumpSpeedAtTime","sendEventsToDevices","setOfMainLineNodes","setOfSecondaryLineNodes","SvgDefs","calculateEdgePoints","createLabels","USBSpectrometer","SpectrometerMQTT","PumpPanel","jsxDEV","_jsxDEV","Fragment","_Fragment","Simulation","nodes","edges","droplets","selectedCarrierPumps","onBack","onNext","_s","_dropletHistory$curre","_selectedNode$data","_selectedNode$data2","_selectedNode$data3","buttonVariants","graphData","setGraphData","links","simulationDroplets","setSimulationDroplets","isSimulationRunning","setIsSimulationRunning","key","setKey","currentTime","setCurrentTime","timeScale","setTimeScale","animationFrameRef","lastFrameTimeRef","currentBlockDroplets","setCurrentBlockDroplets","dropletHistory","setDropletHistory","currentTimepoint","setCurrentTimepoint","pumpEvents","setPumpEvents","detectorEvents","setDetectorEvents","displayPumpSpeeds","setDisplayPumpSpeeds","displayNodeIds","setDisplayNodeIds","displayDropletInfo","setDisplayDropletInfo","displayDropletGaps","setDisplayDropletGaps","displayEdgeLabels","setDisplayEdgeLabels","isDisplayMenuOpen","setDisplayMenuOpen","displayTimelineDropletInfo","setDisplayTimelineDropletInfo","displayDetectorEvents","setDisplayDetectorEvents","displayMenuRef","selectedNode","setSelectedNode","ws","setWs","pumpPanelPosition","setPumpPanelPosition","x","window","innerWidth","y","visiblePumpPanel","setVisiblePumpPanel","isSendingEvents","setIsSendingEvents","graphRefs","overlayComponent","setOverlayComponent","console","log","length","map","node","_node$data","id","type","dataType","data","websocket","WebSocket","onopen","onerror","error","close","sendingEventsToDevices","sendMeasurementTimepointsToSpectrometers","generateEventList","warn","eventsByDetector","reduce","acc","event","target","push","Object","entries","forEach","detectorId","events","_detectorNode$data","detectorNode","find","_detectorNode$data2","_detectorNode$data2$p","_detectorNode$data2$p2","_detectorNode$data3","_detectorNode$data3$p","_detectorNode$data3$p2","mqttName","properties","prop","name","value","timepoints","Math","round","time","mqttMessage","topic","payload","timestamp","Date","now","send","JSON","stringify","values","current","graphRef","addToMemory","eventType","calculateVolumesBetweenThermostats","outletNode","visited","Set","queue","thermostatVolumes","currentNodeId","accumulatedVolume","thermostatPath","shift","currentNode","n","has","add","updatedPath","startThermostatId","endThermostatId","volume","connectedEdges","filter","link","source","edge","nextNodeId","nextNode","edgeVolume","divideDropletsIntoBlocks","thermostatId","totalVolume","droplet","actualVolume","temperature","furthestNode","volumeToFurthestNode","blocks","currentBlock","finalizeBlock","lastDroplet","surfixParam","parameters","p","max","i","_droplet$parameters$f","_droplet$parameters$f2","_droplet$parameters$f3","_droplet$parameters$f4","_droplet$parameters$f5","relevantVolume","tv","dropletVolume","printDropletFrontPositionsAndSpeeds","frontVolumetricPosition","frontTimeToReachNextNode","frontVolumetricDistanceToNextNode","rearVolumetricPosition","rearTimeToReachNextNode","rearVolumetricDistanceToNextNode","frontNextNodeID","rearNextNodeID","extractPumpEvents","eventList","flat","sort","a","b","extractDetectorEvents","getDetectorEventsAtTime","abs","recalculateEventListForDevices","deviceEventMap","Map","convertPumpEvent","deviceProperties","_deviceProperties$fin","_deviceProperties$fin2","_deviceProperties$fin3","_deviceProperties$fin4","syringeDiameter","default","syringeLength","stepsPerRevolution","lead","syringeArea","PI","pow","linearSpeed","stepsPerMm","stepsPerSecond","delayMicroseconds","delay","convertThermostatEvent","convertLedEvent","intensity","convertDetectorEvent","setting","deviceEventList","targetId","deviceNode","deviceEvents","Boolean","set","Array","from","isArray","orderedNodes","dropletSnapshot","dropletWithParams","d","volumetricSpeedParam","commonVolumetricSpeed","inletVolumetricSpeed","outletVolumetricSpeed","pump","connectedPump","connectedPumpRatio","connectedPumpSpeedAtPause","pumpSpeedMultiplier","pauseLevel","carrierPumpConnector","connectorNode","position","_droplet$parameters$f6","_droplet$parameters$f7","prefixVolume","surfixVolume","frontVolumetricSpeed","rearVolumetricSpeed","frontVolumetricSpeedAtPause","rearVolumetricSpeedAtPause","stoppingDroplet","initialPumping","lastDropletRearPosition","outletNodePosition","volumetricPosition","timePassed","newTimePassed","smallestFrontTime","Infinity","smallestRearTime","smallestFrontTimeDroplet","smallestRearTimeDroplet","min","reachedNode","reachedNodeDistance","distance","index","indexOf","dropletsOlder","slice","dropletsNewer","ds","drops","parse","snappedNode","existingSnapshotIndex","findIndex","snapshot","nextEdge","_smallestFrontTimeDro","_smallestFrontTimeDro2","pumpRatio","param","nodeId","dropletDesiredVolume","_smallestFrontTimeDro3","_smallestFrontTimeDro4","rearTimeLeft","totalTimeLeft","thispumpspeed","accumulatedSpeed","reverse","editedNode","pumpBoost","waitTime","property","measurementTime","currentSpeed","speedDifference","accumulatedSpeedDecrease","pumpBreak","isFarthestThermostatOrLED","every","_smallestRearTimeDrop","carrierPumpEvent","dropletState","_droplet$parameters$f8","prev","graphNodes","label","graphLinks","_edge$data","_edge$data$properties","_edge$data2","_edge$data2$propertie","diameter","nodesLength","linksLength","dropletsLength","mainLineNodes","includes","secondaryLineNodes","mainLineY","secondaryLineY","pumpSpacing","currentX","currentVolumetricPosition","graphNode","e","nodesByDistance","pumpOffset","connectedEdge","connectedNodeId","connectedMainNode","thermoVol","dropletsCopy","eventListForDevices","startSimulation","stopSimulation","cancelAnimationFrame","restartSimulation","prevKey","getNodeColor","volumetricToXPosition","_graphData$nodes$find","_graphData$nodes$find2","outletX","furthestX","isNaN","undefined","clampedPosition","scaledX","isFinite","updateDropletPositions","requestAnimationFrame","deltaTime","simulationDeltaTime","prevTime","newTime","lastHistoryTime","currentState","interpolateDropletState","updatedDroplets","frontX","rearX","dropletId","frontPosition","rearPosition","speed","state","beforeState","afterState","fraction","beforeDroplet","afterDroplet","jumpToTimepoint","nextTimepoint","previousTimepoint","handleNodeClick","_node$data2","_node$data3","nodeType","createRef","handleNodeAction","action","togglePumpSpeeds","toggleNodeIds","toggleDropletInfo","toggleDropletGaps","toggleEdgeLabels","toggleDisplayMenu","toggleTimelineDropletInfo","toggleDetectorEvents","handleClickOutside","contains","document","addEventListener","removeEventListener","togglePumpPanel","pumpId","styles","container","mainBackground","padding","minHeight","dropletInfo","borderRadius","fontSize","panelBackground","color","minWidth","timelineContainer","display","flexDirection","gap","marginBottom","timeInput","width","inputBackground","marginLeft","buttonGroup","marginTop","timelineControls","timeControls","sliderContainer","alignItems","borderBottom","paddingBottom","timeStepButtons","justifyContent","timeScaleContainer","borderTop","paddingTop","svgContainer","background","navigationButtons","timeSlider","height","WebkitAppearance","appearance","outline","opacity","transition","cursor","displayMenuButton","infoButton","displayMenu","top","right","backgroundColor","border","zIndex","boxShadow","menuItem","checkmark","fontWeight","sliderStyle","style","children","onChange","Number","disabled","className","fileName","_jsxFileName","lineNumber","columnNumber","flexWrap","_graphData$nodes$find3","_graphData$nodes$find4","onClick","secondaryButton","marginRight","toFixed","primaryButton","ref","sourceNode","targetNode","midX","midY","x1","y1","x2","y2","stroke","strokeWidth","textAnchor","fill","cx","cy","r","centerX","distanceInfo","nextDropletFront","distanceLabelX","strokeLinecap","strokeDasharray","_dropletHistory","maxTime","pumpSpecificEvents","transform","arr","nextEvent","timePosition","nextTimePosition","maxSpeed","normalizedHeight","_dropletHistory2","currentEvents","detectorSpecificEvents","eventSubtype","initialPosition","title","onAction","detector","detectorName","onClose","isVisible","left","bottom","pointerEvents","fallback","props","_c","$RefreshReg$"],"sources":["E:/flow chemistry/fluidicGUI/frontend/fluidicgui/src/components/Simulation/Simulation.js"],"sourcesContent":["import React, { useState, useEffect, useCallback, useRef, Suspense } from 'react';\r\nimport { ReactFlowProvider, useNodesState, useEdgesState } from 'react-flow-renderer';\r\nimport PumpActions from './NodeActions/PumpActions';\r\nimport DraggablePanel from './DraggablePanel';\r\nimport { convertToHardwareValuesPump } from '../../utils/pumpCalculations';\r\nimport { useButtonStyles } from '../../styles/ButtonStyleProvider';\r\nimport { backgroundVariants } from '../../styles/backgroundStyles';\r\nimport {\r\n  findOutletNode,\r\n  findFurthestNode,\r\n  orderNodesByDistance,\r\n  calculateEdgeVolume,\r\n  getVolumeBetweenNodes,\r\n  findConnectedPump,\r\n  getPumpSpeed,\r\n  getPumpsBetweenPositions,\r\n  cleanAndSortEventList,\r\n  getPumpSpeedAtTime,\r\n  sendEventsToDevices,\r\n  setOfMainLineNodes,\r\n  setOfSecondaryLineNodes\r\n} from '../../utils/simulationUtils';\r\nimport './simulation.css'; // We'll create this CSS file\r\nimport SvgDefs from './SvgDefs';\r\nimport { calculateEdgePoints, createLabels } from '../../utils/flowchartUtils';\r\nimport USBSpectrometer from './USBSpectrometer';\r\nimport SpectrometerMQTT from './SpectrometerMQTT';\r\nimport PumpPanel from './PumpPanel';\r\n\r\nconst Simulation = ({ nodes = [], edges = [], droplets = [], selectedCarrierPumps = [], onBack, onNext }) => {\r\n  const buttonVariants = useButtonStyles();\r\n  const [graphData, setGraphData] = useState({ nodes: [], links: [] });\r\n  const [simulationDroplets, setSimulationDroplets] = useState([]);\r\n  const [isSimulationRunning, setIsSimulationRunning] = useState(false);\r\n  const [key, setKey] = useState(0);\r\n  const [currentTime, setCurrentTime] = useState(0);\r\n  const [timeScale, setTimeScale] = useState(1); // Default 1x speed\r\n  const animationFrameRef = useRef();\r\n  const lastFrameTimeRef = useRef();\r\n  const [currentBlockDroplets, setCurrentBlockDroplets] = useState([]);\r\n  const [dropletHistory, setDropletHistory] = useState([]);\r\n  const [currentTimepoint, setCurrentTimepoint] = useState(0);\r\n  const [pumpEvents, setPumpEvents] = useState([]);\r\n  const [detectorEvents, setDetectorEvents] = useState([]);\r\n  const [displayPumpSpeeds, setDisplayPumpSpeeds] = useState(false);\r\n  const [displayNodeIds, setDisplayNodeIds] = useState(false);\r\n  const [displayDropletInfo, setDisplayDropletInfo] = useState(false);\r\n  const [displayDropletGaps, setDisplayDropletGaps] = useState(true);\r\n  const [displayEdgeLabels, setDisplayEdgeLabels] = useState(false);\r\n  const [isDisplayMenuOpen, setDisplayMenuOpen] = useState(false);\r\n  const [displayTimelineDropletInfo, setDisplayTimelineDropletInfo] = useState(false);\r\n  const [displayDetectorEvents, setDisplayDetectorEvents] = useState(false);\r\n  const displayMenuRef = useRef(null);\r\n  const [selectedNode, setSelectedNode] = useState(null);\r\n  const [ws, setWs] = useState(null);\r\n  const [pumpPanelPosition, setPumpPanelPosition] = useState({ x: window.innerWidth - 300, y: 100 });\r\n  const [visiblePumpPanel, setVisiblePumpPanel] = useState(null);\r\n  const [isSendingEvents, setIsSendingEvents] = useState(false);\r\n  const graphRefs = useRef({});\r\n  const [overlayComponent, setOverlayComponent] = useState(null);\r\n\r\n  // Add at the beginning of the component, after the state initialization\r\n  useEffect(() => {\r\n    // Log all nodes and their types for debugging\r\n    console.log('All nodes:', nodes);\r\n    if (nodes && nodes.length > 0) {\r\n      console.log('Node types in simulation:', nodes.map(node => ({\r\n        id: node.id,\r\n        type: node.type,\r\n        dataType: node.data?.type\r\n      })));\r\n    }\r\n  }, [nodes]);\r\n\r\n  useEffect(() => {\r\n    // Create WebSocket connection\r\n    const websocket = new WebSocket('ws://localhost:4000');\r\n    \r\n    websocket.onopen = () => {\r\n      console.log('Connected to WebSocket server');\r\n    };\r\n\r\n    websocket.onerror = (error) => {\r\n      console.error('WebSocket error:', error);\r\n    };\r\n\r\n    setWs(websocket);\r\n\r\n    // Cleanup on unmount\r\n    return () => {\r\n      if (websocket) {\r\n        websocket.close();\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  const sendingEventsToDevices = () => {\r\n    setIsSendingEvents(true);\r\n    sendEventsToDevices(pumpEvents, ws, nodes);\r\n    // Send measurement timepoints to spectrometers\r\n    sendMeasurementTimepointsToSpectrometers(detectorEvents, ws, nodes);\r\n    // Reset simulation state\r\n    setCurrentTime(0);\r\n    setCurrentTimepoint(0);\r\n    setIsSimulationRunning(true);\r\n    setDropletHistory([]);\r\n    // Generate new event list\r\n    generateEventList([{ droplets: droplets }]);\r\n  };\r\n\r\n  // Add function to send measurement timepoints to spectrometers via MQTT\r\n  const sendMeasurementTimepointsToSpectrometers = (detectorEvents, websocket, nodes) => {\r\n    if (!websocket || !detectorEvents || !nodes) {\r\n      console.warn('Missing required parameters for sending measurement timepoints');\r\n      return;\r\n    }\r\n\r\n    // Group detector events by detector/spectrometer ID\r\n    const eventsByDetector = detectorEvents.reduce((acc, event) => {\r\n      if (!acc[event.target]) {\r\n        acc[event.target] = [];\r\n      }\r\n      acc[event.target].push(event);\r\n      return acc;\r\n    }, {});\r\n\r\n    // Send timepoints to each spectrometer\r\n    Object.entries(eventsByDetector).forEach(([detectorId, events]) => {\r\n      const detectorNode = nodes.find(node => node.id === detectorId);\r\n      \r\n      // Check if this is an MQTT spectrometer\r\n      if (detectorNode && (detectorNode.type === 'MQTTSpectrometer' || detectorNode.data?.type === 'MQTTSpectrometer')) {\r\n        // Extract MQTT name from detector properties\r\n        const mqttName = detectorNode.data?.properties?.find(prop => prop.name === 'mqttName')?.value || \r\n                        detectorNode.data?.properties?.find(prop => prop.name === 'mqtt_name')?.value ||\r\n                        detectorId; // fallback to detector ID\r\n        \r\n        // Extract timepoints from events (convert to milliseconds)\r\n        const timepoints = events.map(event => Math.round(event.time * 1000));\r\n        \r\n        // Create MQTT message\r\n        const mqttMessage = {\r\n          type: 'mqtt_publish',\r\n          topic: `${mqttName}/request/measurement_timepoints`,\r\n          payload: {\r\n            timepoints: timepoints,\r\n            timestamp: Date.now(),\r\n            detectorId: detectorId\r\n          }\r\n        };\r\n\r\n        // Send via WebSocket\r\n        try {\r\n          websocket.send(JSON.stringify(mqttMessage));\r\n          console.log(`Sent measurement timepoints to ${mqttName}:`, timepoints);\r\n        } catch (error) {\r\n          console.error(`Failed to send measurement timepoints to ${mqttName}:`, error);\r\n        }\r\n      }\r\n    });\r\n  };\r\n\r\n  // Add effect to handle automatic memory addition when events are being sent\r\n  useEffect(() => {\r\n    if (isSendingEvents) {\r\n      // Get all graph refs and add data to memory\r\n      Object.values(graphRefs.current).forEach(graphRef => {\r\n        if (graphRef && graphRef.current && graphRef.current.addToMemory) {\r\n          graphRef.current.addToMemory();\r\n        }\r\n      });\r\n    }\r\n  }, [isSendingEvents]);\r\n\r\n  const eventType = ['setPumpSpeed', 'setThermostatTemperature', 'setLedIntensity', 'wait', 'blockEnd'];\r\n\r\n  const calculateVolumesBetweenThermostats = (graphData) => {\r\n  \r\n    // Find outlet node first\r\n    const outletNode = findOutletNode(graphData.nodes);\r\n  \r\n    const visited = new Set();\r\n    const queue = [[outletNode.id, 0, []]]; // [nodeId, accumulated volume, path of thermostats]\r\n    const thermostatVolumes = [];\r\n  \r\n    while (queue.length > 0) {\r\n      let [currentNodeId, accumulatedVolume, thermostatPath] = queue.shift();\r\n      const currentNode = graphData.nodes.find(n => n.id === currentNodeId);\r\n  \r\n      if (!currentNode) continue;\r\n      \r\n      // Track all visited nodes to prevent infinite loops\r\n      if (visited.has(currentNodeId)) continue;\r\n      visited.add(currentNodeId);\r\n  \r\n      // If we found a thermostat, add it to the path\r\n      let updatedPath = [...thermostatPath];\r\n      if (currentNode.type === 'thermostat') {\r\n        if (thermostatPath.length > 0) {\r\n          thermostatVolumes.push({\r\n            startThermostatId: thermostatPath[thermostatPath.length - 1],\r\n            endThermostatId: currentNodeId,\r\n            volume: accumulatedVolume\r\n          });\r\n        }\r\n        updatedPath.push(currentNodeId);\r\n        // Reset accumulated volume after finding a thermostat\r\n        accumulatedVolume = 0;\r\n      }\r\n  \r\n      // Find all connected edges and nodes\r\n      const connectedEdges = graphData.links.filter(link => \r\n        link.source === currentNodeId || link.target === currentNodeId\r\n      );\r\n  \r\n      for (const edge of connectedEdges) {\r\n        const nextNodeId = edge.source === currentNodeId ? edge.target : edge.source;\r\n        const nextNode = graphData.nodes.find(n => n.id === nextNodeId);\r\n        \r\n        // Skip paths to pumps\r\n        if (nextNode && nextNode.type !== 'pump') {\r\n          const edgeVolume = calculateEdgeVolume(edge);\r\n          queue.push([nextNodeId, accumulatedVolume + edgeVolume, updatedPath]);\r\n        }\r\n      }\r\n    }\r\n  \r\n    return thermostatVolumes;\r\n  };\r\n//add something to handle lack of thermostat\r\n  const divideDropletsIntoBlocks = (droplets, thermostatVolumes) => {\r\n\r\n    if (thermostatVolumes.length === 0) {\r\n      return [{\r\n        droplets: droplets,\r\n        thermostatId: null,\r\n        totalVolume: droplets.reduce((acc, droplet) => acc + droplet.actualVolume, 0),\r\n        temperature: null,\r\n        time: null\r\n      }];\r\n    }\r\n\r\n    const furthestNode = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links);\r\n\r\n    const volumeToFurthestNode = getVolumeBetweenNodes(thermostatVolumes[0].endThermostatId, furthestNode.id, graphData.nodes, graphData.links);\r\n    \r\n    if (!droplets.length || !thermostatVolumes.length) return [];\r\n\r\n    const blocks = [];\r\n    let currentBlock = {\r\n      droplets: [],\r\n      thermostatId: thermostatVolumes[0].endThermostatId,\r\n      totalVolume: 0,\r\n      temperature: null,\r\n      time: null\r\n    };\r\n\r\n    // Helper to finalize a block and start a new one\r\n    const finalizeBlock = (thermostatId, temperature, time) => {\r\n      if (currentBlock.droplets.length > 0) {\r\n        // Add volumeToFurthestNode to the surfixVolume of the last droplet in the block\r\n        const lastDroplet = currentBlock.droplets[currentBlock.droplets.length - 1];\r\n        const surfixParam = lastDroplet.parameters.find(p => p.name === 'surfixVolume');\r\n        if (surfixParam) {\r\n          surfixParam.value = Math.max(volumeToFurthestNode, surfixParam.value);\r\n        } else {\r\n          lastDroplet.parameters.push({\r\n            name: 'surfixVolume',\r\n            value: volumeToFurthestNode\r\n          });\r\n        }\r\n        \r\n        blocks.push({ ...currentBlock });\r\n      }\r\n      currentBlock = {\r\n        droplets: [],\r\n        thermostatId: thermostatId,\r\n        totalVolume: 0,\r\n        temperature: temperature,\r\n        time: time\r\n      };\r\n    };\r\n\r\n    // Process droplets in order\r\n    for (let i = 0; i < droplets.length; i++) {\r\n      const droplet = droplets[i];\r\n      const temperature = droplet.parameters.find(p => p.name === 'temperature')?.value;\r\n      const time = droplet.parameters.find(p => p.name === 'time')?.value;\r\n\r\n      // Start new block if temperature or time changes, or if volume limit exceeded\r\n      const relevantVolume = thermostatVolumes.find(tv => \r\n        tv.startThermostatId === currentBlock.thermostatId || \r\n        tv.endThermostatId === currentBlock.thermostatId\r\n      );\r\n\r\n      let dropletVolume = droplet.parameters.find(p => p.name === 'volume')?.value;\r\n      dropletVolume += droplet.parameters.find(p => p.name === 'prefixVolume')?.value;\r\n      \r\n\r\n      if (\r\n        currentBlock.temperature !== temperature ||\r\n        currentBlock.time !== time ||\r\n        (relevantVolume && currentBlock.totalVolume + dropletVolume > relevantVolume.volume)\r\n      ) {\r\n        finalizeBlock(thermostatVolumes[0].endThermostatId, temperature, time);\r\n      }\r\n      dropletVolume += droplet.parameters.find(p => p.name === 'surfixVolume')?.value;\r\n      // Add droplet to current block\r\n      currentBlock.droplets.push(droplet);\r\n      currentBlock.totalVolume += dropletVolume;\r\n      currentBlock.temperature = temperature;\r\n      currentBlock.time = time;\r\n    }\r\n\r\n    // Finalize last block\r\n    finalizeBlock(null, null, null);\r\n\r\n    return blocks;\r\n  };\r\n\r\n  function printDropletFrontPositionsAndSpeeds(droplets) {\r\n    droplets.forEach(droplet => {\r\n      console.log(`Droplet ID: ${droplet.id}, Front Volumetric Position: ${droplet.frontVolumetricPosition}, Front time to next node  : ${droplet.frontTimeToReachNextNode}, Front Volumetric Distance to next node: ${droplet.frontVolumetricDistanceToNextNode}, Rear Volumetric Position: ${droplet.rearVolumetricPosition}, Rear time to next node: ${droplet.rearTimeToReachNextNode}, Rear Volumetric Distance to next node: ${droplet.rearVolumetricDistanceToNextNode}, frontNextNodeID: ${droplet.frontNextNodeID}, rearNextNodeID: ${droplet.rearNextNodeID}`);\r\n    });\r\n  }\r\n\r\n  const extractPumpEvents = (eventList) => {\r\n    // eventList is now an array of arrays, where each inner array contains events for a specific pump\r\n    return eventList\r\n      .flat() // Flatten the array of arrays\r\n      .filter(event => event.type === 'setPumpSpeed')\r\n      .sort((a, b) => a.time - b.time);\r\n  };\r\n\r\n  const extractDetectorEvents = (eventList) => {\r\n    // Extract detector/spectrometer measurement events\r\n    return eventList\r\n      .flat() // Flatten the array of arrays\r\n      .filter(event => event.type === 'setDetectorMeasurement')\r\n      .sort((a, b) => a.time - b.time);\r\n  };\r\n\r\n  const getDetectorEventsAtTime = (detectorId, detectorEvents, currentTime) => {\r\n    return detectorEvents.filter(event => \r\n      event.target === detectorId && \r\n      Math.abs(event.time - currentTime) < 0.1 // Within 0.1 second tolerance\r\n    );\r\n  };\r\n\r\n  const recalculateEventListForDevices = (eventList) => {\r\n    const deviceEventMap = new Map();\r\n\r\n    const convertPumpEvent = (event, deviceProperties) => {\r\n      // Find properties by name from the properties array\r\n      const syringeDiameter = deviceProperties.find(p => p.name === 'diameter')?.default || 0;\r\n      const syringeLength = deviceProperties.find(p => p.name === 'length')?.default || 0;\r\n      const stepsPerRevolution = deviceProperties.find(p => p.name === 'steps per revolution')?.default || 0;\r\n      const lead = deviceProperties.find(p => p.name === 'lead')?.default || 0;\r\n\r\n      const syringeArea = Math.PI * Math.pow(syringeDiameter / 2, 2);\r\n      const linearSpeed = Math.abs(event.value) / syringeArea;\r\n      const stepsPerMm = stepsPerRevolution / lead;\r\n      const stepsPerSecond = linearSpeed * stepsPerMm;\r\n      const delayMicroseconds = stepsPerSecond > 0 ? \r\n        Math.round(1000000 / stepsPerSecond) : \r\n        0;\r\n\r\n      return {\r\n        target: event.target,\r\n        time: Math.round(event.time * 1000000),\r\n        delay: delayMicroseconds\r\n      };\r\n    };\r\n\r\n    const convertThermostatEvent = (event, deviceProperties) => {\r\n      // Placeholder for thermostat conversion logic\r\n      return {\r\n        target: event.target,\r\n        time: Math.round(event.time * 1000000),\r\n        temperature: event.value,\r\n        // Add other thermostat-specific parameters here\r\n      };\r\n    };\r\n\r\n    const convertLedEvent = (event, deviceProperties) => {\r\n      // Placeholder for LED conversion logic\r\n      return {\r\n        target: event.target,\r\n        time: Math.round(event.time * 1000000),\r\n        intensity: event.value,\r\n        // Add other LED-specific parameters here\r\n      };\r\n    };\r\n\r\n    const convertDetectorEvent = (event, deviceProperties) => {\r\n      // Placeholder for detector conversion logic\r\n      return {\r\n        target: event.target,\r\n        time: Math.round(event.time * 1000000),\r\n        setting: event.value,\r\n        // Add other detector-specific parameters here\r\n      };\r\n    };\r\n\r\n    eventList.forEach(deviceEventList => {\r\n      if (!deviceEventList.length) return;\r\n\r\n      const targetId = deviceEventList[0].target;\r\n      const deviceNode = nodes.find(node => node.id === targetId);\r\n      \r\n      if (!deviceNode || !deviceNode.data) {\r\n        console.error(`Device node or data not found for ID: ${targetId}`);\r\n        return;\r\n      }\r\n\r\n      const deviceEvents = deviceEventList.map(event => {\r\n        switch (event.type) {\r\n          case 'setPumpSpeed':\r\n            return convertPumpEvent(event, deviceNode.data.properties);\r\n          \r\n          case 'setThermostatTemperature':\r\n            return convertThermostatEvent(event, deviceNode.data.properties);\r\n          \r\n          case 'setLedIntensity':\r\n            return convertLedEvent(event, deviceNode.data.properties);\r\n          \r\n          case 'setDetectorSetting':\r\n            return convertDetectorEvent(event, deviceNode.data.properties);\r\n          \r\n          default:\r\n            console.warn(`Unknown event type: ${event.type}`);\r\n            return null;\r\n        }\r\n      }).filter(Boolean); // Remove any null events\r\n\r\n      if (deviceEvents.length > 0) {\r\n        deviceEventMap.set(targetId, deviceEvents);\r\n      }\r\n    });\r\n    console.log('deviceEventMap: ', Array.from(deviceEventMap.values()));\r\n    return Array.from(deviceEventMap.values());\r\n  };\r\n\r\n  const generateEventList = (blocks) => {\r\n    // Early exit if blocks array is invalid\r\n    if (!blocks || !Array.isArray(blocks) || blocks.length === 0) {\r\n      console.warn('No valid blocks found for event generation');\r\n      return [];\r\n    }\r\n\r\n    const orderedNodes = orderNodesByDistance(findOutletNode(graphData.nodes), graphData.nodes, graphData.links);\r\n    console.log('orderedNodes: ', orderedNodes);\r\n    \r\n    // Early exit if no ordered nodes\r\n    if (!orderedNodes || orderedNodes.length === 0) {\r\n      console.warn('No ordered nodes found for event generation');\r\n      return [];\r\n    }\r\n    \r\n    let eventList = [];\r\n    let dropletSnapshot = [];\r\n    \r\n    // Validate block droplets\r\n    if (!blocks[0] || !blocks[0].droplets || !Array.isArray(blocks[0].droplets) || blocks[0].droplets.length === 0) {\r\n      console.warn('No valid droplets found in blocks for event generation');\r\n      return [];\r\n    }\r\n    \r\n    const i = 0;\r\n    const currentBlockDroplets = blocks[i].droplets;\r\n    \r\n    // Add fallback for volumetricSpeed in case it's not found\r\n    const dropletWithParams = currentBlockDroplets.find(d => d && d.parameters && Array.isArray(d.parameters));\r\n    if (!dropletWithParams) {\r\n      console.warn('No droplet with valid parameters found');\r\n      return [];\r\n    }\r\n    \r\n    // Make sure we can find the volumetricSpeed parameter or use a default\r\n    const volumetricSpeedParam = dropletWithParams.parameters.find(p => p && p.name === 'volumetricSpeed');\r\n    const commonVolumetricSpeed = volumetricSpeedParam?.value || 1;\r\n    console.log('Using volumetricSpeed:', commonVolumetricSpeed);\r\n    \r\n    //adds some parameters to nodes\r\n    orderedNodes.forEach(node => {\r\n      node.inletVolumetricSpeed = commonVolumetricSpeed;\r\n      node.outletVolumetricSpeed = commonVolumetricSpeed;\r\n      const pump = findConnectedPump(node.node.id, graphData.nodes, graphData.links);\r\n      if (pump) {\r\n        node.connectedPump = pump;\r\n      }\r\n      else {\r\n        node.connectedPump = 0;\r\n      }\r\n      node.connectedPumpRatio = 0;\r\n      node.connectedPumpSpeedAtPause = 0;\r\n      node.pumpSpeedMultiplier = 1;\r\n      //node.requestedRatio = 0;\r\n      node.pauseLevel = 0;\r\n\r\n    });\r\n    //ustawia carrier pump na odpowiednią predkość\r\n    const carrierPumpConnector = graphData.links.find(link => link.source === selectedCarrierPumps[0]).target;\r\n    if (carrierPumpConnector) {\r\n      const connectorNode = orderedNodes.find(node => node.node.id === carrierPumpConnector);\r\n      connectorNode.inletVolumetricSpeed = commonVolumetricSpeed;\r\n      connectorNode.outletVolumetricSpeed = commonVolumetricSpeed;\r\n      connectorNode.connectedPump = graphData.nodes.find(node => node.id === selectedCarrierPumps[0]);\r\n      connectorNode.connectedPumpRatio = 1;\r\n      connectorNode.connectedPumpSpeedAtPause = commonVolumetricSpeed;\r\n      //connectorNode.requestedRatio = 0;\r\n      connectorNode.pauseLevel = 0;\r\n    }\r\n    let event = { //it is ok\r\n      type: 'setPumpSpeed',\r\n      target: selectedCarrierPumps[0],\r\n      time: 0,\r\n      value: commonVolumetricSpeed\r\n    };\r\n    eventList.push(event);\r\n\r\n    orderedNodes.filter(node => node.node.type === 'pump' && node.node.id !== selectedCarrierPumps[0]).forEach(pump => {\r\n      event = {//it is ok\r\n        type: 'setPumpSpeed',\r\n        target: pump.node.id,\r\n        time: 0,\r\n        value: 0\r\n      };\r\n      eventList.push(event);\r\n      \r\n    });\r\n\r\n    \r\n    let position = -0.001;\r\n    //prepares all droplets in block and calculates some parameters\r\n    currentBlockDroplets.forEach(droplet => {\r\n      const prefixVolume = droplet.parameters.find(p => p.name === 'prefixVolume')?.value;\r\n      const surfixVolume = droplet.parameters.find(p => p.name === 'surfixVolume')?.value;\r\n\r\n      droplet.frontVolumetricSpeed = commonVolumetricSpeed;\r\n      droplet.rearVolumetricSpeed = commonVolumetricSpeed;\r\n      droplet.frontVolumetricPosition = position - prefixVolume;\r\n      droplet.rearVolumetricPosition = droplet.frontVolumetricPosition;\r\n      droplet.frontVolumetricDistanceToNextNode = Math.abs(droplet.frontVolumetricPosition);\r\n      droplet.rearVolumetricDistanceToNextNode = Math.abs(droplet.rearVolumetricPosition); \r\n      droplet.frontTimeToReachNextNode = 0;\r\n      droplet.rearTimeToReachNextNode = 0;\r\n      droplet.frontNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\r\n      droplet.rearNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\r\n      droplet.pumpSpeedMultiplier = 1;\r\n      droplet.pauseLevel = 0;\r\n      droplet.frontVolumetricSpeedAtPause = 0;\r\n      droplet.rearVolumetricSpeedAtPause = 0;\r\n      droplet.stoppingDroplet = false;\r\n      droplet.initialPumping = false;\r\n\r\n      position -= ( prefixVolume + surfixVolume);\r\n    });\r\n    console.log('findFurthestNode: ', findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id);\r\n    console.log('Droplet positions initialized, nodes ready');\r\n\r\n    let lastDropletRearPosition = currentBlockDroplets[currentBlockDroplets.length - 1].rearVolumetricPosition;\r\n    let outletNodePosition = orderedNodes[0].node.volumetricPosition; \r\n    let timePassed = 0; //in s\r\n    let newTimePassed = 0;\r\n\r\n    // Simulate the movement of droplets in the current block\r\n    currentBlockDroplets.forEach(droplet => {\r\n      droplet.frontTimeToReachNextNode = Math.abs(droplet.frontVolumetricDistanceToNextNode / droplet.frontVolumetricSpeed);\r\n      droplet.rearTimeToReachNextNode = Math.abs(droplet.rearVolumetricDistanceToNextNode / droplet.rearVolumetricSpeed);\r\n    });\r\n\r\n    while (lastDropletRearPosition < outletNodePosition) {\r\n      \r\n      let smallestFrontTime = Infinity;\r\n      let smallestRearTime = Infinity;\r\n      let smallestFrontTimeDroplet = [];\r\n      let smallestRearTimeDroplet = [];\r\n\r\n      currentBlockDroplets.forEach(droplet => {// Update the smallest front and rear times and associated droplet(s) based on the current droplet's front and rear times to reach the next node.\r\n        \r\n        if (Math.abs(droplet.frontTimeToReachNextNode) < smallestFrontTime) {\r\n          smallestFrontTime = Math.abs(droplet.frontTimeToReachNextNode);\r\n          smallestFrontTimeDroplet = [droplet];\r\n        }\r\n        else if (Math.abs(droplet.frontTimeToReachNextNode) === smallestFrontTime) {\r\n          smallestFrontTimeDroplet.push(droplet);\r\n        }\r\n        if (Math.abs(droplet.rearTimeToReachNextNode) < smallestRearTime) {\r\n          smallestRearTime = Math.abs(droplet.rearTimeToReachNextNode);\r\n          smallestRearTimeDroplet = [droplet];\r\n        }\r\n        else if (Math.abs(droplet.rearTimeToReachNextNode) === smallestRearTime) {\r\n          smallestRearTimeDroplet.push(droplet);\r\n        }\r\n      });\r\n\r\n      newTimePassed += Math.min(Math.abs(smallestFrontTime), Math.abs(smallestRearTime));\r\n\r\n      if (smallestFrontTime === smallestRearTime) {//przypadek w ktorym wiele kropel ma ten sam czas do przejścia do nastepnego noda, rzadki\r\n        \r\n        if (smallestFrontTimeDroplet.length > 1 || smallestRearTimeDroplet.length > 1) {//sprawdź czy wśród nich jest kropla z rear i front\r\n          console.log('Multiple droplets have reached the next node simultaneously');\r\n          console.log('smallestFrontTimeDroplet: ', smallestFrontTimeDroplet);\r\n          console.log('smallestRearTimeDroplet: ', smallestRearTimeDroplet);\r\n          \r\n        }\r\n        else if (smallestFrontTimeDroplet[0] === smallestRearTimeDroplet[0]) {//przypadek gdy kropla ma 0 objętości\r\n          console.log('Both front and rear times are for the same droplet');\r\n          const reachedNode = orderedNodes.find(n => n.node.id === smallestFrontTimeDroplet[0].frontNextNodeID);\r\n          const reachedNodeDistance = orderedNodes.find(node => node.node.id === reachedNode.node.id).distance;\r\n          if (reachedNode.node.type === 'connector') {\r\n\r\n\r\n            const index = currentBlockDroplets.indexOf(smallestFrontTimeDroplet[0]);\r\n            const dropletsOlder = currentBlockDroplets.slice(0, index);\r\n            const dropletsNewer = currentBlockDroplets.slice(index + 1);\r\n\r\n            const ds = [];\r\n            ds.drops = JSON.parse(JSON.stringify(dropletsNewer)); // Create deep copy\r\n            ds.snappedNode = smallestFrontTimeDroplet[0].frontNextNodeID;\r\n            const existingSnapshotIndex = dropletSnapshot.findIndex(snapshot => snapshot.snappedNode === ds.snappedNode);\r\n            if (existingSnapshotIndex !== -1) {\r\n              dropletSnapshot[existingSnapshotIndex] = ds;\r\n            } else {\r\n              dropletSnapshot.push(ds);\r\n            }\r\n\r\n            //aktualizuje starsze krople\r\n            dropletsOlder.forEach(droplet => {\r\n              droplet.frontTimeToReachNextNode -= smallestFrontTime;\r\n              droplet.rearTimeToReachNextNode -= smallestFrontTime;\r\n              droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n              droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n              droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n              droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n            });\r\n\r\n            //aktualizuje kroplę\r\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n            const nextEdge = graphData.links.find(link => link.source === smallestFrontTimeDroplet[0].frontNextNodeID && link.target === nextNode.node.id);\r\n\r\n            if (reachedNode.connectedPump !== null){\r\n              const pumpRatio = smallestFrontTimeDroplet[0].parameters.find(param => param.nodeId === reachedNode.connectedPump.id && param.name === 'ratio')?.value || 0;\r\n              const dropletDesiredVolume = smallestFrontTimeDroplet[0].parameters.find(param => param.name === 'volume')?.value || 0;\r\n              \r\n              reachedNode.connectedPumpRatio = pumpRatio;\r\n              //reachedNode.inletVolumetricSpeed = 0;\r\n              //smallestFrontTimeDroplet[0].frontVolumetricSpeed = reachedNode.outletVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].frontVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].rearVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].rearVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].rearVolumetricSpeed = 0;\r\n              smallestFrontTimeDroplet[0].frontVolumetricPosition = reachedNode.node.volumetricPosition;\r\n              smallestFrontTimeDroplet[0].rearVolumetricPosition = reachedNode.node.volumetricPosition;\r\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n              smallestFrontTimeDroplet[0].rearVolumetricDistanceToNextNode = 0; \r\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode/smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].rearTimeToReachNextNode = dropletDesiredVolume*pumpRatio/smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\r\n              //smallestFrontTimeDroplet[0].rearNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\r\n              smallestFrontTimeDroplet[0].pumpSpeedMultiplier = 1;\r\n              //smallestFrontTimeDroplet[0].pauseLevel = 0;\r\n              smallestFrontTimeDroplet[0].stoppingDroplet = true;\r\n              smallestFrontTimeDroplet[0].initialPumping = true;\r\n              if (reachedNode.connectedPump.id !==selectedCarrierPumps[0]) {\r\n                event={\r\n                  type: 'setPumpSpeed',\r\n                  target: reachedNode.connectedPump.id,\r\n                  time: newTimePassed,\r\n                  value: smallestFrontTimeDroplet[0].frontVolumetricSpeed\r\n                };\r\n                eventList.push(event);\r\n              }\r\n\r\n              //update newer droplets\r\n              dropletsNewer.forEach(droplet => {\r\n                droplet.pauseLevel += 1;\r\n                if (droplet.pauseLevel===1){\r\n                  droplet.frontVolumetricSpeedAtPause = droplet.frontVolumetricSpeed;\r\n                  if (droplet.stoppingDroplet !== true){\r\n                    droplet.rearVolumetricSpeedAtPause = droplet.rearVolumetricSpeed;\r\n                  }\r\n                }\r\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricSpeed = 0;\r\n                droplet.rearVolumetricSpeed = 0;\r\n                droplet.frontTimeToReachNextNode += smallestFrontTimeDroplet[0].rearTimeToReachNextNode-smallestFrontTime;\r\n                droplet.rearTimeToReachNextNode += smallestFrontTimeDroplet[0].rearTimeToReachNextNode-smallestFrontTime;\r\n              });\r\n              getPumpsBetweenPositions(smallestFrontTimeDroplet[0].frontVolumetricPosition,-1, graphData.nodes, graphData.links).filter(pump => pump.id !== reachedNode.connectedPump.id, ).forEach(pump => {\r\n                \r\n                event={\r\n                  type: 'setPumpSpeed',\r\n                  target: pump.id,\r\n                  time: newTimePassed,\r\n                  value: 0\r\n                };\r\n                eventList.push(event);\r\n              });\r\n            }\r\n            \r\n          }\r\n          else if (reachedNode.type === 'thermostat' || reachedNode.type === 'LED') {\r\n            console.log('reachedNode is thermostat');\r\n          }\r\n          else if (reachedNode.type === 'outlet') {\r\n            console.log('reachedNode is outlet');\r\n          }\r\n          else if (reachedNode.type === 'detector' || reachedNode.type === 'USBSpectrometer' || reachedNode.type === 'MQTTSpectrometer') {\r\n            console.log('reachedNode is detector');\r\n          }\r\n        } \r\n        else {\r\n          console.log('Front and rear times are for different droplets');\r\n        }\r\n      } \r\n\r\n      else if (smallestFrontTime < smallestRearTime) { //przypadek gdzie przód jest przed tyłem\r\n        console.log('Front time is smaller than rear time');\r\n        if (smallestFrontTimeDroplet.length > 1) {\r\n          console.log(`Multiple droplets have reached the next node simultaneously`);\r\n          smallestFrontTimeDroplet.forEach(droplet => {\r\n            // Perform some action for each droplet in smallestFrontTimeDroplet\r\n          });\r\n        }\r\n        else { //przypadek gdy przód jednej kropelki dochodzi do noda\r\n          console.log(`Single droplet front has reached the next node`);\r\n          const reachedNode = orderedNodes.find(n => n.node.id === smallestFrontTimeDroplet[0].frontNextNodeID);\r\n          const reachedNodeDistance = orderedNodes.find(node => node.node.id === reachedNode.node.id).distance;\r\n\r\n          if (reachedNode.node.type === 'connector') { //przypadek gdy dochodzi do connectora\r\n            console.log('reachedNode is connector');\r\n\r\n            const index = currentBlockDroplets.indexOf(smallestFrontTimeDroplet[0]);\r\n            const dropletsOlder = currentBlockDroplets.slice(0, index);\r\n            const dropletsNewer = currentBlockDroplets.slice(index + 1);\r\n\r\n            //aktualizuje kroplę\r\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n            const nextEdge = graphData.links.find(link => link.source === reachedNode.node.id && link.target === nextNode.node.id);\r\n\r\n            if (reachedNode.connectedPump.id !== null){\r\n\r\n              const pumpRatio = smallestFrontTimeDroplet[0].parameters.find(param => param.nodeId === reachedNode.connectedPump.id && param.name === 'ratio')?.value || 0;\r\n              const dropletDesiredVolume = smallestFrontTimeDroplet[0].parameters.find(param => param.name === 'volume')?.value || 0;\r\n              smallestFrontTimeDroplet[0].frontVolumetricPosition = reachedNode.node.volumetricPosition;\r\n              smallestFrontTimeDroplet[0].rearVolumetricPosition += smallestFrontTime * smallestFrontTimeDroplet[0].rearVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].actualVolume =smallestFrontTimeDroplet[0].frontVolumetricPosition-smallestFrontTimeDroplet[0].rearVolumetricPosition;\r\n              reachedNode.inletVolumetricSpeed = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              reachedNode.connectedPumpRatio = pumpRatio;\r\n              smallestFrontTimeDroplet[0].rearTimeToReachNextNode -= smallestFrontTime;\r\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n              smallestFrontTimeDroplet[0].rearVolumetricDistanceToNextNode -= smallestFrontTime * smallestFrontTimeDroplet[0].rearVolumetricSpeed; \r\n\r\n              if (smallestFrontTimeDroplet[0].initialPumping === true){ //przypadek gdy kropla jest w pierwszej fazie pompowania (od 0uL)\r\n                console.log('Kropla jest w pierwszej fazie pompowania');\r\n                //smallestFrontTimeDroplet[0].initialPumping = false;\r\n                const rearTimeLeft = smallestFrontTimeDroplet[0].rearTimeToReachNextNode;\r\n                const totalTimeLeft = rearTimeLeft + smallestFrontTimeDroplet[0].actualVolume/commonVolumetricSpeed;\r\n                console.log('commonVolumetricSpeed: ', commonVolumetricSpeed);\r\n                console.log('smallestFrontTimeDroplet[0].actualVolume: ', smallestFrontTimeDroplet[0].actualVolume);\r\n                console.log('rearTimeLeft: ', rearTimeLeft);\r\n                console.log('totalTimeLeft: ', totalTimeLeft);\r\n                const thispumpspeed = pumpRatio*dropletDesiredVolume/totalTimeLeft;\r\n                console.log('thispumpspeed: ', thispumpspeed);\r\n                reachedNode.connectedPumpSpeedAtPause = thispumpspeed;\r\n              }\r\n\r\n              else {\r\n                console.log('Normalne pompowanie');\r\n                reachedNode.connectedPumpSpeedAtPause = (dropletDesiredVolume*pumpRatio) / (smallestFrontTimeDroplet[0].actualVolume / reachedNode.inletVolumetricSpeed);\r\n              }\r\n\r\n              reachedNode.outletVolumetricSpeed = reachedNode.inletVolumetricSpeed+reachedNode.connectedPumpSpeedAtPause;\r\n              smallestFrontTimeDroplet[0].frontVolumetricSpeed += reachedNode.connectedPumpSpeedAtPause;\r\n              //smallestFrontTimeDroplet[0].rearVolumetricSpeed = 0;\r\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode/smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\r\n              //smallestFrontTimeDroplet[0].rearNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\r\n              //smallestFrontTimeDroplet[0].pumpSpeedMultiplier = 1;\r\n              //smallestFrontTimeDroplet[0].pauseLevel = 0;\r\n              //smallestFrontTimeDroplet[0].frontVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              //smallestFrontTimeDroplet[0].rearVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              //smallestFrontTimeDroplet[0].stoppingDroplet = true;\r\n              event={\r\n                type: 'setPumpSpeed',\r\n                target: reachedNode.connectedPump.id,\r\n                time: newTimePassed,\r\n                value: reachedNode.connectedPumpSpeedAtPause \r\n              };\r\n              eventList.push(event);\r\n              //update newer droplets\r\n              dropletsNewer.forEach(droplet => {\r\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontTimeToReachNextNode -= smallestFrontTime;\r\n                droplet.rearTimeToReachNextNode -= smallestFrontTime;\r\n              });\r\n              //aktualizuje starsze krople\r\n              let accumulatedSpeed = reachedNode.connectedPumpSpeedAtPause;\r\n              dropletsOlder.reverse().forEach(droplet => {\r\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.rearVolumetricSpeed += accumulatedSpeed; \r\n                getPumpsBetweenPositions(droplet.frontVolumetricPosition,droplet.rearVolumetricPosition, graphData.nodes, graphData.links).forEach(pump => {\r\n                  const editedNode = orderedNodes.find(node => node.connectedPump.id === pump.id);\r\n                  //editedNode.pumpSpeedMultiplier = 1;\r\n                  const pumpBoost = editedNode.connectedPumpSpeedAtPause * accumulatedSpeed/editedNode.inletVolumetricSpeed;\r\n                  editedNode.connectedPumpSpeedAtPause += pumpBoost;\r\n                  editedNode.inletVolumetricSpeed += accumulatedSpeed;\r\n                  accumulatedSpeed += pumpBoost;\r\n                  editedNode.outletVolumetricSpeed += accumulatedSpeed;\r\n                  event={\r\n                    type: 'setPumpSpeed',\r\n                    target: pump.id,\r\n                    time: newTimePassed,\r\n                    value: editedNode.connectedPumpSpeedAtPause\r\n                  };\r\n                  eventList.push(event);\r\n                });\r\n                droplet.frontVolumetricSpeed += accumulatedSpeed;\r\n                droplet.frontTimeToReachNextNode = droplet.frontVolumetricDistanceToNextNode/droplet.frontVolumetricSpeed;\r\n                droplet.rearTimeToReachNextNode = droplet.rearVolumetricDistanceToNextNode/droplet.rearVolumetricSpeed;\r\n\r\n              });\r\n            }\r\n          }\r\n          else if (reachedNode.node.type === 'thermostat' || reachedNode.type === 'LED') {//przypadek gdy dochodzi do termostatu\r\n            console.log('reachedNode (thermostat, LED): ', reachedNode);\r\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n            if (nextNode) {\r\n              const nextEdge = graphData.links.find(link => link.source === smallestFrontTimeDroplet[0].frontNextNodeID && link.target === nextNode.node.id);\r\n              //aktualizuje krople\r\n              currentBlockDroplets.forEach(droplet => {\r\n                droplet.frontTimeToReachNextNode -= smallestFrontTime;\r\n                droplet.rearTimeToReachNextNode -= smallestFrontTime;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n              });\r\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\r\n            }\r\n          }\r\n          else if (reachedNode.node.type === 'outlet') { //jeśli ostatni node osiągnięty\r\n            console.log('reachedNode (outlet): ', reachedNode);\r\n            //typowe zaktualizowanie czasu do następnego noda dla reszty kropel i zestallowanie frontu\r\n            currentBlockDroplets.forEach(droplet => {\r\n              droplet.frontTimeToReachNextNode -= smallestFrontTime;\r\n              droplet.rearTimeToReachNextNode -= smallestFrontTime;\r\n              droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n              droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n              droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n              droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n            });\r\n            smallestFrontTimeDroplet[0].frontTimeToReachNextNode = Infinity;\r\n            smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = Infinity;\r\n            smallestFrontTimeDroplet[0].frontNextNodeID = null;\r\n          }\r\n          else if (reachedNode.node.type === 'detector' || reachedNode.node.type === 'USBSpectrometer' || reachedNode.node.type === 'MQTTSpectrometer') { //przypadek gdy dochodzi do detektora\r\n            console.log('reachedNode (detector): ', reachedNode);\r\n            const waitTime = reachedNode.node.properties.find(property => property.name === 'wait time').value;\r\n            const measurementTime = reachedNode.node.properties.find(property => property.name === 'measurement time').value;\r\n            \r\n            // Create detector measurement end event when droplet front reaches detector\r\n            event={\r\n              type: 'setDetectorMeasurement',\r\n              target: reachedNode.node.id,\r\n              time: newTimePassed+waitTime,\r\n              value: 1 \r\n            };\r\n            eventList.push(event);\r\n\r\n            // Add events to set pump speeds before and after measurement\r\n            graphData.nodes.forEach(node => {\r\n              if (node.type === 'pump') {\r\n                const currentSpeed = getPumpSpeedAtTime(node.id, pumpEvents, currentTime);\r\n                event = {\r\n                  type: 'setPumpSpeed',\r\n                  target: node.id,\r\n                  time: newTimePassed + waitTime + measurementTime,\r\n                  value: currentSpeed\r\n                };\r\n                eventList.push(event);\r\n                event = {\r\n                  type: 'setPumpSpeed',\r\n                  target: node.id,\r\n                  time: newTimePassed,\r\n                  value: 0\r\n                };\r\n                eventList.push(event);\r\n              }\r\n            });\r\n            \r\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n            if (nextNode) {\r\n              const nextEdge = graphData.links.find(link => link.source === smallestFrontTimeDroplet[0].frontNextNodeID && link.target === nextNode.node.id);\r\n              //aktualizuje krople\r\n              currentBlockDroplets.forEach(droplet => {\r\n                droplet.frontTimeToReachNextNode -= smallestFrontTime-(measurementTime + waitTime);\r\n                droplet.rearTimeToReachNextNode -= smallestFrontTime-(measurementTime + waitTime);\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n              });\r\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = (smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestFrontTimeDroplet[0].frontVolumetricSpeed)+(measurementTime + waitTime);\r\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\r\n            }\r\n          }\r\n        }\r\n      } \r\n      \r\n      else {//przypadek gdzie tył jest przed przodem\r\n        console.log('Rear time is smaller than front time');\r\n        if (smallestRearTimeDroplet.length > 1) { //przypadek gdy dochodzi do noda wiele kropel\r\n          console.log(`Multiple droplets ends have reached the next node simultaneously`);\r\n          smallestRearTimeDroplet.forEach(droplet => {\r\n            // Perform some action for each droplet in smallestRearTimeDroplet\r\n          });\r\n        } \r\n        else { //przypadek gdy tył jednej kropelki dochodzi do noda\r\n          const reachedNode = orderedNodes.find(n => n.node.id === smallestRearTimeDroplet[0].rearNextNodeID);\r\n          const reachedNodeDistance = orderedNodes.find(node => node.node.id === reachedNode.node.id).distance;\r\n          \r\n          if (reachedNode.node.type === 'connector') { //przypadek gdy dochodzi do connectora\r\n            console.log('reachedNode is connector');\r\n\r\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n            const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\r\n            const index = currentBlockDroplets.indexOf(smallestRearTimeDroplet[0]);\r\n            const dropletsOlder = currentBlockDroplets.slice(0, index);\r\n            const dropletsNewer = currentBlockDroplets.slice(index + 1);\r\n            if (smallestRearTimeDroplet[0].stoppingDroplet === true){ //wznawia jeśli była zatrzymana\r\n              //aktualizuje starsze krople\r\n              dropletsOlder.forEach(droplet => {\r\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n              });\r\n\r\n              //aktualizuje nowsze krople\r\n              dropletsNewer.forEach(droplet => {\r\n                if (droplet.pauseLevel === 1){//\r\n                  droplet.pauseLevel = 0;\r\n                  droplet.frontVolumetricSpeed = droplet.frontVolumetricSpeedAtPause;\r\n                  droplet.rearVolumetricSpeed = droplet.rearVolumetricSpeedAtPause;\r\n                  getPumpsBetweenPositions(droplet.frontVolumetricPosition,droplet.rearVolumetricPosition, graphData.nodes, graphData.links).forEach(pump => {\r\n                    \r\n                    event={\r\n                      type: 'setPumpSpeed',\r\n                      target: pump.id,\r\n                      time: newTimePassed,\r\n                      value: orderedNodes.find(node => node.node.id === pump.id).connectedPumpSpeedAtPause\r\n                    };\r\n                    eventList.push(event);\r\n                  });\r\n                }\r\n                else {\r\n                  droplet.pauseLevel -= 1;\r\n                }\r\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n              });\r\n\r\n              reachedNode.connectedPumpRatio = 0; \r\n              //reachedNode.inletVolumetricSpeed = 0;\r\n              //smallestRearTimeDroplet[0].frontVolumetricSpeed = reachedNode.outletVolumetricSpeed;\r\n              smallestRearTimeDroplet[0].rearVolumetricSpeed = smallestRearTimeDroplet[0].rearVolumetricSpeedAtPause;\r\n              smallestRearTimeDroplet[0].frontVolumetricPosition += smallestRearTimeDroplet[0].frontVolumetricSpeed*smallestRearTime;\r\n              smallestRearTimeDroplet[0].rearVolumetricPosition = reachedNode.node.volumetricPosition;\r\n              smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode -= smallestRearTimeDroplet[0].frontVolumetricSpeed*smallestRearTime;\r\n              smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge); \r\n              smallestRearTimeDroplet[0].frontTimeToReachNextNode = smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode/smallestRearTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode/smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n              //smallestRearTimeDroplet[0].frontNextNodeID = nextNode.id;\r\n              smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\r\n              //smallestRearTimeDroplet[0].pumpSpeedMultiplier = 1;\r\n              //smallestRearTimeDroplet[0].pauseLevel = 0;\r\n              smallestRearTimeDroplet[0].frontVolumetricSpeedAtPause = smallestRearTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestRearTimeDroplet[0].rearVolumetricSpeedAtPause = smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n              smallestRearTimeDroplet[0].stoppingDroplet = false;\r\n              smallestRearTimeDroplet[0].initialPumping = false;\r\n\r\n              reachedNode.connectedPumpRatio = 0;\r\n              event = {\r\n                type: 'setPumpSpeed',\r\n                target: reachedNode.connectedPump.id,\r\n                time: newTimePassed,\r\n                value: 0\r\n              };\r\n              eventList.push(event);\r\n              event = {\r\n                type: 'setPumpSpeed',\r\n                target: selectedCarrierPumps[0],\r\n                time: newTimePassed,\r\n                value: commonVolumetricSpeed\r\n              };\r\n              eventList.push(event);\r\n\r\n            }\r\n            else {\r\n              console.log('it is not stopper');\r\n              if (reachedNode.connectedPump.id !== null){\r\n                \r\n                const speedDifference = reachedNode.outletVolumetricSpeed - reachedNode.inletVolumetricSpeed;\r\n                //reachedNode.inletVolumetricSpeed = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n                reachedNode.outletVolumetricSpeed = reachedNode.inletVolumetricSpeed;\r\n                reachedNode.connectedPumpRatio = 0;\r\n                reachedNode.connectedPumpSpeedAtPause = 0;\r\n                smallestRearTimeDroplet[0].frontVolumetricPosition += smallestRearTime * smallestRearTimeDroplet[0].frontVolumetricSpeed;\r\n                smallestRearTimeDroplet[0].rearVolumetricPosition = reachedNode.node.volumetricPosition;\r\n                smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode -= smallestRearTime * smallestRearTimeDroplet[0].frontVolumetricSpeed;\r\n                smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge); \r\n                //smallestRearTimeDroplet[0].frontNextNodeID = nextNode.id;\r\n                smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\r\n                //smallestRearTimeDroplet[0].pumpSpeedMultiplier = 1;\r\n                //smallestRearTimeDroplet[0].pauseLevel = 0; \r\n                //smallestRearTimeDroplet[0].stoppingDroplet = true;\r\n                smallestRearTimeDroplet[0].frontVolumetricSpeed = smallestRearTimeDroplet[0].frontVolumetricSpeed-speedDifference;\r\n                //smallestRearTimeDroplet[0].rearVolumetricSpeed = 0;\r\n                smallestRearTimeDroplet[0].frontVolumetricSpeedAtPause = smallestRearTimeDroplet[0].frontVolumetricSpeed;\r\n                //smallestRearTimeDroplet[0].rearVolumetricSpeedAtPause = smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n                smallestRearTimeDroplet[0].frontTimeToReachNextNode = smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].frontVolumetricSpeed;\r\n                smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n                event={\r\n                  type: 'setPumpSpeed',\r\n                  target: reachedNode.connectedPump.id,\r\n                  time: newTimePassed,\r\n                  value: reachedNode.connectedPumpSpeedAtPause \r\n                };\r\n                eventList.push(event);\r\n                //updte newer droplets\r\n                dropletsNewer.forEach(droplet => {\r\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                  droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n                  droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n                });\r\n                //aktualizuje starsze krople\r\n                let accumulatedSpeedDecrease = speedDifference;\r\n                dropletsOlder.reverse().forEach(droplet => {\r\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                  droplet.rearVolumetricSpeed -= accumulatedSpeedDecrease;\r\n                  getPumpsBetweenPositions(droplet.frontVolumetricPosition,droplet.rearVolumetricPosition, graphData.nodes, graphData.links).forEach(pump => {\r\n                    const editedNode = orderedNodes.find(node => node.connectedPump.id === pump.id);\r\n                    const pumpBreak = editedNode.connectedPumpSpeedAtPause * accumulatedSpeedDecrease/editedNode.inletVolumetricSpeed;\r\n                    editedNode.connectedPumpSpeedAtPause -= pumpBreak;\r\n                    editedNode.inletVolumetricSpeed -= accumulatedSpeedDecrease;\r\n                    accumulatedSpeedDecrease += pumpBreak;\r\n                    editedNode.outletVolumetricSpeed -= accumulatedSpeedDecrease;\r\n                    event={\r\n                      type: 'setPumpSpeed',\r\n                      target: pump.id,\r\n                      time: newTimePassed,\r\n                      value: editedNode.connectedPumpSpeedAtPause\r\n                    };\r\n                    eventList.push(event);\r\n                  });\r\n                  droplet.frontVolumetricSpeed -= accumulatedSpeedDecrease;\r\n                  droplet.frontTimeToReachNextNode = droplet.frontVolumetricDistanceToNextNode/droplet.frontVolumetricSpeed;\r\n                  droplet.rearTimeToReachNextNode = droplet.rearVolumetricDistanceToNextNode/droplet.rearVolumetricSpeed;\r\n  \r\n                });\r\n              }\r\n            }\r\n\r\n          }\r\n          else if (reachedNode.node.type === 'thermostat' || reachedNode.node.type === 'LED') {//przypadek gdy dochodzi do termostatu\r\n            console.log('reachedNode thermostat: ', reachedNode);\r\n            \r\n            const isFarthestThermostatOrLED = orderedNodes.filter(node => node.node.type === 'thermostat' || node.node.type === 'LED').every(node => node.distance <= reachedNodeDistance);\r\n            \r\n            // This line checks if the smallestRearTimeDroplet is the last droplet in the currentBlockDroplets array.\r\n            if (isFarthestThermostatOrLED && currentBlockDroplets.length === currentBlockDroplets.indexOf(smallestRearTimeDroplet[0])+1) {\r\n              console.log('This is the farthest thermostat or LED node. Also, last droplet just passed through it.');\r\n              const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n              const waitTime = smallestRearTimeDroplet[0].parameters.find(param => param.nodeId === reachedNode.node.id && param.name === 'time')?.value || 0;\r\n              if (nextNode) {\r\n                const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\r\n                smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n                smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode/smallestRearTimeDroplet[0].rearVolumetricSpeed + smallestRearTime;\r\n                smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\r\n                //aktualizuje resztę kropli\r\n                currentBlockDroplets.forEach(droplet => {\r\n                  droplet.frontTimeToReachNextNode += waitTime - smallestRearTime;\r\n                  droplet.rearTimeToReachNextNode += waitTime - smallestRearTime;\r\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed-waitTime * droplet.frontVolumetricSpeed;//to jest zrobione na razie aby czas się zgadzał\r\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed-waitTime * droplet.rearVolumetricSpeed;\r\n                });\r\n\r\n                let carrierPumpEvent = {\r\n                  type: 'setPumpSpeed',\r\n                  target: selectedCarrierPumps[0], // Assuming 'carrierPumpId' is the ID of the carrier pump\r\n                  time: newTimePassed,\r\n                  value: 0\r\n                };\r\n                eventList.push(carrierPumpEvent);\r\n                carrierPumpEvent = {\r\n                  type: 'setPumpSpeed',\r\n                  target: selectedCarrierPumps[0], // Assuming 'carrierPumpId' is the ID of the carrier pump\r\n                  time: newTimePassed+waitTime,\r\n                  value: commonVolumetricSpeed\r\n                };\r\n                eventList.push(carrierPumpEvent);\r\n              }\r\n            }\r\n            else { //droplet wasnt the last one\r\n              console.log('smallestRearTimeDroplet is not the last droplet in the currentBlockDroplets array');\r\n              const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n              if (nextNode) {\r\n                const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\r\n                //aktualizuje krople\r\n                currentBlockDroplets.forEach(droplet => {\r\n                  droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n                  droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n                });\r\n                smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n                smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n                smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\r\n              }\r\n            }\r\n          }\r\n          else if (reachedNode.node.type === 'outlet') { //jeśli ostatni node osiągnięty\r\n            //typowe zaktualizowanie czasu do następnego noda dla reszty kropel i zestallowanie reara\r\n            //aktualizuje resztę kropli\r\n            currentBlockDroplets.forEach(droplet => {\r\n              droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n              droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n              droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n              droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n              droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n              droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n            });\r\n            smallestRearTimeDroplet[0].frontTimeToReachNextNode = Infinity;\r\n            smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode = Infinity;\r\n            smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = Infinity;\r\n            smallestRearTimeDroplet[0].rearNextNodeID = null;\r\n            smallestRearTimeDroplet[0].rearTimeToReachNextNode = Infinity;\r\n          }\r\n          else if (reachedNode.node.type === 'detector' || reachedNode.node.type === 'USBSpectrometer' || reachedNode.node.type === 'MQTTSpectrometer') { //przypadek gdy dochodzi do detektora\r\n            console.log('reachedNode (detector): ', reachedNode);\r\n            \r\n            \r\n            \r\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n            if (nextNode) {\r\n              const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\r\n              //aktualizuje krople\r\n              currentBlockDroplets.forEach(droplet => {\r\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n              });\r\n              smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n              smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n              smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      timePassed = newTimePassed;\r\n      // Update last droplet rear position\r\n      lastDropletRearPosition = currentBlockDroplets[currentBlockDroplets.length - 1].rearVolumetricPosition;\r\n\r\n      //add code that preserves droplets positions and speeds for visualization\r\n      const dropletState = {\r\n        time: timePassed,\r\n        droplets: currentBlockDroplets.map(droplet => ({\r\n          id: droplet.id,\r\n          frontVolumetricPosition: droplet.frontVolumetricPosition,\r\n          rearVolumetricPosition: droplet.rearVolumetricPosition,\r\n          frontVolumetricSpeed: droplet.frontVolumetricSpeed,\r\n          rearVolumetricSpeed: droplet.rearVolumetricSpeed,\r\n          pumpSpeedMultiplier: droplet.pumpSpeedMultiplier,\r\n          frontTimeToReachNextNode: droplet.frontTimeToReachNextNode,\r\n          rearTimeToReachNextNode: droplet.rearTimeToReachNextNode,\r\n          frontVolumetricDistanceToNextNode: droplet.frontVolumetricDistanceToNextNode,\r\n          rearVolumetricDistanceToNextNode: droplet.rearVolumetricDistanceToNextNode,\r\n          volume: droplet.parameters.find(p => p.name === 'volume')?.value || 0,\r\n          frontNextNodeID: droplet.frontNextNodeID,\r\n          rearNextNodeID: droplet.rearNextNodeID\r\n        }))\r\n      };\r\n      setDropletHistory(prev => [...prev, dropletState]);\r\n\r\n      \r\n\r\n      //if (timePassed > 9999) {//here for testing, preventing infinite loop\r\n      //  lastDropletRearPosition = 88100;\r\n      //}\r\n\r\n    }\r\n    event = {//it is ok\r\n      type: 'setPumpSpeed',\r\n      target: selectedCarrierPumps[0],\r\n      time: timePassed,\r\n      value: 0\r\n    };\r\n    eventList.push(event);\r\n\r\n    eventList = cleanAndSortEventList(eventList);\r\n    console.log('dropletHistory in event generator: ', dropletHistory);\r\n    console.log('eventList: ', eventList.sort((a, b) => a.time - b.time));\r\n    setPumpEvents(extractPumpEvents(eventList));\r\n    setDetectorEvents(extractDetectorEvents(eventList));\r\n    console.log('Detector events:', extractDetectorEvents(eventList));\r\n    return eventList;\r\n  }\r\n  // First useEffect to set initial graphData\r\n  useEffect(() => {\r\n    setDropletHistory([]);\r\n    if (nodes.length > 0 && edges.length > 0) {\r\n      const graphNodes = nodes.map(node => ({\r\n        id: node.id,\r\n        label: node.data.label,\r\n        type: node.data.type,\r\n        x: 0,\r\n        y: 0,\r\n        volumetricPosition: 0\r\n      }));\r\n\r\n      const graphLinks = edges.map(edge => ({\r\n        source: edge.source,\r\n        target: edge.target,\r\n        length: edge.data?.properties?.length || 100,\r\n        diameter: edge.data?.properties?.diameter || 1,\r\n      }));\r\n\r\n      setGraphData({ nodes: graphNodes, links: graphLinks });\r\n    }\r\n    \r\n  }, [nodes, edges]);\r\n\r\n  // Second useEffect to calculate nodes positions and set up simulation data\r\n  useEffect(() => {\r\n    if (!graphData.nodes.length || !graphData.links.length || !droplets.length) {\r\n      console.log('Missing required data for simulation setup:', {\r\n        nodesLength: graphData.nodes.length,\r\n        linksLength: graphData.links.length,\r\n        dropletsLength: droplets.length\r\n      });\r\n      return;\r\n    }\r\n\r\n    const graphNodes = [...graphData.nodes];\r\n    \r\n    // Find outlet node first\r\n    const outletNode = findOutletNode(graphData.nodes);\r\n    if (!outletNode) {\r\n      console.error('No outlet node found. Cannot set up simulation.');\r\n      return;\r\n    }\r\n\r\n    // Get ordered nodes from outlet\r\n    const orderedNodes = orderNodesByDistance(outletNode, graphData.nodes, graphData.links);\r\n    \r\n    // Separate nodes into main line and secondary line\r\n    const mainLineNodes = orderedNodes\r\n      .filter(({node}) => \r\n        setOfMainLineNodes.includes(node.type))\r\n      .reverse();\r\n      \r\n    const secondaryLineNodes = orderedNodes\r\n      .filter(({node}) => setOfSecondaryLineNodes.includes(node.type))\r\n      .sort((a, b) => b.distance - a.distance);\r\n\r\n    // Position settings\r\n    const mainLineY = 300;\r\n    const secondaryLineY = 150;\r\n    const pumpSpacing = 100; // Increased horizontal spacing between pumps\r\n    let currentX = 100;\r\n\r\n    // Position main line nodes\r\n    let currentVolumetricPosition = 0;\r\n    mainLineNodes.forEach(({node}, index) => {\r\n      const graphNode = graphNodes.find(n => n.id === node.id);\r\n      if (!graphNode) return;\r\n\r\n      graphNode.x = currentX;\r\n      graphNode.y = mainLineY;\r\n      graphNode.volumetricPosition = currentVolumetricPosition;\r\n      \r\n      if (index < mainLineNodes.length - 1) {\r\n        const nextNode = mainLineNodes[index + 1];\r\n        const edge = graphData.links.find(e => \r\n          (e.source === graphNode.id && e.target === nextNode.node.id) ||\r\n          (e.target === graphNode.id && e.source === nextNode.node.id)\r\n        );\r\n        \r\n        if (edge && edge.length) {\r\n          currentX += edge.length * 2;\r\n          // Use existing calculateEdgeVolume function\r\n          const edgeVolume = calculateEdgeVolume(edge);\r\n          currentVolumetricPosition += edgeVolume;\r\n        } else {\r\n          currentX += 200;\r\n          currentVolumetricPosition += 150;\r\n        }\r\n      }\r\n    });\r\n\r\n    // Group secondary nodes by distance\r\n    const nodesByDistance = {};\r\n    secondaryLineNodes.forEach(({node, distance}) => {\r\n      if (!nodesByDistance[distance]) {\r\n        nodesByDistance[distance] = [];\r\n      }\r\n      nodesByDistance[distance].push(node);\r\n    });\r\n\r\n    // Position secondary nodes based on their connected main line nodes\r\n    const pumpOffset = 50; // Add this constant for pump spacing\r\n    Object.entries(nodesByDistance).forEach(([distance, nodes]) => {\r\n      nodes.forEach((node, index) => {\r\n        const graphNode = graphNodes.find(n => n.id === node.id);\r\n        if (!graphNode) return;\r\n\r\n        // Find connected main line node through edges\r\n        const connectedEdge = edges.find(e => \r\n          e.source === node.id || e.target === node.id\r\n        );\r\n        \r\n        if (connectedEdge) {\r\n          const connectedNodeId = connectedEdge.source === node.id ? connectedEdge.target : connectedEdge.source;\r\n          const connectedMainNode = graphNodes.find(n => n.id === connectedNodeId);\r\n          \r\n          if (connectedMainNode) {\r\n            // Position pump above its connected main line node with offset if needed\r\n            graphNode.x = connectedMainNode.x + (index * pumpOffset) - ((nodes.length - 1) * pumpOffset / 2);\r\n            graphNode.y = secondaryLineY;\r\n          }\r\n        }\r\n      });\r\n    });\r\n\r\n    setGraphData(prev => ({ ...prev, nodes: graphNodes }));\r\n    \r\n    // Only calculate volumes and blocks if not already done\r\n    if (currentBlockDroplets.length === 0) {\r\n      console.log('Calculating thermostat volumes and blocks for droplets:', droplets.length);\r\n      const thermoVol = calculateVolumesBetweenThermostats(graphData);\r\n      \r\n      // Create deep copy of droplets to avoid mutation issues\r\n      const dropletsCopy = JSON.parse(JSON.stringify(droplets));\r\n      const blocks = divideDropletsIntoBlocks(dropletsCopy, thermoVol);\r\n      \r\n      if (blocks.length > 0) {\r\n        setCurrentBlockDroplets(blocks[0].droplets);\r\n        // Generate event list only once when initializing\r\n        const eventList = generateEventList(blocks);\r\n        const eventListForDevices = recalculateEventListForDevices(eventList);\r\n      }\r\n    }\r\n    \r\n    // Important: the dependency array includes currentBlockDroplets.length to prevent infinite recalculations\r\n  }, [graphData.nodes.length, graphData.links.length, droplets, edges, currentBlockDroplets.length]);\r\n\r\n  const startSimulation = useCallback(() => {\r\n    setIsSimulationRunning(true);\r\n    lastFrameTimeRef.current = null; // Reset the last frame time\r\n  }, []);\r\n\r\n  const stopSimulation = useCallback(() => {\r\n    setIsSimulationRunning(false);\r\n    if (animationFrameRef.current) {\r\n      cancelAnimationFrame(animationFrameRef.current);\r\n      animationFrameRef.current = null;\r\n    }\r\n  }, []);\r\n\r\n  const restartSimulation = useCallback(() => {\r\n    stopSimulation();\r\n    setKey(prevKey => prevKey + 1);\r\n    setCurrentTime(0);\r\n    startSimulation();\r\n  }, [stopSimulation, startSimulation]);\r\n\r\n\r\n  const getNodeColor = (node) => {\r\n    switch (node.type) {\r\n      case 'pump': return '#4CAF50';\r\n      case 'connector': return '#2196F3';\r\n      case 'outlet': return '#F44336';\r\n      default: return '#FFA000'; // Default color for unknown types\r\n    }\r\n  };\r\n\r\n  // Update volumetricToXPosition function\r\n  const volumetricToXPosition = useCallback((volumetricPosition) => {\r\n    const outletNode = findOutletNode(graphData.nodes);\r\n    const furthestNode = findFurthestNode(outletNode, graphData.nodes, graphData.links);\r\n    \r\n    if (!outletNode || !furthestNode) return 0;\r\n\r\n    const totalVolume = getVolumeBetweenNodes(furthestNode.id, outletNode.id, graphData.nodes, graphData.links);\r\n    const outletX = graphData.nodes.find(n => n.id === outletNode.id)?.x || 0;\r\n    const furthestX = graphData.nodes.find(n => n.id === furthestNode.id)?.x || 0;\r\n    \r\n    // Handle edge cases\r\n    if (!totalVolume || totalVolume === 0 || isNaN(totalVolume)) {\r\n      console.warn('Total volume is invalid:', totalVolume);\r\n      return furthestX;\r\n    }\r\n\r\n    if (volumetricPosition === undefined || volumetricPosition === null || isNaN(volumetricPosition)) {\r\n      console.warn('Volumetric position is invalid:', volumetricPosition);\r\n      return furthestX;\r\n    }\r\n\r\n    // Clamp the position to valid range\r\n    const clampedPosition = Math.max(-totalVolume, Math.min(totalVolume, volumetricPosition));\r\n    \r\n    // Apply scaling factor to the position calculation\r\n    const scaledX = furthestX + ((clampedPosition / totalVolume) * (outletX - furthestX));\r\n    \r\n    // Ensure the returned value is a valid number\r\n    if (!isFinite(scaledX) || isNaN(scaledX)) {\r\n      console.warn('Invalid scaled position calculated:', {\r\n        scaledX,\r\n        clampedPosition,\r\n        totalVolume,\r\n        outletX,\r\n        furthestX\r\n      });\r\n      return furthestX;\r\n    }\r\n    \r\n    return scaledX;\r\n  }, [graphData.nodes]);    \r\n\r\n  // Update the updateDropletPositions function\r\n  const updateDropletPositions = useCallback((timestamp) => {\r\n    if (!isSimulationRunning || dropletHistory.length === 0) return;\r\n\r\n    if (!lastFrameTimeRef.current) {\r\n      lastFrameTimeRef.current = timestamp;\r\n      animationFrameRef.current = requestAnimationFrame(updateDropletPositions);\r\n      return;\r\n    }\r\n\r\n    const deltaTime = (timestamp - lastFrameTimeRef.current) / 1000; // Convert to seconds\r\n    const simulationDeltaTime = deltaTime * timeScale;\r\n    \r\n    setCurrentTime(prevTime => {\r\n      const newTime = prevTime + simulationDeltaTime;\r\n      \r\n      // Get the time range of our history\r\n      const lastHistoryTime = dropletHistory[dropletHistory.length - 1].time;\r\n      \r\n      // If we've reached the end, loop back to start\r\n      if (newTime >= lastHistoryTime) {\r\n        setCurrentTime(0);\r\n        return 0;\r\n      }\r\n\r\n      // Find the appropriate states to interpolate between\r\n      const currentState = interpolateDropletState(newTime);\r\n      // Update droplet visualization\r\n      const updatedDroplets = currentState.map(droplet => {\r\n        const frontX = volumetricToXPosition(droplet.frontVolumetricPosition);\r\n        const rearX = volumetricToXPosition(droplet.rearVolumetricPosition);\r\n\r\n        if (isNaN(frontX) || isNaN(rearX)) {\r\n          console.warn('Invalid droplet position calculated:', {\r\n            dropletId: droplet.id,\r\n            frontPosition: droplet.frontVolumetricPosition,\r\n            rearPosition: droplet.rearVolumetricPosition,\r\n            frontX,\r\n            rearX\r\n          });\r\n          return null;\r\n        }\r\n\r\n        return {\r\n          id: droplet.id,\r\n          frontX,\r\n          rearX,\r\n          y: 300,\r\n          volume: droplet.frontVolumetricPosition-droplet.rearVolumetricPosition,\r\n          speed: droplet.frontVolumetricSpeed\r\n        };\r\n      }).filter(Boolean);\r\n\r\n      setSimulationDroplets(updatedDroplets);\r\n      return newTime;\r\n    });\r\n\r\n    lastFrameTimeRef.current = timestamp;\r\n    animationFrameRef.current = requestAnimationFrame(updateDropletPositions);\r\n  }, [isSimulationRunning, timeScale, volumetricToXPosition, dropletHistory]);\r\n\r\n  // Add animation effect\r\n  useEffect(() => {\r\n    if (isSimulationRunning) {\r\n      lastFrameTimeRef.current = null;\r\n      animationFrameRef.current = requestAnimationFrame(updateDropletPositions);\r\n    }\r\n    return () => {\r\n      if (animationFrameRef.current) {\r\n        cancelAnimationFrame(animationFrameRef.current);\r\n      }\r\n    };\r\n  }, [isSimulationRunning, updateDropletPositions]);\r\n\r\n  // Add this helper function for interpolation\r\n  const interpolateDropletState = (time) => {\r\n    if (!dropletHistory.length) return [];\r\n    \r\n    // Find the two closest states\r\n    const index = dropletHistory.findIndex(state => state.time > time);\r\n    if (index === -1) return dropletHistory[dropletHistory.length - 1].droplets;\r\n    if (index === 0) return dropletHistory[0].droplets;\r\n    \r\n    const beforeState = dropletHistory[index - 1];\r\n    const afterState = dropletHistory[index];\r\n    const fraction = (time - beforeState.time) / (afterState.time - beforeState.time);\r\n    \r\n    return beforeState.droplets.map(beforeDroplet => {\r\n      const afterDroplet = afterState.droplets.find(d => d.id === beforeDroplet.id);\r\n      if (!afterDroplet) return beforeDroplet;\r\n      \r\n      return {\r\n        ...beforeDroplet,\r\n        frontVolumetricPosition: beforeDroplet.frontVolumetricPosition + \r\n          (afterDroplet.frontVolumetricPosition - beforeDroplet.frontVolumetricPosition) * fraction,\r\n        rearVolumetricPosition: beforeDroplet.rearVolumetricPosition + \r\n          (afterDroplet.rearVolumetricPosition - beforeDroplet.rearVolumetricPosition) * fraction,\r\n      };\r\n    });\r\n  };\r\n\r\n  // Add navigation functions\r\n  const jumpToTimepoint = useCallback((index) => {\r\n    if (index >= 0 && index < dropletHistory.length) {\r\n      setCurrentTimepoint(index);\r\n      setCurrentTime(dropletHistory[index].time);\r\n    }\r\n  }, [dropletHistory]);\r\n\r\n  const nextTimepoint = useCallback(() => {\r\n    jumpToTimepoint(currentTimepoint + 1);\r\n  }, [currentTimepoint, jumpToTimepoint]);\r\n\r\n  const previousTimepoint = useCallback(() => {\r\n    jumpToTimepoint(currentTimepoint - 1);\r\n  }, [currentTimepoint, jumpToTimepoint]);\r\n\r\n\r\n\r\n  const handleNodeClick = (node) => {\r\n    console.log('Node clicked:', node);\r\n    console.log('Node type:', node.type);\r\n    console.log('Node data type:', node.data?.type);\r\n    \r\n    // Check both node.type and node.data.type\r\n    const nodeType = node.type || node.data?.type;\r\n    console.log('Determined node type:', nodeType);\r\n    \r\n    if (nodeType === 'pump' || nodeType === 'USBSpectrometer' || nodeType === 'MQTTSpectrometer') {\r\n      setSelectedNode(node);\r\n      console.log('Selected node set:', node.id, nodeType);\r\n    }\r\n    if (node.type === 'detector' || node.type === 'USBSpectrometer' || node.type === 'MQTTSpectrometer') {\r\n      // Store the graph ref when opening a spectrometer\r\n      const graphRef = React.createRef();\r\n      graphRefs.current[node.id] = graphRef;\r\n      \r\n      // ... rest of the existing handleNodeClick code ...\r\n    }\r\n  };\r\n\r\n  const handleNodeAction = (action) => {\r\n    console.log('Node action:', action);\r\n    // Here you would implement the actual device communication\r\n    // based on the action type and parameters\r\n  };\r\n\r\n  const togglePumpSpeeds = () => {\r\n    setDisplayPumpSpeeds(!displayPumpSpeeds);\r\n  };\r\n\r\n  // Toggle functions for each display option\r\n  const toggleNodeIds = () => {\r\n    setDisplayNodeIds(!displayNodeIds);\r\n  };\r\n  \r\n  const toggleDropletInfo = () => {\r\n    setDisplayDropletInfo(!displayDropletInfo);\r\n  };\r\n  \r\n  const toggleDropletGaps = () => {\r\n    setDisplayDropletGaps(!displayDropletGaps);\r\n  };\r\n  \r\n  const toggleEdgeLabels = () => {\r\n    setDisplayEdgeLabels(!displayEdgeLabels);\r\n  };\r\n  \r\n  const toggleDisplayMenu = () => {\r\n    setDisplayMenuOpen(!isDisplayMenuOpen);\r\n  };\r\n  \r\n  const toggleTimelineDropletInfo = () => {\r\n    setDisplayTimelineDropletInfo(!displayTimelineDropletInfo);\r\n  };\r\n  \r\n  const toggleDetectorEvents = () => {\r\n    setDisplayDetectorEvents(!displayDetectorEvents);\r\n  };\r\n  \r\n  // Close menu when clicking outside\r\n  useEffect(() => {\r\n    const handleClickOutside = (event) => {\r\n      if (displayMenuRef.current && !displayMenuRef.current.contains(event.target)) {\r\n        setDisplayMenuOpen(false);\r\n      }\r\n    };\r\n    \r\n    document.addEventListener('mousedown', handleClickOutside);\r\n    return () => {\r\n      document.removeEventListener('mousedown', handleClickOutside);\r\n    };\r\n  }, []);\r\n\r\n  // Function to toggle pump panel visibility\r\n  const togglePumpPanel = (pumpId) => {\r\n    setVisiblePumpPanel((prev) => (prev === pumpId ? null : pumpId));\r\n  };\r\n\r\n  // Add styles for the display menu\r\n  const styles = {\r\n    container: {\r\n      ...backgroundVariants.mainBackground,\r\n      padding: '20px',\r\n      minHeight: '100vh'\r\n    },\r\n    dropletInfo: {\r\n      padding: '8px',\r\n      borderRadius: '4px',\r\n      fontSize: '12px',\r\n      ...backgroundVariants.panelBackground,\r\n      color: '#fff',\r\n      minWidth: '150px'\r\n    },\r\n    timelineContainer: {\r\n      display: 'flex',\r\n      flexDirection: 'column',\r\n      gap: '10px',\r\n      marginBottom: '20px'\r\n    },\r\n    timeInput: {\r\n      width: '100px',\r\n      ...backgroundVariants.inputBackground,\r\n      padding: '5px',\r\n      borderRadius: '4px',\r\n      marginLeft: '8px'\r\n    },\r\n    buttonGroup: {\r\n      display: 'flex',\r\n      gap: '10px',\r\n      marginTop: '20px',\r\n      marginBottom: '20px'\r\n    },\r\n    timelineControls: {\r\n      display: 'flex',\r\n      flexDirection: 'column',\r\n      gap: '15px',\r\n      marginBottom: '20px',\r\n      ...backgroundVariants.panelBackground,\r\n      padding: '15px',\r\n      borderRadius: '4px'\r\n    },\r\n    timeControls: {\r\n      display: 'flex',\r\n      flexDirection: 'column',\r\n      gap: '15px'\r\n    },\r\n    sliderContainer: {\r\n      display: 'flex',\r\n      gap: '10px',\r\n      alignItems: 'center',\r\n      borderBottom: '1px solid rgba(255,255,255,0.1)',\r\n      paddingBottom: '15px'\r\n    },\r\n    timeStepButtons: {\r\n      display: 'flex',\r\n      gap: '5px',\r\n      alignItems: 'center',\r\n      justifyContent: 'flex-start'\r\n    },\r\n    timeScaleContainer: {\r\n      display: 'flex',\r\n      alignItems: 'center',\r\n      gap: '15px',\r\n      justifyContent: 'flex-start',\r\n      borderTop: '1px solid rgba(255,255,255,0.1)',\r\n      paddingTop: '15px'\r\n    },\r\n    svgContainer: {\r\n      background: backgroundVariants.panelBackground.background,\r\n      borderRadius: '4px',\r\n      padding: '10px'\r\n    },\r\n    navigationButtons: {\r\n      display: 'flex',\r\n      justifyContent: 'space-between',\r\n      marginBottom: '20px'\r\n    },\r\n    timeSlider: {\r\n      width: '33%',\r\n      ...backgroundVariants.inputBackground,\r\n      height: '20px',\r\n      borderRadius: '10px',\r\n      WebkitAppearance: 'none',\r\n      appearance: 'none',\r\n      background: backgroundVariants.inputBackground.background,\r\n      outline: 'none',\r\n      opacity: '0.7',\r\n      transition: 'opacity .2s',\r\n      '&:hover': {\r\n        opacity: '1'\r\n      },\r\n      '&::-webkit-slider-thumb': {\r\n        WebkitAppearance: 'none',\r\n        appearance: 'none',\r\n        width: '20px',\r\n        height: '20px',\r\n        background: '#4CAF50',\r\n        cursor: 'pointer',\r\n        borderRadius: '50%'\r\n      },\r\n      '&::-moz-range-thumb': {\r\n        width: '20px',\r\n        height: '20px',\r\n        background: '#4CAF50',\r\n        cursor: 'pointer',\r\n        borderRadius: '50%'\r\n      }\r\n    },\r\n    // Add styles for display menu\r\n    displayMenuButton: {\r\n      ...buttonVariants.infoButton,\r\n      position: 'relative'\r\n    },\r\n    displayMenu: {\r\n      position: 'absolute',\r\n      top: '100%',\r\n      right: 0,\r\n      backgroundColor: '#333',\r\n      border: '1px solid #555',\r\n      borderRadius: '4px',\r\n      padding: '8px 0',\r\n      zIndex: 1000,\r\n      width: '220px',\r\n      boxShadow: '0 2px 10px rgba(0, 0, 0, 0.3)'\r\n    },\r\n    menuItem: {\r\n      padding: '8px 16px',\r\n      cursor: 'pointer',\r\n      display: 'flex',\r\n      alignItems: 'center',\r\n      justifyContent: 'space-between',\r\n      color: 'white',\r\n      transition: 'background-color 0.2s',\r\n      '&:hover': {\r\n        backgroundColor: '#444'\r\n      }\r\n    },\r\n    checkmark: {\r\n      color: '#4CAF50',\r\n      fontWeight: 'bold'\r\n    }\r\n  };\r\n\r\n  const sliderStyle = {\r\n    width: '100%',\r\n    height: '10px',\r\n    borderRadius: '5px', \r\n    background: '#333',\r\n    outline: 'none',\r\n    opacity: '0.7',\r\n    transition: 'opacity .2s'\r\n    // Remove all pseudo-element styles that were here\r\n  };\r\n\r\n  return (\r\n    <div style={styles.container}>\r\n      <div style={styles.timelineControls}>\r\n        <div style={styles.timeControls}>\r\n          <div style={styles.sliderContainer}>\r\n            <input\r\n              type=\"range\"\r\n              min={0}\r\n              max={Math.max(0, dropletHistory.length - 1)}\r\n              value={currentTimepoint}\r\n              onChange={(e) => jumpToTimepoint(Number(e.target.value))}\r\n              disabled={isSimulationRunning}\r\n              style={styles.timeSlider}\r\n              className=\"time-slider\" // Add this className\r\n            />\r\n            {displayTimelineDropletInfo && (\r\n              <div style={{ display: 'flex', gap: '10px', flexWrap: 'wrap' }}>\r\n                {dropletHistory.length > 0 && dropletHistory[currentTimepoint]?.droplets.map((droplet, index) => (\r\n                  <div key={droplet.id} style={styles.dropletInfo}>\r\n                    <div>Droplet {index + 1}:</div>\r\n                    {droplet.frontNextNodeID && (\r\n                      <div>Front → {graphData.nodes.find(n => n.id === droplet.frontNextNodeID)?.label || droplet.frontNextNodeID}</div>\r\n                    )}\r\n                    {droplet.rearNextNodeID && (\r\n                      <div>Rear → {graphData.nodes.find(n => n.id === droplet.rearNextNodeID)?.label || droplet.rearNextNodeID}</div>\r\n                    )}\r\n                  </div>\r\n                ))}\r\n              </div>\r\n            )}\r\n          </div>\r\n\r\n          <div style={styles.timeStepButtons}>\r\n            <button\r\n              onClick={() => jumpToTimepoint(0)}\r\n              disabled={currentTimepoint === 0 || isSimulationRunning}\r\n              style={{ ...buttonVariants.secondaryButton, padding: '4px 8px' }}\r\n            >\r\n              ⏮️ Start\r\n            </button>\r\n            <button\r\n              onClick={() => jumpToTimepoint(currentTimepoint - 1)}\r\n              disabled={currentTimepoint === 0 || isSimulationRunning}\r\n              style={{ ...buttonVariants.secondaryButton, padding: '4px 8px' }}\r\n            >\r\n              ⏪ Previous\r\n            </button>\r\n            <button\r\n              onClick={() => jumpToTimepoint(currentTimepoint + 1)}\r\n              disabled={currentTimepoint >= dropletHistory.length - 1 || isSimulationRunning}\r\n              style={{ ...buttonVariants.secondaryButton, padding: '4px 8px' }}\r\n            >\r\n              Next ⏩\r\n            </button>\r\n            <button\r\n              onClick={() => jumpToTimepoint(dropletHistory.length - 1)}\r\n              disabled={currentTimepoint >= dropletHistory.length - 1 || isSimulationRunning}\r\n              style={{ ...buttonVariants.secondaryButton, padding: '4px 8px' }}\r\n            >\r\n              End ⏭️\r\n            </button>\r\n          </div>\r\n\r\n          <div style={styles.timeScaleContainer}>\r\n            <label style={{ color: '#fff', marginRight: '10px' }}>\r\n              Time Scale:\r\n              <select\r\n                value={timeScale}\r\n                onChange={(e) => setTimeScale(Number(e.target.value))}\r\n                style={styles.timeInput}\r\n              >\r\n                <option value={0.0625}>1/16x</option>\r\n                <option value={0.25}>1/4x</option>\r\n                <option value={1}>1x</option>\r\n                <option value={4}>4x</option>\r\n                <option value={16}>16x</option>\r\n                <option value={64}>64x</option>\r\n                <option value={256}>256x</option>\r\n                <option value={1024}>1024x</option>\r\n              </select>\r\n            </label>\r\n            <label style={{ color: '#fff', marginRight: '10px' }}>\r\n              Current Time: {currentTime.toFixed(2)}s\r\n            </label>\r\n            <label style={{ color: '#fff' }}>\r\n              Step: {currentTimepoint + 1}/{dropletHistory.length}\r\n            </label>\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      <div style={styles.buttonGroup}>\r\n        <button \r\n          onClick={isSimulationRunning ? stopSimulation : startSimulation} \r\n          style={{ ...buttonVariants.primaryButton }}\r\n        >\r\n          {isSimulationRunning ? 'Stop Simulation' : 'Start Simulation'}\r\n        </button>\r\n        <button \r\n          onClick={restartSimulation} \r\n          style={{ ...buttonVariants.secondaryButton }}\r\n        >\r\n          Restart simulation\r\n        </button>\r\n        <button \r\n          onClick={sendingEventsToDevices} \r\n          style={{ ...buttonVariants.primaryButton }}\r\n        >\r\n          Send Events to Devices\r\n        </button>\r\n        <div ref={displayMenuRef} style={{ position: 'relative', display: 'inline-block' }}>\r\n          <button \r\n            onClick={toggleDisplayMenu} \r\n            style={styles.displayMenuButton}\r\n          >\r\n            Display Settings\r\n          </button>\r\n          {isDisplayMenuOpen && (\r\n            <div style={styles.displayMenu}>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={toggleNodeIds}\r\n              >\r\n                <span>Show Node IDs</span>\r\n                <span style={styles.checkmark}>{displayNodeIds ? '✓' : ''}</span>\r\n              </div>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={toggleDropletInfo}\r\n              >\r\n                <span>Show Droplet Info</span>\r\n                <span style={styles.checkmark}>{displayDropletInfo ? '✓' : ''}</span>\r\n              </div>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={toggleDropletGaps}\r\n              >\r\n                <span>Show Droplet Gaps</span>\r\n                <span style={styles.checkmark}>{displayDropletGaps ? '✓' : ''}</span>\r\n              </div>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={toggleEdgeLabels}\r\n              >\r\n                <span>Show Tube Dimensions</span>\r\n                <span style={styles.checkmark}>{displayEdgeLabels ? '✓' : ''}</span>\r\n              </div>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={togglePumpSpeeds}\r\n              >\r\n                <span>Show Pump Speeds</span>\r\n                <span style={styles.checkmark}>{displayPumpSpeeds ? '✓' : ''}</span>\r\n              </div>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={toggleTimelineDropletInfo}\r\n              >\r\n                <span>Show Timeline Droplet Info</span>\r\n                <span style={styles.checkmark}>{displayTimelineDropletInfo ? '✓' : ''}</span>\r\n              </div>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={toggleDetectorEvents}\r\n              >\r\n                <span>Show Detector Events</span>\r\n                <span style={styles.checkmark}>{displayDetectorEvents ? '✓' : ''}</span>\r\n              </div>\r\n            </div>\r\n          )}\r\n        </div>\r\n      </div>\r\n\r\n      {/* Rest of the SVG rendering code */}\r\n      {graphData.nodes.length > 0 && (\r\n        <div style={styles.svgContainer}>\r\n          <svg width=\"2000\" height=\"400\">\r\n            {/* Render edges first (background) */}\r\n            {graphData.links.map((link, index) => {\r\n              const sourceNode = graphData.nodes.find(node => node.id === link.source);\r\n              const targetNode = graphData.nodes.find(node => node.id === link.target);\r\n              if (!sourceNode || !targetNode) return null;\r\n              \r\n              const midX = (sourceNode.x + targetNode.x) / 2;\r\n              const midY = (sourceNode.y + targetNode.y) / 2;\r\n              \r\n              return (\r\n                <g key={`edge-${index}`}>\r\n                  <line\r\n                    x1={sourceNode.x}\r\n                    y1={sourceNode.y}\r\n                    x2={targetNode.x}\r\n                    y2={targetNode.y}\r\n                    stroke=\"#999\"\r\n                    strokeWidth={2}\r\n                  />\r\n                  <text\r\n                    x={midX}\r\n                    y={midY - 20}\r\n                    textAnchor=\"middle\"\r\n                    fill=\"#fff\"\r\n                    fontSize=\"12px\"\r\n                    style={{ display: displayEdgeLabels ? 'block' : 'none' }}\r\n                  >\r\n                    {`${link.length} mm (Ø ${link.diameter} mm)`}\r\n                  </text>\r\n                </g>\r\n              );\r\n            })}\r\n\r\n            {/* Render nodes (on top) */}\r\n            {graphData.nodes.map((node, index) => (\r\n              <g key={`node-${index}`}>\r\n                <circle\r\n                  cx={node.x}\r\n                  cy={node.y}\r\n                  r={15}\r\n                  fill={getNodeColor(node)}\r\n                  stroke={selectedNode && selectedNode.id === node.id ? '#FFA500' : 'none'}\r\n                  strokeWidth={selectedNode && selectedNode.id === node.id ? '3' : '0'}\r\n                  onClick={() => handleNodeClick(node)}\r\n                  style={{ cursor: 'pointer' }}\r\n                />\r\n                <text\r\n                  x={node.x}\r\n                  y={node.y - 25}\r\n                  textAnchor=\"middle\"\r\n                  fill=\"#fff\"\r\n                  fontSize=\"12px\"\r\n                >\r\n                  {node.label}\r\n                </text>\r\n                <text\r\n                  x={node.x}\r\n                  y={node.y - 10}\r\n                  textAnchor=\"middle\"\r\n                  fill=\"#fff\"\r\n                  fontSize=\"10px\"\r\n                  style={{ display: displayNodeIds ? 'block' : 'none' }}\r\n                >\r\n                  {`ID: ${node.id}`}\r\n                </text>\r\n              </g>\r\n            ))}\r\n\r\n            {/* Render droplets and distances between them */}\r\n            {interpolateDropletState(currentTime).map((droplet, index, droplets) => {\r\n              const frontX = volumetricToXPosition(droplet.frontVolumetricPosition);\r\n              const rearX = volumetricToXPosition(droplet.rearVolumetricPosition);\r\n              const centerX = (frontX + rearX) / 2;\r\n              \r\n              // Calculate distance to next droplet if this isn't the last droplet\r\n              const distanceInfo = index < droplets.length - 1 ? {\r\n                nextDropletFront: droplets[index + 1].frontVolumetricPosition,\r\n                distance: Math.abs(droplets[index + 1].frontVolumetricPosition - droplet.rearVolumetricPosition)\r\n              } : null;\r\n              \r\n              // Calculate midpoint for distance label\r\n              const distanceLabelX = distanceInfo ? \r\n                (volumetricToXPosition(droplet.rearVolumetricPosition) + \r\n                 volumetricToXPosition(distanceInfo.nextDropletFront)) / 2 : null;\r\n\r\n              return (\r\n                <g key={`droplet-${droplet.id}`}>\r\n                  {/* Droplet body */}\r\n                  <line\r\n                    x1={rearX}\r\n                    y1={300}\r\n                    x2={frontX}\r\n                    y2={300}\r\n                    stroke=\"rgba(255, 100, 100, 0.9)\"\r\n                    strokeWidth={8}\r\n                    strokeLinecap=\"butt\"\r\n                  />\r\n                  \r\n                  {/* Distance to next droplet */}\r\n                  {distanceInfo && displayDropletGaps && (\r\n                    <g>\r\n                      {/* Distance line */}\r\n                      <line\r\n                        x1={rearX}\r\n                        y1={320}\r\n                        x2={volumetricToXPosition(distanceInfo.nextDropletFront)}\r\n                        y2={320}\r\n                        stroke=\"#fff\"\r\n                        strokeWidth={1}\r\n                        strokeDasharray=\"5,5\"\r\n                      />\r\n                      {/* Distance arrows */}\r\n                      <line\r\n                        x1={rearX}\r\n                        y1={315}\r\n                        x2={rearX}\r\n                        y2={325}\r\n                        stroke=\"#fff\"\r\n                        strokeWidth={1}\r\n                      />\r\n                      <line\r\n                        x1={volumetricToXPosition(distanceInfo.nextDropletFront)}\r\n                        y1={315}\r\n                        x2={volumetricToXPosition(distanceInfo.nextDropletFront)}\r\n                        y2={325}\r\n                        stroke=\"#666\"\r\n                        strokeWidth={1}\r\n                      />\r\n                      {/* Distance label */}\r\n                      <text\r\n                        x={distanceLabelX}\r\n                        y={335}\r\n                        textAnchor=\"middle\"\r\n                        fill=\"#666\"\r\n                        fontSize=\"12px\"\r\n                      >\r\n                        {`${distanceInfo.distance.toFixed(2)} μL`}\r\n                      </text>\r\n                    </g>\r\n                  )}\r\n                  \r\n                  {/* Droplet info - wrap all info texts in conditional rendering */}\r\n                  {displayDropletInfo && (\r\n                    <>\r\n                      <text\r\n                        x={centerX}\r\n                        y={270}\r\n                        textAnchor=\"middle\"\r\n                        fill=\"#6f6\"\r\n                        fontSize=\"12px\"\r\n                      >\r\n                        {`Vol: ${(droplet.frontVolumetricPosition-droplet.rearVolumetricPosition).toFixed(2)} μL`}\r\n                      </text>\r\n                      <text\r\n                        x={centerX}\r\n                        y={255}\r\n                        textAnchor=\"middle\"\r\n                        fill=\"#6f6\"\r\n                        fontSize=\"12px\"\r\n                      >\r\n                        {`Spd f: ${droplet.frontVolumetricSpeed.toFixed(2)} μL/s`}\r\n                      </text>\r\n                      <text\r\n                        x={centerX}\r\n                        y={240}\r\n                        textAnchor=\"middle\"\r\n                        fill=\"#6f6\"\r\n                        fontSize=\"12px\"\r\n                      >\r\n                        {`Spd r: ${droplet.rearVolumetricSpeed.toFixed(2)} μL/s`}\r\n                      </text>\r\n                      <text\r\n                        x={centerX}\r\n                        y={225}\r\n                        textAnchor=\"middle\"\r\n                        fill=\"#6f6\"\r\n                        fontSize=\"12px\"\r\n                      >\r\n                        {`mlt: ${droplet.pumpSpeedMultiplier.toFixed(2)}`}\r\n                      </text>\r\n                    </>\r\n                  )}\r\n                </g>\r\n              );\r\n            })}\r\n\r\n            {displayPumpSpeeds && graphData.nodes.map((node, index) => {\r\n              if (node.type === 'pump') {\r\n                const currentSpeed = getPumpSpeedAtTime(node.id, pumpEvents, currentTime);\r\n                const maxTime = dropletHistory[dropletHistory.length - 1]?.time || 1;\r\n                const pumpSpecificEvents = pumpEvents.filter(event => event.target === node.id);\r\n                \r\n                return (\r\n                  <g key={`pump-speed-${node.id}`}>\r\n                    {/* Current pump speed value */}\r\n                    <text\r\n                      x={node.x}\r\n                      y={node.y - 35}\r\n                      textAnchor=\"middle\"\r\n                      fill=\"#4CAF50\"\r\n                      fontSize=\"12px\"\r\n                    >\r\n                      {`${currentSpeed.toFixed(2)} μL/s`}\r\n                    </text>\r\n                    \r\n                    {/* Speed history visualization */}\r\n                    <g transform={`translate(${node.x - 40}, ${node.y - 65})`}>\r\n                      {pumpSpecificEvents.map((event, i, arr) => {\r\n                        const nextEvent = arr[i + 1];\r\n                        const width = 80;\r\n                        const x = 0;\r\n                        const y = 0;\r\n                        \r\n                        // Calculate position based on time\r\n                        const timePosition = (event.time / maxTime) * width;\r\n                        const nextTimePosition = nextEvent \r\n                          ? (nextEvent.time / maxTime) * width\r\n                          : width;\r\n                        \r\n                        // Calculate height based on speed value (normalized)\r\n                        const maxSpeed = Math.max(...pumpSpecificEvents.map(e => e.value));\r\n                        const normalizedHeight = event.value / (maxSpeed || 1) * 20;\r\n                        \r\n                        return (\r\n                          <g key={`pump-event-${i}`}>\r\n                            {/* Speed segment */}\r\n                            <line\r\n                              x1={x + timePosition}\r\n                              y1={y - normalizedHeight}\r\n                              x2={x + nextTimePosition}\r\n                              y2={y - normalizedHeight}\r\n                              stroke=\"#4CAF50\"\r\n                              strokeWidth={2}\r\n                            />\r\n                            {/* Event point */}\r\n                            <circle\r\n                              cx={x + timePosition}\r\n                              cy={y - normalizedHeight}\r\n                              r={2}\r\n                              fill=\"#4CAF50\"\r\n                            />\r\n                            {/* Time marker */}\r\n                            <text\r\n                              x={x + timePosition}\r\n                              y={y + 12}\r\n                              textAnchor=\"middle\"\r\n                              fill=\"#666\"\r\n                              fontSize=\"10px\"\r\n                            >\r\n                              {event.time.toFixed(1)}s\r\n                            </text>\r\n                            {/* Speed value */}\r\n                            <text\r\n                              x={x + timePosition}\r\n                              y={y - normalizedHeight - 5}\r\n                              textAnchor=\"middle\"\r\n                              fill=\"#4CAF50\"\r\n                              fontSize=\"8px\"\r\n                            >\r\n                              {event.value.toFixed(1)}\r\n                            </text>\r\n                          </g>\r\n                        );\r\n                      })}\r\n                      {/* Current time indicator */}\r\n                      <line\r\n                        x1={(currentTime / maxTime) * 80}\r\n                        y1={-25}\r\n                        x2={(currentTime / maxTime) * 80}\r\n                        y2={15}\r\n                        stroke=\"red\"\r\n                        strokeWidth={1}\r\n                        strokeDasharray=\"2,2\"\r\n                      />\r\n                    </g>\r\n                  </g>\r\n                );\r\n              }\r\n              return null;\r\n            })}\r\n\r\n            {/* Render detector events */}\r\n            {displayDetectorEvents && graphData.nodes.map((node, index) => {\r\n              if (node.type === 'detector' || node.type === 'USBSpectrometer' || node.type === 'MQTTSpectrometer') {\r\n                const currentEvents = getDetectorEventsAtTime(node.id, detectorEvents, currentTime);\r\n                const detectorSpecificEvents = detectorEvents.filter(event => event.target === node.id);\r\n                const maxTime = dropletHistory[dropletHistory.length - 1]?.time || 1;\r\n                \r\n                return (\r\n                  <g key={`detector-events-${node.id}`}>\r\n                    {/* Current detector events indicator */}\r\n                    {currentEvents.length > 0 && (\r\n                      <circle\r\n                        cx={node.x}\r\n                        cy={node.y}\r\n                        r={20}\r\n                        fill=\"none\"\r\n                        stroke=\"#FF6B35\"\r\n                        strokeWidth={3}\r\n                        opacity={0.8}\r\n                      />\r\n                    )}\r\n                    \r\n                    {/* Event count display */}\r\n                    <text\r\n                      x={node.x}\r\n                      y={node.y - 35}\r\n                      textAnchor=\"middle\"\r\n                      fill=\"#FF6B35\"\r\n                      fontSize=\"12px\"\r\n                    >\r\n                      {`Events: ${detectorSpecificEvents.length}`}\r\n                    </text>\r\n                    \r\n                    {/* Event timeline visualization */}\r\n                    <g transform={`translate(${node.x - 40}, ${node.y - 65})`}>\r\n                      {detectorSpecificEvents.map((event, i) => {\r\n                        const width = 80;\r\n                        const x = 0;\r\n                        const y = 0;\r\n                        \r\n                        // Calculate position based on time\r\n                        const timePosition = (event.time / maxTime) * width;\r\n                        \r\n                        return (\r\n                          <g key={`detector-event-${i}`}>\r\n                            {/* Event marker */}\r\n                            <circle\r\n                              cx={x + timePosition}\r\n                              cy={y}\r\n                              r={3}\r\n                              fill={event.eventSubtype === 'dropletFrontReached' ? '#FF6B35' : '#FFA500'}\r\n                            />\r\n                            {/* Event line */}\r\n                            <line\r\n                              x1={x + timePosition}\r\n                              y1={y - 5}\r\n                              x2={x + timePosition}\r\n                              y2={y + 5}\r\n                              stroke=\"#FF6B35\"\r\n                              strokeWidth={1}\r\n                            />\r\n                            {/* Time label */}\r\n                            <text\r\n                              x={x + timePosition}\r\n                              y={y + 15}\r\n                              textAnchor=\"middle\"\r\n                              fill=\"#FF6B35\"\r\n                              fontSize=\"8px\"\r\n                            >\r\n                              {event.time.toFixed(1)}s\r\n                            </text>\r\n                            {/* Droplet ID */}\r\n                            <text\r\n                              x={x + timePosition}\r\n                              y={y - 10}\r\n                              textAnchor=\"middle\"\r\n                              fill=\"#FF6B35\"\r\n                              fontSize=\"8px\"\r\n                            >\r\n                              D{event.dropletId}\r\n                            </text>\r\n                          </g>\r\n                        );\r\n                      })}\r\n                      {/* Current time indicator */}\r\n                      <line\r\n                        x1={(currentTime / maxTime) * 80}\r\n                        y1={-25}\r\n                        x2={(currentTime / maxTime) * 80}\r\n                        y2={25}\r\n                        stroke=\"red\"\r\n                        strokeWidth={1}\r\n                        strokeDasharray=\"2,2\"\r\n                      />\r\n                    </g>\r\n                  </g>\r\n                );\r\n              }\r\n              return null;\r\n            })}\r\n          </svg>\r\n        </div>\r\n      )}\r\n      \r\n      {selectedNode && (selectedNode.type === 'pump' || selectedNode.data?.type === 'pump') && (\r\n        <DraggablePanel \r\n          initialPosition={pumpPanelPosition}\r\n          title={`Pump Controls - ${selectedNode.label || selectedNode.id}`}\r\n        >\r\n          <PumpActions\r\n            node={selectedNode}\r\n            nodes={nodes}\r\n            edges={edges}\r\n            onAction={handleNodeAction}\r\n          />\r\n        </DraggablePanel>\r\n      )}\r\n      {selectedNode && (selectedNode.type === 'USBSpectrometer' || selectedNode.data?.type === 'USBSpectrometer') && (\r\n        <>\r\n          {console.log('Rendering USBSpectrometer component for node:', selectedNode)}\r\n          <USBSpectrometer\r\n            detector={selectedNode}\r\n            detectorId={selectedNode.id}\r\n            detectorName={selectedNode.label || selectedNode.id}\r\n            onClose={() => setSelectedNode(null)}\r\n            initialPosition={{ x: 150, y: 100 }}\r\n            isVisible={true}\r\n          />\r\n        </>\r\n      )}\r\n      {selectedNode && (selectedNode.type === 'MQTTSpectrometer' || selectedNode.data?.type === 'MQTTSpectrometer') && (\r\n        <>\r\n          {console.log('Rendering SpectrometerMQTT component for node:', selectedNode)}\r\n          <SpectrometerMQTT\r\n            detector={selectedNode}\r\n            detectorId={selectedNode.id}\r\n            detectorName={selectedNode.label || selectedNode.id}\r\n            onClose={() => setSelectedNode(null)}\r\n            initialPosition={{ x: 150, y: 100 }}\r\n            isVisible={true}\r\n          />\r\n        </>\r\n      )}\r\n      {/* Add styles for PumpActions */}\r\n      <style>\r\n        {`\r\n          .node-actions {\r\n            position: fixed;\r\n            top: 20px;\r\n            right: 20px;\r\n            background: black;\r\n            padding: 20px;\r\n            border: 1px solid #ccc;\r\n            border-radius: 5px;\r\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\r\n          }\r\n          .node-actions h3 {\r\n            margin: 0 0 15px 0;\r\n            color: #333;\r\n          }\r\n          .node-actions button {\r\n            margin: 5px;\r\n            padding: 8px 16px;\r\n            background: #4CAF50;\r\n            color: white;\r\n            border: none;\r\n            border-radius: 4px;\r\n            cursor: pointer;\r\n          }\r\n          .node-actions button:disabled {\r\n            background: #ccc;\r\n            cursor: not-allowed;\r\n          }\r\n          .node-actions input {\r\n            margin: 5px;\r\n            padding: 8px;\r\n            border: 1px solid #ccc;\r\n            border-radius: 4px;\r\n            width: 80px;\r\n          }\r\n          .move-controls {\r\n            display: flex;\r\n            flex-direction: column;\r\n            gap: 10px;\r\n            margin-top: 10px;\r\n          }\r\n          .input-group {\r\n            display: flex;\r\n            align-items: center;\r\n            gap: 10px;\r\n          }\r\n          .input-group label {\r\n            min-width: 100px;\r\n            text-align: right;\r\n            color: #666;\r\n          }\r\n        `}\r\n      </style>\r\n      {overlayComponent && (\r\n        <div style={{\r\n          position: 'fixed',\r\n          top: 0,\r\n          left: 0,\r\n          right: 0,\r\n          bottom: 0,\r\n          zIndex: 9999,\r\n          pointerEvents: 'none'\r\n        }}>\r\n          <Suspense fallback={\r\n            <div style={{\r\n              position: 'fixed',\r\n              top: '50%',\r\n              left: '50%',\r\n              transform: 'translate(-50%, -50%)',\r\n              background: 'rgba(0,0,0,0.8)',\r\n              padding: '20px',\r\n              borderRadius: '8px',\r\n              color: 'white',\r\n              pointerEvents: 'auto'\r\n            }}>\r\n              <h2>Loading Component...</h2>\r\n            </div>\r\n          }>\r\n            {overlayComponent.type === 'USBSpectrometer' && (\r\n              <div style={{ pointerEvents: 'auto' }}>\r\n                <USBSpectrometer {...overlayComponent.props} />\r\n              </div>\r\n            )}\r\n            {overlayComponent.type === 'MQTTSpectrometer' && (\r\n              <div style={{ pointerEvents: 'auto' }}>\r\n                <SpectrometerMQTT \r\n                  {...overlayComponent.props} \r\n                  graphRef={graphRefs.current[overlayComponent.props.detector.id]}\r\n                />\r\n              </div>\r\n            )}\r\n            {overlayComponent.type === 'PumpPanel' && (\r\n              <div style={{ pointerEvents: 'auto' }}>\r\n                <PumpPanel {...overlayComponent.props} />\r\n              </div>\r\n            )}\r\n          </Suspense>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Simulation;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}