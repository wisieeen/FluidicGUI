{"ast":null,"code":"var _jsxFileName = \"E:\\\\flow chemistry\\\\fluidicGUI\\\\frontend\\\\fluidicgui\\\\src\\\\components\\\\Simulation\\\\Simulation.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useCallback, useRef, Suspense } from 'react';\nimport { ReactFlowProvider, useNodesState, useEdgesState } from 'react-flow-renderer';\nimport PumpActions from './NodeActions/PumpActions';\nimport DraggablePanel from './DraggablePanel';\nimport { convertToHardwareValuesPump } from '../../utils/pumpCalculations';\nimport { useButtonStyles } from '../../styles/ButtonStyleProvider';\nimport { backgroundVariants } from '../../styles/backgroundStyles';\nimport { findOutletNode, findFurthestNode, orderNodesByDistance, calculateEdgeVolume, getVolumeBetweenNodes, findConnectedPump, getPumpSpeed, getPumpsBetweenPositions, cleanAndSortEventList, getPumpSpeedAtTime, sendEventsToDevices, setOfMainLineNodes, setOfSecondaryLineNodes } from '../../utils/simulationUtils';\nimport './simulation.css'; // We'll create this CSS file\nimport SvgDefs from './SvgDefs';\nimport { calculateEdgePoints, createLabels } from '../../utils/flowchartUtils';\nimport USBSpectrometer from './USBSpectrometer';\nimport SpectrometerMQTT from './SpectrometerMQTT';\nimport PumpPanel from './PumpPanel';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst Simulation = ({\n  nodes = [],\n  edges = [],\n  droplets = [],\n  selectedCarrierPumps = [],\n  onBack,\n  onNext\n}) => {\n  _s();\n  var _dropletHistory$curre, _selectedNode$data, _selectedNode$data2, _selectedNode$data3;\n  const buttonVariants = useButtonStyles();\n  const [graphData, setGraphData] = useState({\n    nodes: [],\n    links: []\n  });\n  const [simulationDroplets, setSimulationDroplets] = useState([]);\n  const [isSimulationRunning, setIsSimulationRunning] = useState(false);\n  const [key, setKey] = useState(0);\n  const [currentTime, setCurrentTime] = useState(0);\n  const [timeScale, setTimeScale] = useState(1); // Default 1x speed\n  const animationFrameRef = useRef();\n  const lastFrameTimeRef = useRef();\n  const [currentBlockDroplets, setCurrentBlockDroplets] = useState([]);\n  const [dropletHistory, setDropletHistory] = useState([]);\n  const [currentTimepoint, setCurrentTimepoint] = useState(0);\n  const [pumpEvents, setPumpEvents] = useState([]);\n  const [displayPumpSpeeds, setDisplayPumpSpeeds] = useState(false);\n  const [displayNodeIds, setDisplayNodeIds] = useState(false);\n  const [displayDropletInfo, setDisplayDropletInfo] = useState(false);\n  const [displayDropletGaps, setDisplayDropletGaps] = useState(true);\n  const [displayEdgeLabels, setDisplayEdgeLabels] = useState(false);\n  const [isDisplayMenuOpen, setDisplayMenuOpen] = useState(false);\n  const [displayTimelineDropletInfo, setDisplayTimelineDropletInfo] = useState(false);\n  const displayMenuRef = useRef(null);\n  const [selectedNode, setSelectedNode] = useState(null);\n  const [ws, setWs] = useState(null);\n  const [pumpPanelPosition, setPumpPanelPosition] = useState({\n    x: window.innerWidth - 300,\n    y: 100\n  });\n  const [visiblePumpPanel, setVisiblePumpPanel] = useState(null);\n  const [isSendingEvents, setIsSendingEvents] = useState(false);\n  const graphRefs = useRef({});\n  const [overlayComponent, setOverlayComponent] = useState(null);\n\n  // Add at the beginning of the component, after the state initialization\n  useEffect(() => {\n    // Log all nodes and their types for debugging\n    console.log('All nodes:', nodes);\n    if (nodes && nodes.length > 0) {\n      console.log('Node types in simulation:', nodes.map(node => {\n        var _node$data;\n        return {\n          id: node.id,\n          type: node.type,\n          dataType: (_node$data = node.data) === null || _node$data === void 0 ? void 0 : _node$data.type\n        };\n      }));\n    }\n  }, [nodes]);\n  useEffect(() => {\n    // Create WebSocket connection\n    const websocket = new WebSocket('ws://localhost:4000');\n    websocket.onopen = () => {\n      console.log('Connected to WebSocket server');\n    };\n    websocket.onerror = error => {\n      console.error('WebSocket error:', error);\n    };\n    setWs(websocket);\n\n    // Cleanup on unmount\n    return () => {\n      if (websocket) {\n        websocket.close();\n      }\n    };\n  }, []);\n  const sendingEventsToDevices = () => {\n    setIsSendingEvents(true);\n    sendEventsToDevices(pumpEvents, ws, nodes);\n    // Reset simulation state\n    setCurrentTime(0);\n    setCurrentTimepoint(0);\n    setIsSimulationRunning(true);\n    setDropletHistory([]);\n    // Generate new event list\n    generateEventList([{\n      droplets: droplets\n    }]);\n  };\n\n  // Add effect to handle automatic memory addition when events are being sent\n  useEffect(() => {\n    if (isSendingEvents) {\n      // Get all graph refs and add data to memory\n      Object.values(graphRefs.current).forEach(graphRef => {\n        if (graphRef && graphRef.current && graphRef.current.addToMemory) {\n          graphRef.current.addToMemory();\n        }\n      });\n    }\n  }, [isSendingEvents]);\n  const eventType = ['setPumpSpeed', 'setThermostatTemperature', 'setLedIntensity', 'wait', 'blockEnd'];\n  const calculateVolumesBetweenThermostats = graphData => {\n    // Find outlet node first\n    const outletNode = findOutletNode(graphData.nodes);\n    const visited = new Set();\n    const queue = [[outletNode.id, 0, []]]; // [nodeId, accumulated volume, path of thermostats]\n    const thermostatVolumes = [];\n    while (queue.length > 0) {\n      let [currentNodeId, accumulatedVolume, thermostatPath] = queue.shift();\n      const currentNode = graphData.nodes.find(n => n.id === currentNodeId);\n      if (!currentNode) continue;\n\n      // Track all visited nodes to prevent infinite loops\n      if (visited.has(currentNodeId)) continue;\n      visited.add(currentNodeId);\n\n      // If we found a thermostat, add it to the path\n      let updatedPath = [...thermostatPath];\n      if (currentNode.type === 'thermostat') {\n        if (thermostatPath.length > 0) {\n          thermostatVolumes.push({\n            startThermostatId: thermostatPath[thermostatPath.length - 1],\n            endThermostatId: currentNodeId,\n            volume: accumulatedVolume\n          });\n        }\n        updatedPath.push(currentNodeId);\n        // Reset accumulated volume after finding a thermostat\n        accumulatedVolume = 0;\n      }\n\n      // Find all connected edges and nodes\n      const connectedEdges = graphData.links.filter(link => link.source === currentNodeId || link.target === currentNodeId);\n      for (const edge of connectedEdges) {\n        const nextNodeId = edge.source === currentNodeId ? edge.target : edge.source;\n        const nextNode = graphData.nodes.find(n => n.id === nextNodeId);\n\n        // Skip paths to pumps\n        if (nextNode && nextNode.type !== 'pump') {\n          const edgeVolume = calculateEdgeVolume(edge);\n          queue.push([nextNodeId, accumulatedVolume + edgeVolume, updatedPath]);\n        }\n      }\n    }\n    return thermostatVolumes;\n  };\n  //add something to handle lack of thermostat\n  const divideDropletsIntoBlocks = (droplets, thermostatVolumes) => {\n    if (thermostatVolumes.length === 0) {\n      return [{\n        droplets: droplets,\n        thermostatId: null,\n        totalVolume: droplets.reduce((acc, droplet) => acc + droplet.actualVolume, 0),\n        temperature: null,\n        time: null\n      }];\n    }\n    const furthestNode = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links);\n    const volumeToFurthestNode = getVolumeBetweenNodes(thermostatVolumes[0].endThermostatId, furthestNode.id, graphData.nodes, graphData.links);\n    if (!droplets.length || !thermostatVolumes.length) return [];\n    const blocks = [];\n    let currentBlock = {\n      droplets: [],\n      thermostatId: thermostatVolumes[0].endThermostatId,\n      totalVolume: 0,\n      temperature: null,\n      time: null\n    };\n\n    // Helper to finalize a block and start a new one\n    const finalizeBlock = (thermostatId, temperature, time) => {\n      if (currentBlock.droplets.length > 0) {\n        // Add volumeToFurthestNode to the surfixVolume of the last droplet in the block\n        const lastDroplet = currentBlock.droplets[currentBlock.droplets.length - 1];\n        const surfixParam = lastDroplet.parameters.find(p => p.name === 'surfixVolume');\n        if (surfixParam) {\n          surfixParam.value = Math.max(volumeToFurthestNode, surfixParam.value);\n        } else {\n          lastDroplet.parameters.push({\n            name: 'surfixVolume',\n            value: volumeToFurthestNode\n          });\n        }\n        blocks.push({\n          ...currentBlock\n        });\n      }\n      currentBlock = {\n        droplets: [],\n        thermostatId: thermostatId,\n        totalVolume: 0,\n        temperature: temperature,\n        time: time\n      };\n    };\n\n    // Process droplets in order\n    for (let i = 0; i < droplets.length; i++) {\n      var _droplet$parameters$f, _droplet$parameters$f2, _droplet$parameters$f3, _droplet$parameters$f4, _droplet$parameters$f5;\n      const droplet = droplets[i];\n      const temperature = (_droplet$parameters$f = droplet.parameters.find(p => p.name === 'temperature')) === null || _droplet$parameters$f === void 0 ? void 0 : _droplet$parameters$f.value;\n      const time = (_droplet$parameters$f2 = droplet.parameters.find(p => p.name === 'time')) === null || _droplet$parameters$f2 === void 0 ? void 0 : _droplet$parameters$f2.value;\n\n      // Start new block if temperature or time changes, or if volume limit exceeded\n      const relevantVolume = thermostatVolumes.find(tv => tv.startThermostatId === currentBlock.thermostatId || tv.endThermostatId === currentBlock.thermostatId);\n      let dropletVolume = (_droplet$parameters$f3 = droplet.parameters.find(p => p.name === 'volume')) === null || _droplet$parameters$f3 === void 0 ? void 0 : _droplet$parameters$f3.value;\n      dropletVolume += (_droplet$parameters$f4 = droplet.parameters.find(p => p.name === 'prefixVolume')) === null || _droplet$parameters$f4 === void 0 ? void 0 : _droplet$parameters$f4.value;\n      if (currentBlock.temperature !== temperature || currentBlock.time !== time || relevantVolume && currentBlock.totalVolume + dropletVolume > relevantVolume.volume) {\n        finalizeBlock(thermostatVolumes[0].endThermostatId, temperature, time);\n      }\n      dropletVolume += (_droplet$parameters$f5 = droplet.parameters.find(p => p.name === 'surfixVolume')) === null || _droplet$parameters$f5 === void 0 ? void 0 : _droplet$parameters$f5.value;\n      // Add droplet to current block\n      currentBlock.droplets.push(droplet);\n      currentBlock.totalVolume += dropletVolume;\n      currentBlock.temperature = temperature;\n      currentBlock.time = time;\n    }\n\n    // Finalize last block\n    finalizeBlock(null, null, null);\n    return blocks;\n  };\n  function printDropletFrontPositionsAndSpeeds(droplets) {\n    droplets.forEach(droplet => {\n      console.log(`Droplet ID: ${droplet.id}, Front Volumetric Position: ${droplet.frontVolumetricPosition}, Front time to next node  : ${droplet.frontTimeToReachNextNode}, Front Volumetric Distance to next node: ${droplet.frontVolumetricDistanceToNextNode}, Rear Volumetric Position: ${droplet.rearVolumetricPosition}, Rear time to next node: ${droplet.rearTimeToReachNextNode}, Rear Volumetric Distance to next node: ${droplet.rearVolumetricDistanceToNextNode}, frontNextNodeID: ${droplet.frontNextNodeID}, rearNextNodeID: ${droplet.rearNextNodeID}`);\n    });\n  }\n  const extractPumpEvents = eventList => {\n    // eventList is now an array of arrays, where each inner array contains events for a specific pump\n    return eventList.flat() // Flatten the array of arrays\n    .filter(event => event.type === 'setPumpSpeed').sort((a, b) => a.time - b.time);\n  };\n  const recalculateEventListForDevices = eventList => {\n    const deviceEventMap = new Map();\n    const convertPumpEvent = (event, deviceProperties) => {\n      var _deviceProperties$fin, _deviceProperties$fin2, _deviceProperties$fin3, _deviceProperties$fin4;\n      // Find properties by name from the properties array\n      const syringeDiameter = ((_deviceProperties$fin = deviceProperties.find(p => p.name === 'diameter')) === null || _deviceProperties$fin === void 0 ? void 0 : _deviceProperties$fin.default) || 0;\n      const syringeLength = ((_deviceProperties$fin2 = deviceProperties.find(p => p.name === 'length')) === null || _deviceProperties$fin2 === void 0 ? void 0 : _deviceProperties$fin2.default) || 0;\n      const stepsPerRevolution = ((_deviceProperties$fin3 = deviceProperties.find(p => p.name === 'steps per revolution')) === null || _deviceProperties$fin3 === void 0 ? void 0 : _deviceProperties$fin3.default) || 0;\n      const lead = ((_deviceProperties$fin4 = deviceProperties.find(p => p.name === 'lead')) === null || _deviceProperties$fin4 === void 0 ? void 0 : _deviceProperties$fin4.default) || 0;\n      const syringeArea = Math.PI * Math.pow(syringeDiameter / 2, 2);\n      const linearSpeed = Math.abs(event.value) / syringeArea;\n      const stepsPerMm = stepsPerRevolution / lead;\n      const stepsPerSecond = linearSpeed * stepsPerMm;\n      const delayMicroseconds = stepsPerSecond > 0 ? Math.round(1000000 / stepsPerSecond) : 0;\n      return {\n        target: event.target,\n        time: Math.round(event.time * 1000000),\n        delay: delayMicroseconds\n      };\n    };\n    const convertThermostatEvent = (event, deviceProperties) => {\n      // Placeholder for thermostat conversion logic\n      return {\n        target: event.target,\n        time: Math.round(event.time * 1000000),\n        temperature: event.value\n        // Add other thermostat-specific parameters here\n      };\n    };\n    const convertLedEvent = (event, deviceProperties) => {\n      // Placeholder for LED conversion logic\n      return {\n        target: event.target,\n        time: Math.round(event.time * 1000000),\n        intensity: event.value\n        // Add other LED-specific parameters here\n      };\n    };\n    const convertDetectorEvent = (event, deviceProperties) => {\n      // Placeholder for detector conversion logic\n      return {\n        target: event.target,\n        time: Math.round(event.time * 1000000),\n        setting: event.value\n        // Add other detector-specific parameters here\n      };\n    };\n    eventList.forEach(deviceEventList => {\n      if (!deviceEventList.length) return;\n      const targetId = deviceEventList[0].target;\n      const deviceNode = nodes.find(node => node.id === targetId);\n      if (!deviceNode || !deviceNode.data) {\n        console.error(`Device node or data not found for ID: ${targetId}`);\n        return;\n      }\n      const deviceEvents = deviceEventList.map(event => {\n        switch (event.type) {\n          case 'setPumpSpeed':\n            return convertPumpEvent(event, deviceNode.data.properties);\n          case 'setThermostatTemperature':\n            return convertThermostatEvent(event, deviceNode.data.properties);\n          case 'setLedIntensity':\n            return convertLedEvent(event, deviceNode.data.properties);\n          case 'setDetectorSetting':\n            return convertDetectorEvent(event, deviceNode.data.properties);\n          default:\n            console.warn(`Unknown event type: ${event.type}`);\n            return null;\n        }\n      }).filter(Boolean); // Remove any null events\n\n      if (deviceEvents.length > 0) {\n        deviceEventMap.set(targetId, deviceEvents);\n      }\n    });\n    console.log('deviceEventMap: ', Array.from(deviceEventMap.values()));\n    return Array.from(deviceEventMap.values());\n  };\n  const generateEventList = blocks => {\n    // Early exit if blocks array is invalid\n    if (!blocks || !Array.isArray(blocks) || blocks.length === 0) {\n      console.warn('No valid blocks found for event generation');\n      return [];\n    }\n    const orderedNodes = orderNodesByDistance(findOutletNode(graphData.nodes), graphData.nodes, graphData.links);\n    console.log('orderedNodes: ', orderedNodes);\n\n    // Early exit if no ordered nodes\n    if (!orderedNodes || orderedNodes.length === 0) {\n      console.warn('No ordered nodes found for event generation');\n      return [];\n    }\n    let eventList = [];\n    let dropletSnapshot = [];\n\n    // Validate block droplets\n    if (!blocks[0] || !blocks[0].droplets || !Array.isArray(blocks[0].droplets) || blocks[0].droplets.length === 0) {\n      console.warn('No valid droplets found in blocks for event generation');\n      return [];\n    }\n    const i = 0;\n    const currentBlockDroplets = blocks[i].droplets;\n\n    // Add fallback for volumetricSpeed in case it's not found\n    const dropletWithParams = currentBlockDroplets.find(d => d && d.parameters && Array.isArray(d.parameters));\n    if (!dropletWithParams) {\n      console.warn('No droplet with valid parameters found');\n      return [];\n    }\n\n    // Make sure we can find the volumetricSpeed parameter or use a default\n    const volumetricSpeedParam = dropletWithParams.parameters.find(p => p && p.name === 'volumetricSpeed');\n    const commonVolumetricSpeed = (volumetricSpeedParam === null || volumetricSpeedParam === void 0 ? void 0 : volumetricSpeedParam.value) || 1;\n    console.log('Using volumetricSpeed:', commonVolumetricSpeed);\n\n    //adds some parameters to nodes\n    orderedNodes.forEach(node => {\n      node.inletVolumetricSpeed = commonVolumetricSpeed;\n      node.outletVolumetricSpeed = commonVolumetricSpeed;\n      const pump = findConnectedPump(node.node.id, graphData.nodes, graphData.links);\n      if (pump) {\n        node.connectedPump = pump;\n      } else {\n        node.connectedPump = 0;\n      }\n      node.connectedPumpRatio = 0;\n      node.connectedPumpSpeedAtPause = 0;\n      node.pumpSpeedMultiplier = 1;\n      //node.requestedRatio = 0;\n      node.pauseLevel = 0;\n    });\n    //ustawia carrier pump na odpowiednią predkość\n    const carrierPumpConnector = graphData.links.find(link => link.source === selectedCarrierPumps[0]).target;\n    if (carrierPumpConnector) {\n      const connectorNode = orderedNodes.find(node => node.node.id === carrierPumpConnector);\n      connectorNode.inletVolumetricSpeed = commonVolumetricSpeed;\n      connectorNode.outletVolumetricSpeed = commonVolumetricSpeed;\n      connectorNode.connectedPump = graphData.nodes.find(node => node.id === selectedCarrierPumps[0]);\n      connectorNode.connectedPumpRatio = 1;\n      connectorNode.connectedPumpSpeedAtPause = commonVolumetricSpeed;\n      //connectorNode.requestedRatio = 0;\n      connectorNode.pauseLevel = 0;\n    }\n    let event = {\n      //it is ok\n      type: 'setPumpSpeed',\n      target: selectedCarrierPumps[0],\n      time: 0,\n      value: commonVolumetricSpeed\n    };\n    eventList.push(event);\n    orderedNodes.filter(node => node.node.type === 'pump' && node.node.id !== selectedCarrierPumps[0]).forEach(pump => {\n      event = {\n        //it is ok\n        type: 'setPumpSpeed',\n        target: pump.node.id,\n        time: 0,\n        value: 0\n      };\n      eventList.push(event);\n    });\n    let position = -0.001;\n    //prepares all droplets in block and calculates some parameters\n    currentBlockDroplets.forEach(droplet => {\n      var _droplet$parameters$f6, _droplet$parameters$f7;\n      const prefixVolume = (_droplet$parameters$f6 = droplet.parameters.find(p => p.name === 'prefixVolume')) === null || _droplet$parameters$f6 === void 0 ? void 0 : _droplet$parameters$f6.value;\n      const surfixVolume = (_droplet$parameters$f7 = droplet.parameters.find(p => p.name === 'surfixVolume')) === null || _droplet$parameters$f7 === void 0 ? void 0 : _droplet$parameters$f7.value;\n      droplet.frontVolumetricSpeed = commonVolumetricSpeed;\n      droplet.rearVolumetricSpeed = commonVolumetricSpeed;\n      droplet.frontVolumetricPosition = position - prefixVolume;\n      droplet.rearVolumetricPosition = droplet.frontVolumetricPosition;\n      droplet.frontVolumetricDistanceToNextNode = Math.abs(droplet.frontVolumetricPosition);\n      droplet.rearVolumetricDistanceToNextNode = Math.abs(droplet.rearVolumetricPosition);\n      droplet.frontTimeToReachNextNode = 0;\n      droplet.rearTimeToReachNextNode = 0;\n      droplet.frontNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\n      droplet.rearNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\n      droplet.pumpSpeedMultiplier = 1;\n      droplet.pauseLevel = 0;\n      droplet.frontVolumetricSpeedAtPause = 0;\n      droplet.rearVolumetricSpeedAtPause = 0;\n      droplet.stoppingDroplet = false;\n      droplet.initialPumping = false;\n      position -= prefixVolume + surfixVolume;\n    });\n    console.log('findFurthestNode: ', findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id);\n    console.log('Droplet positions initialized, nodes ready');\n    let lastDropletRearPosition = currentBlockDroplets[currentBlockDroplets.length - 1].rearVolumetricPosition;\n    let outletNodePosition = orderedNodes[0].node.volumetricPosition;\n    let timePassed = 0; //in s\n    let newTimePassed = 0;\n\n    // Simulate the movement of droplets in the current block\n    currentBlockDroplets.forEach(droplet => {\n      droplet.frontTimeToReachNextNode = Math.abs(droplet.frontVolumetricDistanceToNextNode / droplet.frontVolumetricSpeed);\n      droplet.rearTimeToReachNextNode = Math.abs(droplet.rearVolumetricDistanceToNextNode / droplet.rearVolumetricSpeed);\n    });\n    while (lastDropletRearPosition < outletNodePosition) {\n      let smallestFrontTime = Infinity;\n      let smallestRearTime = Infinity;\n      let smallestFrontTimeDroplet = [];\n      let smallestRearTimeDroplet = [];\n      currentBlockDroplets.forEach(droplet => {\n        // Update the smallest front and rear times and associated droplet(s) based on the current droplet's front and rear times to reach the next node.\n\n        if (Math.abs(droplet.frontTimeToReachNextNode) < smallestFrontTime) {\n          smallestFrontTime = Math.abs(droplet.frontTimeToReachNextNode);\n          smallestFrontTimeDroplet = [droplet];\n        } else if (Math.abs(droplet.frontTimeToReachNextNode) === smallestFrontTime) {\n          smallestFrontTimeDroplet.push(droplet);\n        }\n        if (Math.abs(droplet.rearTimeToReachNextNode) < smallestRearTime) {\n          smallestRearTime = Math.abs(droplet.rearTimeToReachNextNode);\n          smallestRearTimeDroplet = [droplet];\n        } else if (Math.abs(droplet.rearTimeToReachNextNode) === smallestRearTime) {\n          smallestRearTimeDroplet.push(droplet);\n        }\n      });\n      newTimePassed += Math.min(Math.abs(smallestFrontTime), Math.abs(smallestRearTime));\n      if (smallestFrontTime === smallestRearTime) {\n        //przypadek w ktorym wiele kropel ma ten sam czas do przejścia do nastepnego noda, rzadki\n\n        if (smallestFrontTimeDroplet.length > 1 || smallestRearTimeDroplet.length > 1) {\n          //sprawdź czy wśród nich jest kropla z rear i front\n          console.log('Multiple droplets have reached the next node simultaneously');\n          console.log('smallestFrontTimeDroplet: ', smallestFrontTimeDroplet);\n          console.log('smallestRearTimeDroplet: ', smallestRearTimeDroplet);\n        } else if (smallestFrontTimeDroplet[0] === smallestRearTimeDroplet[0]) {\n          //przypadek gdy kropla ma 0 objętości\n          console.log('Both front and rear times are for the same droplet');\n          const reachedNode = orderedNodes.find(n => n.node.id === smallestFrontTimeDroplet[0].frontNextNodeID);\n          const reachedNodeDistance = orderedNodes.find(node => node.node.id === reachedNode.node.id).distance;\n          if (reachedNode.node.type === 'connector') {\n            const index = currentBlockDroplets.indexOf(smallestFrontTimeDroplet[0]);\n            const dropletsOlder = currentBlockDroplets.slice(0, index);\n            const dropletsNewer = currentBlockDroplets.slice(index + 1);\n            const ds = [];\n            ds.drops = JSON.parse(JSON.stringify(dropletsNewer)); // Create deep copy\n            ds.snappedNode = smallestFrontTimeDroplet[0].frontNextNodeID;\n            const existingSnapshotIndex = dropletSnapshot.findIndex(snapshot => snapshot.snappedNode === ds.snappedNode);\n            if (existingSnapshotIndex !== -1) {\n              dropletSnapshot[existingSnapshotIndex] = ds;\n            } else {\n              dropletSnapshot.push(ds);\n            }\n\n            //aktualizuje starsze krople\n            dropletsOlder.forEach(droplet => {\n              droplet.frontTimeToReachNextNode -= smallestFrontTime;\n              droplet.rearTimeToReachNextNode -= smallestFrontTime;\n              droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n              droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n              droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n              droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n            });\n\n            //aktualizuje kroplę\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n            const nextEdge = graphData.links.find(link => link.source === smallestFrontTimeDroplet[0].frontNextNodeID && link.target === nextNode.node.id);\n            if (reachedNode.connectedPump !== null) {\n              var _smallestFrontTimeDro, _smallestFrontTimeDro2;\n              const pumpRatio = ((_smallestFrontTimeDro = smallestFrontTimeDroplet[0].parameters.find(param => param.nodeId === reachedNode.connectedPump.id && param.name === 'ratio')) === null || _smallestFrontTimeDro === void 0 ? void 0 : _smallestFrontTimeDro.value) || 0;\n              const dropletDesiredVolume = ((_smallestFrontTimeDro2 = smallestFrontTimeDroplet[0].parameters.find(param => param.name === 'volume')) === null || _smallestFrontTimeDro2 === void 0 ? void 0 : _smallestFrontTimeDro2.value) || 0;\n              reachedNode.connectedPumpRatio = pumpRatio;\n              //reachedNode.inletVolumetricSpeed = 0;\n              //smallestFrontTimeDroplet[0].frontVolumetricSpeed = reachedNode.outletVolumetricSpeed;\n              smallestFrontTimeDroplet[0].frontVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              smallestFrontTimeDroplet[0].rearVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].rearVolumetricSpeed;\n              smallestFrontTimeDroplet[0].rearVolumetricSpeed = 0;\n              smallestFrontTimeDroplet[0].frontVolumetricPosition = reachedNode.node.volumetricPosition;\n              smallestFrontTimeDroplet[0].rearVolumetricPosition = reachedNode.node.volumetricPosition;\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n              smallestFrontTimeDroplet[0].rearVolumetricDistanceToNextNode = 0;\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              smallestFrontTimeDroplet[0].rearTimeToReachNextNode = dropletDesiredVolume * pumpRatio / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\n              //smallestFrontTimeDroplet[0].rearNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\n              smallestFrontTimeDroplet[0].pumpSpeedMultiplier = 1;\n              //smallestFrontTimeDroplet[0].pauseLevel = 0;\n              smallestFrontTimeDroplet[0].stoppingDroplet = true;\n              smallestFrontTimeDroplet[0].initialPumping = true;\n              if (reachedNode.connectedPump.id !== selectedCarrierPumps[0]) {\n                event = {\n                  type: 'setPumpSpeed',\n                  target: reachedNode.connectedPump.id,\n                  time: newTimePassed,\n                  value: smallestFrontTimeDroplet[0].frontVolumetricSpeed\n                };\n                eventList.push(event);\n              }\n\n              //update newer droplets\n              dropletsNewer.forEach(droplet => {\n                droplet.pauseLevel += 1;\n                if (droplet.pauseLevel === 1) {\n                  droplet.frontVolumetricSpeedAtPause = droplet.frontVolumetricSpeed;\n                  if (droplet.stoppingDroplet !== true) {\n                    droplet.rearVolumetricSpeedAtPause = droplet.rearVolumetricSpeed;\n                  }\n                }\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricSpeed = 0;\n                droplet.rearVolumetricSpeed = 0;\n                droplet.frontTimeToReachNextNode += smallestFrontTimeDroplet[0].rearTimeToReachNextNode - smallestFrontTime;\n                droplet.rearTimeToReachNextNode += smallestFrontTimeDroplet[0].rearTimeToReachNextNode - smallestFrontTime;\n              });\n              getPumpsBetweenPositions(smallestFrontTimeDroplet[0].frontVolumetricPosition, -1, graphData.nodes, graphData.links).filter(pump => pump.id !== reachedNode.connectedPump.id).forEach(pump => {\n                event = {\n                  type: 'setPumpSpeed',\n                  target: pump.id,\n                  time: newTimePassed,\n                  value: 0\n                };\n                eventList.push(event);\n              });\n            }\n          } else if (reachedNode.type === 'thermostat' || reachedNode.type === 'LED') {\n            console.log('reachedNode is thermostat');\n          } else if (reachedNode.type === 'outlet') {\n            console.log('reachedNode is outlet');\n          } else if (reachedNode.type === 'detector' || reachedNode.type === 'USBSpectrometer' || reachedNode.type === 'MQTTSpectrometer') {\n            console.log('reachedNode is detector');\n          }\n        } else {\n          console.log('Front and rear times are for different droplets');\n        }\n      } else if (smallestFrontTime < smallestRearTime) {\n        //przypadek gdzie przód jest przed tyłem\n        console.log('Front time is smaller than rear time');\n        if (smallestFrontTimeDroplet.length > 1) {\n          console.log(`Multiple droplets have reached the next node simultaneously`);\n          smallestFrontTimeDroplet.forEach(droplet => {\n            // Perform some action for each droplet in smallestFrontTimeDroplet\n          });\n        } else {\n          //przypadek gdy przód jednej kropelki dochodzi do noda\n          console.log(`Single droplet front has reached the next node`);\n          const reachedNode = orderedNodes.find(n => n.node.id === smallestFrontTimeDroplet[0].frontNextNodeID);\n          const reachedNodeDistance = orderedNodes.find(node => node.node.id === reachedNode.node.id).distance;\n          if (reachedNode.node.type === 'connector') {\n            //przypadek gdy dochodzi do connectora\n            console.log('reachedNode is connector');\n            const index = currentBlockDroplets.indexOf(smallestFrontTimeDroplet[0]);\n            const dropletsOlder = currentBlockDroplets.slice(0, index);\n            const dropletsNewer = currentBlockDroplets.slice(index + 1);\n\n            //aktualizuje kroplę\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n            const nextEdge = graphData.links.find(link => link.source === reachedNode.node.id && link.target === nextNode.node.id);\n            if (reachedNode.connectedPump.id !== null) {\n              var _smallestFrontTimeDro3, _smallestFrontTimeDro4;\n              const pumpRatio = ((_smallestFrontTimeDro3 = smallestFrontTimeDroplet[0].parameters.find(param => param.nodeId === reachedNode.connectedPump.id && param.name === 'ratio')) === null || _smallestFrontTimeDro3 === void 0 ? void 0 : _smallestFrontTimeDro3.value) || 0;\n              const dropletDesiredVolume = ((_smallestFrontTimeDro4 = smallestFrontTimeDroplet[0].parameters.find(param => param.name === 'volume')) === null || _smallestFrontTimeDro4 === void 0 ? void 0 : _smallestFrontTimeDro4.value) || 0;\n              smallestFrontTimeDroplet[0].frontVolumetricPosition = reachedNode.node.volumetricPosition;\n              smallestFrontTimeDroplet[0].rearVolumetricPosition += smallestFrontTime * smallestFrontTimeDroplet[0].rearVolumetricSpeed;\n              smallestFrontTimeDroplet[0].actualVolume = smallestFrontTimeDroplet[0].frontVolumetricPosition - smallestFrontTimeDroplet[0].rearVolumetricPosition;\n              reachedNode.inletVolumetricSpeed = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              reachedNode.connectedPumpRatio = pumpRatio;\n              smallestFrontTimeDroplet[0].rearTimeToReachNextNode -= smallestFrontTime;\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n              smallestFrontTimeDroplet[0].rearVolumetricDistanceToNextNode -= smallestFrontTime * smallestFrontTimeDroplet[0].rearVolumetricSpeed;\n              if (smallestFrontTimeDroplet[0].initialPumping === true) {\n                //przypadek gdy kropla jest w pierwszej fazie pompowania (od 0uL)\n                console.log('Kropla jest w pierwszej fazie pompowania');\n                //smallestFrontTimeDroplet[0].initialPumping = false;\n                const rearTimeLeft = smallestFrontTimeDroplet[0].rearTimeToReachNextNode;\n                const totalTimeLeft = rearTimeLeft + smallestFrontTimeDroplet[0].actualVolume / commonVolumetricSpeed;\n                console.log('commonVolumetricSpeed: ', commonVolumetricSpeed);\n                console.log('smallestFrontTimeDroplet[0].actualVolume: ', smallestFrontTimeDroplet[0].actualVolume);\n                console.log('rearTimeLeft: ', rearTimeLeft);\n                console.log('totalTimeLeft: ', totalTimeLeft);\n                const thispumpspeed = pumpRatio * dropletDesiredVolume / totalTimeLeft;\n                console.log('thispumpspeed: ', thispumpspeed);\n                reachedNode.connectedPumpSpeedAtPause = thispumpspeed;\n              } else {\n                console.log('Normalne pompowanie');\n                reachedNode.connectedPumpSpeedAtPause = dropletDesiredVolume * pumpRatio / (smallestFrontTimeDroplet[0].actualVolume / reachedNode.inletVolumetricSpeed);\n              }\n              reachedNode.outletVolumetricSpeed = reachedNode.inletVolumetricSpeed + reachedNode.connectedPumpSpeedAtPause;\n              smallestFrontTimeDroplet[0].frontVolumetricSpeed += reachedNode.connectedPumpSpeedAtPause;\n              //smallestFrontTimeDroplet[0].rearVolumetricSpeed = 0;\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\n              //smallestFrontTimeDroplet[0].rearNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\n              //smallestFrontTimeDroplet[0].pumpSpeedMultiplier = 1;\n              //smallestFrontTimeDroplet[0].pauseLevel = 0;\n              //smallestFrontTimeDroplet[0].frontVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              //smallestFrontTimeDroplet[0].rearVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              //smallestFrontTimeDroplet[0].stoppingDroplet = true;\n              event = {\n                type: 'setPumpSpeed',\n                target: reachedNode.connectedPump.id,\n                time: newTimePassed,\n                value: reachedNode.connectedPumpSpeedAtPause\n              };\n              eventList.push(event);\n              //update newer droplets\n              dropletsNewer.forEach(droplet => {\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontTimeToReachNextNode -= smallestFrontTime;\n                droplet.rearTimeToReachNextNode -= smallestFrontTime;\n              });\n              //aktualizuje starsze krople\n              let accumulatedSpeed = reachedNode.connectedPumpSpeedAtPause;\n              dropletsOlder.reverse().forEach(droplet => {\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.rearVolumetricSpeed += accumulatedSpeed;\n                getPumpsBetweenPositions(droplet.frontVolumetricPosition, droplet.rearVolumetricPosition, graphData.nodes, graphData.links).forEach(pump => {\n                  const editedNode = orderedNodes.find(node => node.connectedPump.id === pump.id);\n                  //editedNode.pumpSpeedMultiplier = 1;\n                  const pumpBoost = editedNode.connectedPumpSpeedAtPause * accumulatedSpeed / editedNode.inletVolumetricSpeed;\n                  editedNode.connectedPumpSpeedAtPause += pumpBoost;\n                  editedNode.inletVolumetricSpeed += accumulatedSpeed;\n                  accumulatedSpeed += pumpBoost;\n                  editedNode.outletVolumetricSpeed += accumulatedSpeed;\n                  event = {\n                    type: 'setPumpSpeed',\n                    target: pump.id,\n                    time: newTimePassed,\n                    value: editedNode.connectedPumpSpeedAtPause\n                  };\n                  eventList.push(event);\n                });\n                droplet.frontVolumetricSpeed += accumulatedSpeed;\n                droplet.frontTimeToReachNextNode = droplet.frontVolumetricDistanceToNextNode / droplet.frontVolumetricSpeed;\n                droplet.rearTimeToReachNextNode = droplet.rearVolumetricDistanceToNextNode / droplet.rearVolumetricSpeed;\n              });\n            }\n          } else if (reachedNode.node.type === 'thermostat' || reachedNode.type === 'LED') {\n            //przypadek gdy dochodzi do termostatu\n            console.log('reachedNode (thermostat, LED): ', reachedNode);\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n            if (nextNode) {\n              const nextEdge = graphData.links.find(link => link.source === smallestFrontTimeDroplet[0].frontNextNodeID && link.target === nextNode.node.id);\n              //aktualizuje krople\n              currentBlockDroplets.forEach(droplet => {\n                droplet.frontTimeToReachNextNode -= smallestFrontTime;\n                droplet.rearTimeToReachNextNode -= smallestFrontTime;\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n              });\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\n            }\n          } else if (reachedNode.node.type === 'outlet') {\n            //jeśli ostatni node osiągnięty\n            console.log('reachedNode (outlet): ', reachedNode);\n            //typowe zaktualizowanie czasu do następnego noda dla reszty kropel i zestallowanie frontu\n            currentBlockDroplets.forEach(droplet => {\n              droplet.frontTimeToReachNextNode -= smallestFrontTime;\n              droplet.rearTimeToReachNextNode -= smallestFrontTime;\n              droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n              droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n              droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n              droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n            });\n            smallestFrontTimeDroplet[0].frontTimeToReachNextNode = Infinity;\n            smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = Infinity;\n            smallestFrontTimeDroplet[0].frontNextNodeID = null;\n          } else if (reachedNode.node.type === 'detector' || reachedNode.node.type === 'USBSpectrometer' || reachedNode.node.type === 'MQTTSpectrometer') {\n            //przypadek gdy dochodzi do detektora\n            console.log('reachedNode (detector): ', reachedNode);\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n            if (nextNode) {\n              const nextEdge = graphData.links.find(link => link.source === smallestFrontTimeDroplet[0].frontNextNodeID && link.target === nextNode.node.id);\n              //aktualizuje krople\n              currentBlockDroplets.forEach(droplet => {\n                droplet.frontTimeToReachNextNode -= smallestFrontTime;\n                droplet.rearTimeToReachNextNode -= smallestFrontTime;\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n              });\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\n            }\n          }\n        }\n      } else {\n        //przypadek gdzie tył jest przed przodem\n        console.log('Rear time is smaller than front time');\n        if (smallestRearTimeDroplet.length > 1) {\n          //przypadek gdy dochodzi do noda wiele kropel\n          console.log(`Multiple droplets ends have reached the next node simultaneously`);\n          smallestRearTimeDroplet.forEach(droplet => {\n            // Perform some action for each droplet in smallestRearTimeDroplet\n          });\n        } else {\n          //przypadek gdy tył jednej kropelki dochodzi do noda\n          const reachedNode = orderedNodes.find(n => n.node.id === smallestRearTimeDroplet[0].rearNextNodeID);\n          const reachedNodeDistance = orderedNodes.find(node => node.node.id === reachedNode.node.id).distance;\n          if (reachedNode.node.type === 'connector') {\n            //przypadek gdy dochodzi do connectora\n            console.log('reachedNode is connector');\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n            const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\n            const index = currentBlockDroplets.indexOf(smallestRearTimeDroplet[0]);\n            const dropletsOlder = currentBlockDroplets.slice(0, index);\n            const dropletsNewer = currentBlockDroplets.slice(index + 1);\n            if (smallestRearTimeDroplet[0].stoppingDroplet === true) {\n              //wznawia jeśli była zatrzymana\n              //aktualizuje starsze krople\n              dropletsOlder.forEach(droplet => {\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\n                droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n              });\n\n              //aktualizuje nowsze krople\n              dropletsNewer.forEach(droplet => {\n                if (droplet.pauseLevel === 1) {\n                  //\n                  droplet.pauseLevel = 0;\n                  droplet.frontVolumetricSpeed = droplet.frontVolumetricSpeedAtPause;\n                  droplet.rearVolumetricSpeed = droplet.rearVolumetricSpeedAtPause;\n                  getPumpsBetweenPositions(droplet.frontVolumetricPosition, droplet.rearVolumetricPosition, graphData.nodes, graphData.links).forEach(pump => {\n                    event = {\n                      type: 'setPumpSpeed',\n                      target: pump.id,\n                      time: newTimePassed,\n                      value: orderedNodes.find(node => node.node.id === pump.id).connectedPumpSpeedAtPause\n                    };\n                    eventList.push(event);\n                  });\n                } else {\n                  droplet.pauseLevel -= 1;\n                }\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\n              });\n              reachedNode.connectedPumpRatio = 0;\n              //reachedNode.inletVolumetricSpeed = 0;\n              //smallestRearTimeDroplet[0].frontVolumetricSpeed = reachedNode.outletVolumetricSpeed;\n              smallestRearTimeDroplet[0].rearVolumetricSpeed = smallestRearTimeDroplet[0].rearVolumetricSpeedAtPause;\n              smallestRearTimeDroplet[0].frontVolumetricPosition += smallestRearTimeDroplet[0].frontVolumetricSpeed * smallestRearTime;\n              smallestRearTimeDroplet[0].rearVolumetricPosition = reachedNode.node.volumetricPosition;\n              smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode -= smallestRearTimeDroplet[0].frontVolumetricSpeed * smallestRearTime;\n              smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n              smallestRearTimeDroplet[0].frontTimeToReachNextNode = smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].frontVolumetricSpeed;\n              smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\n              //smallestRearTimeDroplet[0].frontNextNodeID = nextNode.id;\n              smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\n              //smallestRearTimeDroplet[0].pumpSpeedMultiplier = 1;\n              //smallestRearTimeDroplet[0].pauseLevel = 0;\n              smallestRearTimeDroplet[0].frontVolumetricSpeedAtPause = smallestRearTimeDroplet[0].frontVolumetricSpeed;\n              smallestRearTimeDroplet[0].rearVolumetricSpeedAtPause = smallestRearTimeDroplet[0].rearVolumetricSpeed;\n              smallestRearTimeDroplet[0].stoppingDroplet = false;\n              smallestRearTimeDroplet[0].initialPumping = false;\n              reachedNode.connectedPumpRatio = 0;\n              event = {\n                type: 'setPumpSpeed',\n                target: reachedNode.connectedPump.id,\n                time: newTimePassed,\n                value: 0\n              };\n              eventList.push(event);\n              event = {\n                type: 'setPumpSpeed',\n                target: selectedCarrierPumps[0],\n                time: newTimePassed,\n                value: commonVolumetricSpeed\n              };\n              eventList.push(event);\n            } else {\n              console.log('it is not stopper');\n              if (reachedNode.connectedPump.id !== null) {\n                const speedDifference = reachedNode.outletVolumetricSpeed - reachedNode.inletVolumetricSpeed;\n                //reachedNode.inletVolumetricSpeed = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n                reachedNode.outletVolumetricSpeed = reachedNode.inletVolumetricSpeed;\n                reachedNode.connectedPumpRatio = 0;\n                reachedNode.connectedPumpSpeedAtPause = 0;\n                smallestRearTimeDroplet[0].frontVolumetricPosition += smallestRearTime * smallestRearTimeDroplet[0].frontVolumetricSpeed;\n                smallestRearTimeDroplet[0].rearVolumetricPosition = reachedNode.node.volumetricPosition;\n                smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode -= smallestRearTime * smallestRearTimeDroplet[0].frontVolumetricSpeed;\n                smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n                //smallestRearTimeDroplet[0].frontNextNodeID = nextNode.id;\n                smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\n                //smallestRearTimeDroplet[0].pumpSpeedMultiplier = 1;\n                //smallestRearTimeDroplet[0].pauseLevel = 0; \n                //smallestRearTimeDroplet[0].stoppingDroplet = true;\n                smallestRearTimeDroplet[0].frontVolumetricSpeed = smallestRearTimeDroplet[0].frontVolumetricSpeed - speedDifference;\n                //smallestRearTimeDroplet[0].rearVolumetricSpeed = 0;\n                smallestRearTimeDroplet[0].frontVolumetricSpeedAtPause = smallestRearTimeDroplet[0].frontVolumetricSpeed;\n                //smallestRearTimeDroplet[0].rearVolumetricSpeedAtPause = smallestRearTimeDroplet[0].rearVolumetricSpeed;\n                smallestRearTimeDroplet[0].frontTimeToReachNextNode = smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].frontVolumetricSpeed;\n                smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\n                event = {\n                  type: 'setPumpSpeed',\n                  target: reachedNode.connectedPump.id,\n                  time: newTimePassed,\n                  value: reachedNode.connectedPumpSpeedAtPause\n                };\n                eventList.push(event);\n                //updte newer droplets\n                dropletsNewer.forEach(droplet => {\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                  droplet.frontTimeToReachNextNode -= smallestRearTime;\n                  droplet.rearTimeToReachNextNode -= smallestRearTime;\n                });\n                //aktualizuje starsze krople\n                let accumulatedSpeedDecrease = speedDifference;\n                dropletsOlder.reverse().forEach(droplet => {\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                  droplet.rearVolumetricSpeed -= accumulatedSpeedDecrease;\n                  getPumpsBetweenPositions(droplet.frontVolumetricPosition, droplet.rearVolumetricPosition, graphData.nodes, graphData.links).forEach(pump => {\n                    const editedNode = orderedNodes.find(node => node.connectedPump.id === pump.id);\n                    const pumpBreak = editedNode.connectedPumpSpeedAtPause * accumulatedSpeedDecrease / editedNode.inletVolumetricSpeed;\n                    editedNode.connectedPumpSpeedAtPause -= pumpBreak;\n                    editedNode.inletVolumetricSpeed -= accumulatedSpeedDecrease;\n                    accumulatedSpeedDecrease += pumpBreak;\n                    editedNode.outletVolumetricSpeed -= accumulatedSpeedDecrease;\n                    event = {\n                      type: 'setPumpSpeed',\n                      target: pump.id,\n                      time: newTimePassed,\n                      value: editedNode.connectedPumpSpeedAtPause\n                    };\n                    eventList.push(event);\n                  });\n                  droplet.frontVolumetricSpeed -= accumulatedSpeedDecrease;\n                  droplet.frontTimeToReachNextNode = droplet.frontVolumetricDistanceToNextNode / droplet.frontVolumetricSpeed;\n                  droplet.rearTimeToReachNextNode = droplet.rearVolumetricDistanceToNextNode / droplet.rearVolumetricSpeed;\n                });\n              }\n            }\n          } else if (reachedNode.node.type === 'thermostat' || reachedNode.node.type === 'LED') {\n            //przypadek gdy dochodzi do termostatu\n            console.log('reachedNode thermostat: ', reachedNode);\n            const isFarthestThermostatOrLED = orderedNodes.filter(node => node.node.type === 'thermostat' || node.node.type === 'LED').every(node => node.distance <= reachedNodeDistance);\n\n            // This line checks if the smallestRearTimeDroplet is the last droplet in the currentBlockDroplets array.\n            if (isFarthestThermostatOrLED && currentBlockDroplets.length === currentBlockDroplets.indexOf(smallestRearTimeDroplet[0]) + 1) {\n              var _smallestRearTimeDrop;\n              console.log('This is the farthest thermostat or LED node. Also, last droplet just passed through it.');\n              const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n              const waitTime = ((_smallestRearTimeDrop = smallestRearTimeDroplet[0].parameters.find(param => param.nodeId === reachedNode.node.id && param.name === 'time')) === null || _smallestRearTimeDrop === void 0 ? void 0 : _smallestRearTimeDrop.value) || 0;\n              if (nextNode) {\n                const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\n                smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n                smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed + smallestRearTime;\n                smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\n                //aktualizuje resztę kropli\n                currentBlockDroplets.forEach(droplet => {\n                  droplet.frontTimeToReachNextNode += waitTime - smallestRearTime;\n                  droplet.rearTimeToReachNextNode += waitTime - smallestRearTime;\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed - waitTime * droplet.frontVolumetricSpeed; //to jest zrobione na razie aby czas się zgadzał\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed - waitTime * droplet.rearVolumetricSpeed;\n                });\n                let carrierPumpEvent = {\n                  type: 'setPumpSpeed',\n                  target: selectedCarrierPumps[0],\n                  // Assuming 'carrierPumpId' is the ID of the carrier pump\n                  time: newTimePassed,\n                  value: 0\n                };\n                eventList.push(carrierPumpEvent);\n                carrierPumpEvent = {\n                  type: 'setPumpSpeed',\n                  target: selectedCarrierPumps[0],\n                  // Assuming 'carrierPumpId' is the ID of the carrier pump\n                  time: newTimePassed + waitTime,\n                  value: commonVolumetricSpeed\n                };\n                eventList.push(carrierPumpEvent);\n              }\n            } else {\n              //droplet wasnt the last one\n              console.log('smallestRearTimeDroplet is not the last droplet in the currentBlockDroplets array');\n              const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n              if (nextNode) {\n                const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\n                //aktualizuje krople\n                currentBlockDroplets.forEach(droplet => {\n                  droplet.frontTimeToReachNextNode -= smallestRearTime;\n                  droplet.rearTimeToReachNextNode -= smallestRearTime;\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n                });\n                smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n                smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\n                smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\n              }\n            }\n          } else if (reachedNode.node.type === 'outlet') {\n            //jeśli ostatni node osiągnięty\n            //typowe zaktualizowanie czasu do następnego noda dla reszty kropel i zestallowanie reara\n            //aktualizuje resztę kropli\n            currentBlockDroplets.forEach(droplet => {\n              droplet.frontTimeToReachNextNode -= smallestRearTime;\n              droplet.rearTimeToReachNextNode -= smallestRearTime;\n              droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n              droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n              droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n              droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n            });\n            smallestRearTimeDroplet[0].frontTimeToReachNextNode = Infinity;\n            smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode = Infinity;\n            smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = Infinity;\n            smallestRearTimeDroplet[0].rearNextNodeID = null;\n            smallestRearTimeDroplet[0].rearTimeToReachNextNode = Infinity;\n          } else if (reachedNode.node.type === 'detector' || reachedNode.node.type === 'USBSpectrometer' || reachedNode.node.type === 'MQTTSpectrometer') {\n            //przypadek gdy dochodzi do detektora\n            console.log('reachedNode (detector): ', reachedNode);\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n            if (nextNode) {\n              const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\n              //aktualizuje krople\n              currentBlockDroplets.forEach(droplet => {\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\n                droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n              });\n              smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n              smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\n              smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\n            }\n          }\n        }\n      }\n      timePassed = newTimePassed;\n      // Update last droplet rear position\n      lastDropletRearPosition = currentBlockDroplets[currentBlockDroplets.length - 1].rearVolumetricPosition;\n\n      //add code that preserves droplets positions and speeds for visualization\n      const dropletState = {\n        time: timePassed,\n        droplets: currentBlockDroplets.map(droplet => {\n          var _droplet$parameters$f8;\n          return {\n            id: droplet.id,\n            frontVolumetricPosition: droplet.frontVolumetricPosition,\n            rearVolumetricPosition: droplet.rearVolumetricPosition,\n            frontVolumetricSpeed: droplet.frontVolumetricSpeed,\n            rearVolumetricSpeed: droplet.rearVolumetricSpeed,\n            pumpSpeedMultiplier: droplet.pumpSpeedMultiplier,\n            frontTimeToReachNextNode: droplet.frontTimeToReachNextNode,\n            rearTimeToReachNextNode: droplet.rearTimeToReachNextNode,\n            frontVolumetricDistanceToNextNode: droplet.frontVolumetricDistanceToNextNode,\n            rearVolumetricDistanceToNextNode: droplet.rearVolumetricDistanceToNextNode,\n            volume: ((_droplet$parameters$f8 = droplet.parameters.find(p => p.name === 'volume')) === null || _droplet$parameters$f8 === void 0 ? void 0 : _droplet$parameters$f8.value) || 0,\n            frontNextNodeID: droplet.frontNextNodeID,\n            rearNextNodeID: droplet.rearNextNodeID\n          };\n        })\n      };\n      setDropletHistory(prev => [...prev, dropletState]);\n\n      //if (timePassed > 9999) {//here for testing, preventing infinite loop\n      //  lastDropletRearPosition = 88100;\n      //}\n    }\n    event = {\n      //it is ok\n      type: 'setPumpSpeed',\n      target: selectedCarrierPumps[0],\n      time: timePassed,\n      value: 0\n    };\n    eventList.push(event);\n    eventList = cleanAndSortEventList(eventList);\n    console.log('dropletHistory in event generator: ', dropletHistory);\n    console.log('eventList: ', eventList.sort((a, b) => a.time - b.time));\n    setPumpEvents(extractPumpEvents(eventList));\n    return eventList;\n  };\n  // First useEffect to set initial graphData\n  useEffect(() => {\n    setDropletHistory([]);\n    if (nodes.length > 0 && edges.length > 0) {\n      const graphNodes = nodes.map(node => ({\n        id: node.id,\n        label: node.data.label,\n        type: node.data.type,\n        x: 0,\n        y: 0,\n        volumetricPosition: 0\n      }));\n      const graphLinks = edges.map(edge => {\n        var _edge$data, _edge$data$properties, _edge$data2, _edge$data2$propertie;\n        return {\n          source: edge.source,\n          target: edge.target,\n          length: ((_edge$data = edge.data) === null || _edge$data === void 0 ? void 0 : (_edge$data$properties = _edge$data.properties) === null || _edge$data$properties === void 0 ? void 0 : _edge$data$properties.length) || 100,\n          diameter: ((_edge$data2 = edge.data) === null || _edge$data2 === void 0 ? void 0 : (_edge$data2$propertie = _edge$data2.properties) === null || _edge$data2$propertie === void 0 ? void 0 : _edge$data2$propertie.diameter) || 1\n        };\n      });\n      setGraphData({\n        nodes: graphNodes,\n        links: graphLinks\n      });\n    }\n  }, [nodes, edges]);\n\n  // Second useEffect to calculate nodes positions and set up simulation data\n  useEffect(() => {\n    if (!graphData.nodes.length || !graphData.links.length || !droplets.length) {\n      console.log('Missing required data for simulation setup:', {\n        nodesLength: graphData.nodes.length,\n        linksLength: graphData.links.length,\n        dropletsLength: droplets.length\n      });\n      return;\n    }\n    const graphNodes = [...graphData.nodes];\n\n    // Find outlet node first\n    const outletNode = findOutletNode(graphData.nodes);\n    if (!outletNode) {\n      console.error('No outlet node found. Cannot set up simulation.');\n      return;\n    }\n\n    // Get ordered nodes from outlet\n    const orderedNodes = orderNodesByDistance(outletNode, graphData.nodes, graphData.links);\n\n    // Separate nodes into main line and secondary line\n    const mainLineNodes = orderedNodes.filter(({\n      node\n    }) => setOfMainLineNodes.includes(node.type)).reverse();\n    const secondaryLineNodes = orderedNodes.filter(({\n      node\n    }) => setOfSecondaryLineNodes.includes(node.type)).sort((a, b) => b.distance - a.distance);\n\n    // Position settings\n    const mainLineY = 300;\n    const secondaryLineY = 150;\n    const pumpSpacing = 100; // Increased horizontal spacing between pumps\n    let currentX = 100;\n\n    // Position main line nodes\n    let currentVolumetricPosition = 0;\n    mainLineNodes.forEach(({\n      node\n    }, index) => {\n      const graphNode = graphNodes.find(n => n.id === node.id);\n      if (!graphNode) return;\n      graphNode.x = currentX;\n      graphNode.y = mainLineY;\n      graphNode.volumetricPosition = currentVolumetricPosition;\n      if (index < mainLineNodes.length - 1) {\n        const nextNode = mainLineNodes[index + 1];\n        const edge = graphData.links.find(e => e.source === graphNode.id && e.target === nextNode.node.id || e.target === graphNode.id && e.source === nextNode.node.id);\n        if (edge && edge.length) {\n          currentX += edge.length * 2;\n          // Use existing calculateEdgeVolume function\n          const edgeVolume = calculateEdgeVolume(edge);\n          currentVolumetricPosition += edgeVolume;\n        } else {\n          currentX += 200;\n          currentVolumetricPosition += 150;\n        }\n      }\n    });\n\n    // Group secondary nodes by distance\n    const nodesByDistance = {};\n    secondaryLineNodes.forEach(({\n      node,\n      distance\n    }) => {\n      if (!nodesByDistance[distance]) {\n        nodesByDistance[distance] = [];\n      }\n      nodesByDistance[distance].push(node);\n    });\n\n    // Position secondary nodes based on their connected main line nodes\n    const pumpOffset = 50; // Add this constant for pump spacing\n    Object.entries(nodesByDistance).forEach(([distance, nodes]) => {\n      nodes.forEach((node, index) => {\n        const graphNode = graphNodes.find(n => n.id === node.id);\n        if (!graphNode) return;\n\n        // Find connected main line node through edges\n        const connectedEdge = edges.find(e => e.source === node.id || e.target === node.id);\n        if (connectedEdge) {\n          const connectedNodeId = connectedEdge.source === node.id ? connectedEdge.target : connectedEdge.source;\n          const connectedMainNode = graphNodes.find(n => n.id === connectedNodeId);\n          if (connectedMainNode) {\n            // Position pump above its connected main line node with offset if needed\n            graphNode.x = connectedMainNode.x + index * pumpOffset - (nodes.length - 1) * pumpOffset / 2;\n            graphNode.y = secondaryLineY;\n          }\n        }\n      });\n    });\n    setGraphData(prev => ({\n      ...prev,\n      nodes: graphNodes\n    }));\n\n    // Only calculate volumes and blocks if not already done\n    if (currentBlockDroplets.length === 0) {\n      console.log('Calculating thermostat volumes and blocks for droplets:', droplets.length);\n      const thermoVol = calculateVolumesBetweenThermostats(graphData);\n\n      // Create deep copy of droplets to avoid mutation issues\n      const dropletsCopy = JSON.parse(JSON.stringify(droplets));\n      const blocks = divideDropletsIntoBlocks(dropletsCopy, thermoVol);\n      if (blocks.length > 0) {\n        setCurrentBlockDroplets(blocks[0].droplets);\n        // Generate event list only once when initializing\n        const eventList = generateEventList(blocks);\n        const eventListForDevices = recalculateEventListForDevices(eventList);\n      }\n    }\n\n    // Important: the dependency array includes currentBlockDroplets.length to prevent infinite recalculations\n  }, [graphData.nodes.length, graphData.links.length, droplets, edges, currentBlockDroplets.length]);\n  const startSimulation = useCallback(() => {\n    setIsSimulationRunning(true);\n    lastFrameTimeRef.current = null; // Reset the last frame time\n  }, []);\n  const stopSimulation = useCallback(() => {\n    setIsSimulationRunning(false);\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n      animationFrameRef.current = null;\n    }\n  }, []);\n  const restartSimulation = useCallback(() => {\n    stopSimulation();\n    setKey(prevKey => prevKey + 1);\n    setCurrentTime(0);\n    startSimulation();\n  }, [stopSimulation, startSimulation]);\n  const getNodeColor = node => {\n    switch (node.type) {\n      case 'pump':\n        return '#4CAF50';\n      case 'connector':\n        return '#2196F3';\n      case 'outlet':\n        return '#F44336';\n      default:\n        return '#FFA000';\n      // Default color for unknown types\n    }\n  };\n\n  // Update volumetricToXPosition function\n  const volumetricToXPosition = useCallback(volumetricPosition => {\n    var _graphData$nodes$find, _graphData$nodes$find2;\n    const outletNode = findOutletNode(graphData.nodes);\n    const furthestNode = findFurthestNode(outletNode, graphData.nodes, graphData.links);\n    if (!outletNode || !furthestNode) return 0;\n    const totalVolume = getVolumeBetweenNodes(furthestNode.id, outletNode.id, graphData.nodes, graphData.links);\n    const outletX = ((_graphData$nodes$find = graphData.nodes.find(n => n.id === outletNode.id)) === null || _graphData$nodes$find === void 0 ? void 0 : _graphData$nodes$find.x) || 0;\n    const furthestX = ((_graphData$nodes$find2 = graphData.nodes.find(n => n.id === furthestNode.id)) === null || _graphData$nodes$find2 === void 0 ? void 0 : _graphData$nodes$find2.x) || 0;\n\n    // Handle edge cases\n    if (!totalVolume || totalVolume === 0 || isNaN(totalVolume)) {\n      console.warn('Total volume is invalid:', totalVolume);\n      return furthestX;\n    }\n    if (volumetricPosition === undefined || volumetricPosition === null || isNaN(volumetricPosition)) {\n      console.warn('Volumetric position is invalid:', volumetricPosition);\n      return furthestX;\n    }\n\n    // Clamp the position to valid range\n    const clampedPosition = Math.max(-totalVolume, Math.min(totalVolume, volumetricPosition));\n\n    // Apply scaling factor to the position calculation\n    const scaledX = furthestX + clampedPosition / totalVolume * (outletX - furthestX);\n\n    // Ensure the returned value is a valid number\n    if (!isFinite(scaledX) || isNaN(scaledX)) {\n      console.warn('Invalid scaled position calculated:', {\n        scaledX,\n        clampedPosition,\n        totalVolume,\n        outletX,\n        furthestX\n      });\n      return furthestX;\n    }\n    return scaledX;\n  }, [graphData.nodes]);\n\n  // Update the updateDropletPositions function\n  const updateDropletPositions = useCallback(timestamp => {\n    if (!isSimulationRunning || dropletHistory.length === 0) return;\n    if (!lastFrameTimeRef.current) {\n      lastFrameTimeRef.current = timestamp;\n      animationFrameRef.current = requestAnimationFrame(updateDropletPositions);\n      return;\n    }\n    const deltaTime = (timestamp - lastFrameTimeRef.current) / 1000; // Convert to seconds\n    const simulationDeltaTime = deltaTime * timeScale;\n    setCurrentTime(prevTime => {\n      const newTime = prevTime + simulationDeltaTime;\n\n      // Get the time range of our history\n      const lastHistoryTime = dropletHistory[dropletHistory.length - 1].time;\n\n      // If we've reached the end, loop back to start\n      if (newTime >= lastHistoryTime) {\n        setCurrentTime(0);\n        return 0;\n      }\n\n      // Find the appropriate states to interpolate between\n      const currentState = interpolateDropletState(newTime);\n      // Update droplet visualization\n      const updatedDroplets = currentState.map(droplet => {\n        const frontX = volumetricToXPosition(droplet.frontVolumetricPosition);\n        const rearX = volumetricToXPosition(droplet.rearVolumetricPosition);\n        if (isNaN(frontX) || isNaN(rearX)) {\n          console.warn('Invalid droplet position calculated:', {\n            dropletId: droplet.id,\n            frontPosition: droplet.frontVolumetricPosition,\n            rearPosition: droplet.rearVolumetricPosition,\n            frontX,\n            rearX\n          });\n          return null;\n        }\n        return {\n          id: droplet.id,\n          frontX,\n          rearX,\n          y: 300,\n          volume: droplet.frontVolumetricPosition - droplet.rearVolumetricPosition,\n          speed: droplet.frontVolumetricSpeed\n        };\n      }).filter(Boolean);\n      setSimulationDroplets(updatedDroplets);\n      return newTime;\n    });\n    lastFrameTimeRef.current = timestamp;\n    animationFrameRef.current = requestAnimationFrame(updateDropletPositions);\n  }, [isSimulationRunning, timeScale, volumetricToXPosition, dropletHistory]);\n\n  // Add animation effect\n  useEffect(() => {\n    if (isSimulationRunning) {\n      lastFrameTimeRef.current = null;\n      animationFrameRef.current = requestAnimationFrame(updateDropletPositions);\n    }\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [isSimulationRunning, updateDropletPositions]);\n\n  // Add this helper function for interpolation\n  const interpolateDropletState = time => {\n    if (!dropletHistory.length) return [];\n\n    // Find the two closest states\n    const index = dropletHistory.findIndex(state => state.time > time);\n    if (index === -1) return dropletHistory[dropletHistory.length - 1].droplets;\n    if (index === 0) return dropletHistory[0].droplets;\n    const beforeState = dropletHistory[index - 1];\n    const afterState = dropletHistory[index];\n    const fraction = (time - beforeState.time) / (afterState.time - beforeState.time);\n    return beforeState.droplets.map(beforeDroplet => {\n      const afterDroplet = afterState.droplets.find(d => d.id === beforeDroplet.id);\n      if (!afterDroplet) return beforeDroplet;\n      return {\n        ...beforeDroplet,\n        frontVolumetricPosition: beforeDroplet.frontVolumetricPosition + (afterDroplet.frontVolumetricPosition - beforeDroplet.frontVolumetricPosition) * fraction,\n        rearVolumetricPosition: beforeDroplet.rearVolumetricPosition + (afterDroplet.rearVolumetricPosition - beforeDroplet.rearVolumetricPosition) * fraction\n      };\n    });\n  };\n\n  // Add navigation functions\n  const jumpToTimepoint = useCallback(index => {\n    if (index >= 0 && index < dropletHistory.length) {\n      setCurrentTimepoint(index);\n      setCurrentTime(dropletHistory[index].time);\n    }\n  }, [dropletHistory]);\n  const nextTimepoint = useCallback(() => {\n    jumpToTimepoint(currentTimepoint + 1);\n  }, [currentTimepoint, jumpToTimepoint]);\n  const previousTimepoint = useCallback(() => {\n    jumpToTimepoint(currentTimepoint - 1);\n  }, [currentTimepoint, jumpToTimepoint]);\n  const handleNodeClick = node => {\n    var _node$data2, _node$data3;\n    console.log('Node clicked:', node);\n    console.log('Node type:', node.type);\n    console.log('Node data type:', (_node$data2 = node.data) === null || _node$data2 === void 0 ? void 0 : _node$data2.type);\n\n    // Check both node.type and node.data.type\n    const nodeType = node.type || ((_node$data3 = node.data) === null || _node$data3 === void 0 ? void 0 : _node$data3.type);\n    console.log('Determined node type:', nodeType);\n    if (nodeType === 'pump' || nodeType === 'USBSpectrometer' || nodeType === 'MQTTSpectrometer') {\n      setSelectedNode(node);\n      console.log('Selected node set:', node.id, nodeType);\n    }\n    if (node.type === 'detector' || node.type === 'USBSpectrometer' || node.type === 'MQTTSpectrometer') {\n      // Store the graph ref when opening a spectrometer\n      const graphRef = /*#__PURE__*/React.createRef();\n      graphRefs.current[node.id] = graphRef;\n\n      // ... rest of the existing handleNodeClick code ...\n    }\n  };\n  const handleNodeAction = action => {\n    console.log('Node action:', action);\n    // Here you would implement the actual device communication\n    // based on the action type and parameters\n  };\n  const togglePumpSpeeds = () => {\n    setDisplayPumpSpeeds(!displayPumpSpeeds);\n  };\n\n  // Toggle functions for each display option\n  const toggleNodeIds = () => {\n    setDisplayNodeIds(!displayNodeIds);\n  };\n  const toggleDropletInfo = () => {\n    setDisplayDropletInfo(!displayDropletInfo);\n  };\n  const toggleDropletGaps = () => {\n    setDisplayDropletGaps(!displayDropletGaps);\n  };\n  const toggleEdgeLabels = () => {\n    setDisplayEdgeLabels(!displayEdgeLabels);\n  };\n  const toggleDisplayMenu = () => {\n    setDisplayMenuOpen(!isDisplayMenuOpen);\n  };\n  const toggleTimelineDropletInfo = () => {\n    setDisplayTimelineDropletInfo(!displayTimelineDropletInfo);\n  };\n\n  // Close menu when clicking outside\n  useEffect(() => {\n    const handleClickOutside = event => {\n      if (displayMenuRef.current && !displayMenuRef.current.contains(event.target)) {\n        setDisplayMenuOpen(false);\n      }\n    };\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => {\n      document.removeEventListener('mousedown', handleClickOutside);\n    };\n  }, []);\n\n  // Function to toggle pump panel visibility\n  const togglePumpPanel = pumpId => {\n    setVisiblePumpPanel(prev => prev === pumpId ? null : pumpId);\n  };\n\n  // Add styles for the display menu\n  const styles = {\n    container: {\n      ...backgroundVariants.mainBackground,\n      padding: '20px',\n      minHeight: '100vh'\n    },\n    dropletInfo: {\n      padding: '8px',\n      borderRadius: '4px',\n      fontSize: '12px',\n      ...backgroundVariants.panelBackground,\n      color: '#fff',\n      minWidth: '150px'\n    },\n    timelineContainer: {\n      display: 'flex',\n      flexDirection: 'column',\n      gap: '10px',\n      marginBottom: '20px'\n    },\n    timeInput: {\n      width: '100px',\n      ...backgroundVariants.inputBackground,\n      padding: '5px',\n      borderRadius: '4px',\n      marginLeft: '8px'\n    },\n    buttonGroup: {\n      display: 'flex',\n      gap: '10px',\n      marginTop: '20px',\n      marginBottom: '20px'\n    },\n    timelineControls: {\n      display: 'flex',\n      flexDirection: 'column',\n      gap: '15px',\n      marginBottom: '20px',\n      ...backgroundVariants.panelBackground,\n      padding: '15px',\n      borderRadius: '4px'\n    },\n    timeControls: {\n      display: 'flex',\n      flexDirection: 'column',\n      gap: '15px'\n    },\n    sliderContainer: {\n      display: 'flex',\n      gap: '10px',\n      alignItems: 'center',\n      borderBottom: '1px solid rgba(255,255,255,0.1)',\n      paddingBottom: '15px'\n    },\n    timeStepButtons: {\n      display: 'flex',\n      gap: '5px',\n      alignItems: 'center',\n      justifyContent: 'flex-start'\n    },\n    timeScaleContainer: {\n      display: 'flex',\n      alignItems: 'center',\n      gap: '15px',\n      justifyContent: 'flex-start',\n      borderTop: '1px solid rgba(255,255,255,0.1)',\n      paddingTop: '15px'\n    },\n    svgContainer: {\n      background: backgroundVariants.panelBackground.background,\n      borderRadius: '4px',\n      padding: '10px'\n    },\n    navigationButtons: {\n      display: 'flex',\n      justifyContent: 'space-between',\n      marginBottom: '20px'\n    },\n    timeSlider: {\n      width: '33%',\n      ...backgroundVariants.inputBackground,\n      height: '20px',\n      borderRadius: '10px',\n      WebkitAppearance: 'none',\n      appearance: 'none',\n      background: backgroundVariants.inputBackground.background,\n      outline: 'none',\n      opacity: '0.7',\n      transition: 'opacity .2s',\n      '&:hover': {\n        opacity: '1'\n      },\n      '&::-webkit-slider-thumb': {\n        WebkitAppearance: 'none',\n        appearance: 'none',\n        width: '20px',\n        height: '20px',\n        background: '#4CAF50',\n        cursor: 'pointer',\n        borderRadius: '50%'\n      },\n      '&::-moz-range-thumb': {\n        width: '20px',\n        height: '20px',\n        background: '#4CAF50',\n        cursor: 'pointer',\n        borderRadius: '50%'\n      }\n    },\n    // Add styles for display menu\n    displayMenuButton: {\n      ...buttonVariants.infoButton,\n      position: 'relative'\n    },\n    displayMenu: {\n      position: 'absolute',\n      top: '100%',\n      right: 0,\n      backgroundColor: '#333',\n      border: '1px solid #555',\n      borderRadius: '4px',\n      padding: '8px 0',\n      zIndex: 1000,\n      width: '220px',\n      boxShadow: '0 2px 10px rgba(0, 0, 0, 0.3)'\n    },\n    menuItem: {\n      padding: '8px 16px',\n      cursor: 'pointer',\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'space-between',\n      color: 'white',\n      transition: 'background-color 0.2s',\n      '&:hover': {\n        backgroundColor: '#444'\n      }\n    },\n    checkmark: {\n      color: '#4CAF50',\n      fontWeight: 'bold'\n    }\n  };\n  const sliderStyle = {\n    width: '100%',\n    height: '10px',\n    borderRadius: '5px',\n    background: '#333',\n    outline: 'none',\n    opacity: '0.7',\n    transition: 'opacity .2s'\n    // Remove all pseudo-element styles that were here\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: styles.container,\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      style: styles.timelineControls,\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        style: styles.timeControls,\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          style: styles.sliderContainer,\n          children: [/*#__PURE__*/_jsxDEV(\"input\", {\n            type: \"range\",\n            min: 0,\n            max: Math.max(0, dropletHistory.length - 1),\n            value: currentTimepoint,\n            onChange: e => jumpToTimepoint(Number(e.target.value)),\n            disabled: isSimulationRunning,\n            style: styles.timeSlider,\n            className: \"time-slider\" // Add this className\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1707,\n            columnNumber: 13\n          }, this), displayTimelineDropletInfo && /*#__PURE__*/_jsxDEV(\"div\", {\n            style: {\n              display: 'flex',\n              gap: '10px',\n              flexWrap: 'wrap'\n            },\n            children: dropletHistory.length > 0 && ((_dropletHistory$curre = dropletHistory[currentTimepoint]) === null || _dropletHistory$curre === void 0 ? void 0 : _dropletHistory$curre.droplets.map((droplet, index) => {\n              var _graphData$nodes$find3, _graphData$nodes$find4;\n              return /*#__PURE__*/_jsxDEV(\"div\", {\n                style: styles.dropletInfo,\n                children: [/*#__PURE__*/_jsxDEV(\"div\", {\n                  children: [\"Droplet \", index + 1, \":\"]\n                }, void 0, true, {\n                  fileName: _jsxFileName,\n                  lineNumber: 1721,\n                  columnNumber: 21\n                }, this), droplet.frontNextNodeID && /*#__PURE__*/_jsxDEV(\"div\", {\n                  children: [\"Front \\u2192 \", ((_graphData$nodes$find3 = graphData.nodes.find(n => n.id === droplet.frontNextNodeID)) === null || _graphData$nodes$find3 === void 0 ? void 0 : _graphData$nodes$find3.label) || droplet.frontNextNodeID]\n                }, void 0, true, {\n                  fileName: _jsxFileName,\n                  lineNumber: 1723,\n                  columnNumber: 23\n                }, this), droplet.rearNextNodeID && /*#__PURE__*/_jsxDEV(\"div\", {\n                  children: [\"Rear \\u2192 \", ((_graphData$nodes$find4 = graphData.nodes.find(n => n.id === droplet.rearNextNodeID)) === null || _graphData$nodes$find4 === void 0 ? void 0 : _graphData$nodes$find4.label) || droplet.rearNextNodeID]\n                }, void 0, true, {\n                  fileName: _jsxFileName,\n                  lineNumber: 1726,\n                  columnNumber: 23\n                }, this)]\n              }, droplet.id, true, {\n                fileName: _jsxFileName,\n                lineNumber: 1720,\n                columnNumber: 19\n              }, this);\n            }))\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1718,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1706,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: styles.timeStepButtons,\n          children: [/*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => jumpToTimepoint(0),\n            disabled: currentTimepoint === 0 || isSimulationRunning,\n            style: {\n              ...buttonVariants.secondaryButton,\n              padding: '4px 8px'\n            },\n            children: \"\\u23EE\\uFE0F Start\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1735,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => jumpToTimepoint(currentTimepoint - 1),\n            disabled: currentTimepoint === 0 || isSimulationRunning,\n            style: {\n              ...buttonVariants.secondaryButton,\n              padding: '4px 8px'\n            },\n            children: \"\\u23EA Previous\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1742,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => jumpToTimepoint(currentTimepoint + 1),\n            disabled: currentTimepoint >= dropletHistory.length - 1 || isSimulationRunning,\n            style: {\n              ...buttonVariants.secondaryButton,\n              padding: '4px 8px'\n            },\n            children: \"Next \\u23E9\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1749,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => jumpToTimepoint(dropletHistory.length - 1),\n            disabled: currentTimepoint >= dropletHistory.length - 1 || isSimulationRunning,\n            style: {\n              ...buttonVariants.secondaryButton,\n              padding: '4px 8px'\n            },\n            children: \"End \\u23ED\\uFE0F\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1756,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1734,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: styles.timeScaleContainer,\n          children: [/*#__PURE__*/_jsxDEV(\"label\", {\n            style: {\n              color: '#fff',\n              marginRight: '10px'\n            },\n            children: [\"Time Scale:\", /*#__PURE__*/_jsxDEV(\"select\", {\n              value: timeScale,\n              onChange: e => setTimeScale(Number(e.target.value)),\n              style: styles.timeInput,\n              children: [/*#__PURE__*/_jsxDEV(\"option\", {\n                value: 0.0625,\n                children: \"1/16x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1773,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 0.25,\n                children: \"1/4x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1774,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 1,\n                children: \"1x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1775,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 4,\n                children: \"4x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1776,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 16,\n                children: \"16x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1777,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 64,\n                children: \"64x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1778,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 256,\n                children: \"256x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1779,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 1024,\n                children: \"1024x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1780,\n                columnNumber: 17\n              }, this)]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 1768,\n              columnNumber: 15\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1766,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"label\", {\n            style: {\n              color: '#fff',\n              marginRight: '10px'\n            },\n            children: [\"Current Time: \", currentTime.toFixed(2), \"s\"]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1783,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"label\", {\n            style: {\n              color: '#fff'\n            },\n            children: [\"Step: \", currentTimepoint + 1, \"/\", dropletHistory.length]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1786,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1765,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1705,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1704,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: styles.buttonGroup,\n      children: [/*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: isSimulationRunning ? stopSimulation : startSimulation,\n        style: {\n          ...buttonVariants.primaryButton\n        },\n        children: isSimulationRunning ? 'Stop Simulation' : 'Start Simulation'\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1794,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: restartSimulation,\n        style: {\n          ...buttonVariants.secondaryButton\n        },\n        children: \"Restart simulation\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1800,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: sendingEventsToDevices,\n        style: {\n          ...buttonVariants.primaryButton\n        },\n        children: \"Send Events to Devices\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1806,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        ref: displayMenuRef,\n        style: {\n          position: 'relative',\n          display: 'inline-block'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: toggleDisplayMenu,\n          style: styles.displayMenuButton,\n          children: \"Display Settings\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1813,\n          columnNumber: 11\n        }, this), isDisplayMenuOpen && /*#__PURE__*/_jsxDEV(\"div\", {\n          style: styles.displayMenu,\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: toggleNodeIds,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Node IDs\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1825,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayNodeIds ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1826,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1821,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: toggleDropletInfo,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Droplet Info\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1832,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayDropletInfo ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1833,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1828,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: toggleDropletGaps,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Droplet Gaps\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1839,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayDropletGaps ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1840,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1835,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: toggleEdgeLabels,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Tube Dimensions\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1846,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayEdgeLabels ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1847,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1842,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: togglePumpSpeeds,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Pump Speeds\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1853,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayPumpSpeeds ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1854,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1849,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: toggleTimelineDropletInfo,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Timeline Droplet Info\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1860,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayTimelineDropletInfo ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1861,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1856,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1820,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1812,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1793,\n      columnNumber: 7\n    }, this), graphData.nodes.length > 0 && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: styles.svgContainer,\n      children: /*#__PURE__*/_jsxDEV(\"svg\", {\n        width: \"2000\",\n        height: \"400\",\n        children: [graphData.links.map((link, index) => {\n          const sourceNode = graphData.nodes.find(node => node.id === link.source);\n          const targetNode = graphData.nodes.find(node => node.id === link.target);\n          if (!sourceNode || !targetNode) return null;\n          const midX = (sourceNode.x + targetNode.x) / 2;\n          const midY = (sourceNode.y + targetNode.y) / 2;\n          return /*#__PURE__*/_jsxDEV(\"g\", {\n            children: [/*#__PURE__*/_jsxDEV(\"line\", {\n              x1: sourceNode.x,\n              y1: sourceNode.y,\n              x2: targetNode.x,\n              y2: targetNode.y,\n              stroke: \"#999\",\n              strokeWidth: 2\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1883,\n              columnNumber: 19\n            }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n              x: midX,\n              y: midY - 20,\n              textAnchor: \"middle\",\n              fill: \"#fff\",\n              fontSize: \"12px\",\n              style: {\n                display: displayEdgeLabels ? 'block' : 'none'\n              },\n              children: `${link.length} mm (Ø ${link.diameter} mm)`\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1891,\n              columnNumber: 19\n            }, this)]\n          }, `edge-${index}`, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1882,\n            columnNumber: 17\n          }, this);\n        }), graphData.nodes.map((node, index) => /*#__PURE__*/_jsxDEV(\"g\", {\n          children: [/*#__PURE__*/_jsxDEV(\"circle\", {\n            cx: node.x,\n            cy: node.y,\n            r: 15,\n            fill: getNodeColor(node),\n            stroke: selectedNode && selectedNode.id === node.id ? '#FFA500' : 'none',\n            strokeWidth: selectedNode && selectedNode.id === node.id ? '3' : '0',\n            onClick: () => handleNodeClick(node),\n            style: {\n              cursor: 'pointer'\n            }\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1908,\n            columnNumber: 17\n          }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n            x: node.x,\n            y: node.y - 25,\n            textAnchor: \"middle\",\n            fill: \"#fff\",\n            fontSize: \"12px\",\n            children: node.label\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1918,\n            columnNumber: 17\n          }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n            x: node.x,\n            y: node.y - 10,\n            textAnchor: \"middle\",\n            fill: \"#fff\",\n            fontSize: \"10px\",\n            style: {\n              display: displayNodeIds ? 'block' : 'none'\n            },\n            children: `ID: ${node.id}`\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1927,\n            columnNumber: 17\n          }, this)]\n        }, `node-${index}`, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1907,\n          columnNumber: 15\n        }, this)), interpolateDropletState(currentTime).map((droplet, index, droplets) => {\n          const frontX = volumetricToXPosition(droplet.frontVolumetricPosition);\n          const rearX = volumetricToXPosition(droplet.rearVolumetricPosition);\n          const centerX = (frontX + rearX) / 2;\n\n          // Calculate distance to next droplet if this isn't the last droplet\n          const distanceInfo = index < droplets.length - 1 ? {\n            nextDropletFront: droplets[index + 1].frontVolumetricPosition,\n            distance: Math.abs(droplets[index + 1].frontVolumetricPosition - droplet.rearVolumetricPosition)\n          } : null;\n\n          // Calculate midpoint for distance label\n          const distanceLabelX = distanceInfo ? (volumetricToXPosition(droplet.rearVolumetricPosition) + volumetricToXPosition(distanceInfo.nextDropletFront)) / 2 : null;\n          return /*#__PURE__*/_jsxDEV(\"g\", {\n            children: [/*#__PURE__*/_jsxDEV(\"line\", {\n              x1: rearX,\n              y1: 300,\n              x2: frontX,\n              y2: 300,\n              stroke: \"rgba(255, 100, 100, 0.9)\",\n              strokeWidth: 8,\n              strokeLinecap: \"butt\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1960,\n              columnNumber: 19\n            }, this), distanceInfo && displayDropletGaps && /*#__PURE__*/_jsxDEV(\"g\", {\n              children: [/*#__PURE__*/_jsxDEV(\"line\", {\n                x1: rearX,\n                y1: 320,\n                x2: volumetricToXPosition(distanceInfo.nextDropletFront),\n                y2: 320,\n                stroke: \"#fff\",\n                strokeWidth: 1,\n                strokeDasharray: \"5,5\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1974,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"line\", {\n                x1: rearX,\n                y1: 315,\n                x2: rearX,\n                y2: 325,\n                stroke: \"#fff\",\n                strokeWidth: 1\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1984,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"line\", {\n                x1: volumetricToXPosition(distanceInfo.nextDropletFront),\n                y1: 315,\n                x2: volumetricToXPosition(distanceInfo.nextDropletFront),\n                y2: 325,\n                stroke: \"#666\",\n                strokeWidth: 1\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1992,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                x: distanceLabelX,\n                y: 335,\n                textAnchor: \"middle\",\n                fill: \"#666\",\n                fontSize: \"12px\",\n                children: `${distanceInfo.distance.toFixed(2)} μL`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2001,\n                columnNumber: 23\n              }, this)]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 1972,\n              columnNumber: 21\n            }, this), displayDropletInfo && /*#__PURE__*/_jsxDEV(_Fragment, {\n              children: [/*#__PURE__*/_jsxDEV(\"text\", {\n                x: centerX,\n                y: 270,\n                textAnchor: \"middle\",\n                fill: \"#6f6\",\n                fontSize: \"12px\",\n                children: `Vol: ${(droplet.frontVolumetricPosition - droplet.rearVolumetricPosition).toFixed(2)} μL`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2016,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                x: centerX,\n                y: 255,\n                textAnchor: \"middle\",\n                fill: \"#6f6\",\n                fontSize: \"12px\",\n                children: `Spd f: ${droplet.frontVolumetricSpeed.toFixed(2)} μL/s`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2025,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                x: centerX,\n                y: 240,\n                textAnchor: \"middle\",\n                fill: \"#6f6\",\n                fontSize: \"12px\",\n                children: `Spd r: ${droplet.rearVolumetricSpeed.toFixed(2)} μL/s`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2034,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                x: centerX,\n                y: 225,\n                textAnchor: \"middle\",\n                fill: \"#6f6\",\n                fontSize: \"12px\",\n                children: `mlt: ${droplet.pumpSpeedMultiplier.toFixed(2)}`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2043,\n                columnNumber: 23\n              }, this)]\n            }, void 0, true)]\n          }, `droplet-${droplet.id}`, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1958,\n            columnNumber: 17\n          }, this);\n        }), displayPumpSpeeds && graphData.nodes.map((node, index) => {\n          if (node.type === 'pump') {\n            var _dropletHistory;\n            const currentSpeed = getPumpSpeedAtTime(node.id, pumpEvents, currentTime);\n            const maxTime = ((_dropletHistory = dropletHistory[dropletHistory.length - 1]) === null || _dropletHistory === void 0 ? void 0 : _dropletHistory.time) || 1;\n            const pumpSpecificEvents = pumpEvents.filter(event => event.target === node.id);\n            return /*#__PURE__*/_jsxDEV(\"g\", {\n              children: [/*#__PURE__*/_jsxDEV(\"text\", {\n                x: node.x,\n                y: node.y - 35,\n                textAnchor: \"middle\",\n                fill: \"#4CAF50\",\n                fontSize: \"12px\",\n                children: `${currentSpeed.toFixed(2)} μL/s`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2067,\n                columnNumber: 21\n              }, this), /*#__PURE__*/_jsxDEV(\"g\", {\n                transform: `translate(${node.x - 40}, ${node.y - 65})`,\n                children: [pumpSpecificEvents.map((event, i, arr) => {\n                  const nextEvent = arr[i + 1];\n                  const width = 80;\n                  const x = 0;\n                  const y = 0;\n\n                  // Calculate position based on time\n                  const timePosition = event.time / maxTime * width;\n                  const nextTimePosition = nextEvent ? nextEvent.time / maxTime * width : width;\n\n                  // Calculate height based on speed value (normalized)\n                  const maxSpeed = Math.max(...pumpSpecificEvents.map(e => e.value));\n                  const normalizedHeight = event.value / (maxSpeed || 1) * 20;\n                  return /*#__PURE__*/_jsxDEV(\"g\", {\n                    children: [/*#__PURE__*/_jsxDEV(\"line\", {\n                      x1: x + timePosition,\n                      y1: y - normalizedHeight,\n                      x2: x + nextTimePosition,\n                      y2: y - normalizedHeight,\n                      stroke: \"#4CAF50\",\n                      strokeWidth: 2\n                    }, void 0, false, {\n                      fileName: _jsxFileName,\n                      lineNumber: 2098,\n                      columnNumber: 29\n                    }, this), /*#__PURE__*/_jsxDEV(\"circle\", {\n                      cx: x + timePosition,\n                      cy: y - normalizedHeight,\n                      r: 2,\n                      fill: \"#4CAF50\"\n                    }, void 0, false, {\n                      fileName: _jsxFileName,\n                      lineNumber: 2107,\n                      columnNumber: 29\n                    }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                      x: x + timePosition,\n                      y: y + 12,\n                      textAnchor: \"middle\",\n                      fill: \"#666\",\n                      fontSize: \"10px\",\n                      children: [event.time.toFixed(1), \"s\"]\n                    }, void 0, true, {\n                      fileName: _jsxFileName,\n                      lineNumber: 2114,\n                      columnNumber: 29\n                    }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                      x: x + timePosition,\n                      y: y - normalizedHeight - 5,\n                      textAnchor: \"middle\",\n                      fill: \"#4CAF50\",\n                      fontSize: \"8px\",\n                      children: event.value.toFixed(1)\n                    }, void 0, false, {\n                      fileName: _jsxFileName,\n                      lineNumber: 2124,\n                      columnNumber: 29\n                    }, this)]\n                  }, `pump-event-${i}`, true, {\n                    fileName: _jsxFileName,\n                    lineNumber: 2096,\n                    columnNumber: 27\n                  }, this);\n                }), /*#__PURE__*/_jsxDEV(\"line\", {\n                  x1: currentTime / maxTime * 80,\n                  y1: -25,\n                  x2: currentTime / maxTime * 80,\n                  y2: 15,\n                  stroke: \"red\",\n                  strokeWidth: 1,\n                  strokeDasharray: \"2,2\"\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 2137,\n                  columnNumber: 23\n                }, this)]\n              }, void 0, true, {\n                fileName: _jsxFileName,\n                lineNumber: 2078,\n                columnNumber: 21\n              }, this)]\n            }, `pump-speed-${node.id}`, true, {\n              fileName: _jsxFileName,\n              lineNumber: 2065,\n              columnNumber: 19\n            }, this);\n          }\n          return null;\n        })]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1871,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1870,\n      columnNumber: 9\n    }, this), selectedNode && (selectedNode.type === 'pump' || ((_selectedNode$data = selectedNode.data) === null || _selectedNode$data === void 0 ? void 0 : _selectedNode$data.type) === 'pump') && /*#__PURE__*/_jsxDEV(DraggablePanel, {\n      initialPosition: pumpPanelPosition,\n      title: `Pump Controls - ${selectedNode.label || selectedNode.id}`,\n      children: /*#__PURE__*/_jsxDEV(PumpActions, {\n        node: selectedNode,\n        nodes: nodes,\n        edges: edges,\n        onAction: handleNodeAction\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 2161,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 2157,\n      columnNumber: 9\n    }, this), selectedNode && (selectedNode.type === 'USBSpectrometer' || ((_selectedNode$data2 = selectedNode.data) === null || _selectedNode$data2 === void 0 ? void 0 : _selectedNode$data2.type) === 'USBSpectrometer') && /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [console.log('Rendering USBSpectrometer component for node:', selectedNode), /*#__PURE__*/_jsxDEV(USBSpectrometer, {\n        detector: selectedNode,\n        detectorId: selectedNode.id,\n        detectorName: selectedNode.label || selectedNode.id,\n        onClose: () => setSelectedNode(null),\n        initialPosition: {\n          x: 150,\n          y: 100\n        },\n        isVisible: true\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 2172,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true), selectedNode && (selectedNode.type === 'MQTTSpectrometer' || ((_selectedNode$data3 = selectedNode.data) === null || _selectedNode$data3 === void 0 ? void 0 : _selectedNode$data3.type) === 'MQTTSpectrometer') && /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [console.log('Rendering SpectrometerMQTT component for node:', selectedNode), /*#__PURE__*/_jsxDEV(SpectrometerMQTT, {\n        detector: selectedNode,\n        detectorId: selectedNode.id,\n        detectorName: selectedNode.label || selectedNode.id,\n        onClose: () => setSelectedNode(null),\n        initialPosition: {\n          x: 150,\n          y: 100\n        },\n        isVisible: true\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 2185,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true), /*#__PURE__*/_jsxDEV(\"style\", {\n      children: `\n          .node-actions {\n            position: fixed;\n            top: 20px;\n            right: 20px;\n            background: black;\n            padding: 20px;\n            border: 1px solid #ccc;\n            border-radius: 5px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n          }\n          .node-actions h3 {\n            margin: 0 0 15px 0;\n            color: #333;\n          }\n          .node-actions button {\n            margin: 5px;\n            padding: 8px 16px;\n            background: #4CAF50;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n          }\n          .node-actions button:disabled {\n            background: #ccc;\n            cursor: not-allowed;\n          }\n          .node-actions input {\n            margin: 5px;\n            padding: 8px;\n            border: 1px solid #ccc;\n            border-radius: 4px;\n            width: 80px;\n          }\n          .move-controls {\n            display: flex;\n            flex-direction: column;\n            gap: 10px;\n            margin-top: 10px;\n          }\n          .input-group {\n            display: flex;\n            align-items: center;\n            gap: 10px;\n          }\n          .input-group label {\n            min-width: 100px;\n            text-align: right;\n            color: #666;\n          }\n        `\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 2196,\n      columnNumber: 7\n    }, this), overlayComponent && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: 'fixed',\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0,\n        zIndex: 9999,\n        pointerEvents: 'none'\n      },\n      children: /*#__PURE__*/_jsxDEV(Suspense, {\n        fallback: /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            position: 'fixed',\n            top: '50%',\n            left: '50%',\n            transform: 'translate(-50%, -50%)',\n            background: 'rgba(0,0,0,0.8)',\n            padding: '20px',\n            borderRadius: '8px',\n            color: 'white',\n            pointerEvents: 'auto'\n          },\n          children: /*#__PURE__*/_jsxDEV(\"h2\", {\n            children: \"Loading Component...\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 2272,\n            columnNumber: 15\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2261,\n          columnNumber: 13\n        }, this),\n        children: [overlayComponent.type === 'USBSpectrometer' && /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            pointerEvents: 'auto'\n          },\n          children: /*#__PURE__*/_jsxDEV(USBSpectrometer, {\n            ...overlayComponent.props\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 2277,\n            columnNumber: 17\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2276,\n          columnNumber: 15\n        }, this), overlayComponent.type === 'MQTTSpectrometer' && /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            pointerEvents: 'auto'\n          },\n          children: /*#__PURE__*/_jsxDEV(SpectrometerMQTT, {\n            ...overlayComponent.props,\n            graphRef: graphRefs.current[overlayComponent.props.detector.id]\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 2282,\n            columnNumber: 17\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2281,\n          columnNumber: 15\n        }, this), overlayComponent.type === 'PumpPanel' && /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            pointerEvents: 'auto'\n          },\n          children: /*#__PURE__*/_jsxDEV(PumpPanel, {\n            ...overlayComponent.props\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 2290,\n            columnNumber: 17\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2289,\n          columnNumber: 15\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 2260,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 2251,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 1703,\n    columnNumber: 5\n  }, this);\n};\n_s(Simulation, \"vBdwhyDZIsL51XkWtf+fUNpjTb4=\", false, function () {\n  return [useButtonStyles];\n});\n_c = Simulation;\nexport default Simulation;\nvar _c;\n$RefreshReg$(_c, \"Simulation\");","map":{"version":3,"names":["React","useState","useEffect","useCallback","useRef","Suspense","ReactFlowProvider","useNodesState","useEdgesState","PumpActions","DraggablePanel","convertToHardwareValuesPump","useButtonStyles","backgroundVariants","findOutletNode","findFurthestNode","orderNodesByDistance","calculateEdgeVolume","getVolumeBetweenNodes","findConnectedPump","getPumpSpeed","getPumpsBetweenPositions","cleanAndSortEventList","getPumpSpeedAtTime","sendEventsToDevices","setOfMainLineNodes","setOfSecondaryLineNodes","SvgDefs","calculateEdgePoints","createLabels","USBSpectrometer","SpectrometerMQTT","PumpPanel","jsxDEV","_jsxDEV","Fragment","_Fragment","Simulation","nodes","edges","droplets","selectedCarrierPumps","onBack","onNext","_s","_dropletHistory$curre","_selectedNode$data","_selectedNode$data2","_selectedNode$data3","buttonVariants","graphData","setGraphData","links","simulationDroplets","setSimulationDroplets","isSimulationRunning","setIsSimulationRunning","key","setKey","currentTime","setCurrentTime","timeScale","setTimeScale","animationFrameRef","lastFrameTimeRef","currentBlockDroplets","setCurrentBlockDroplets","dropletHistory","setDropletHistory","currentTimepoint","setCurrentTimepoint","pumpEvents","setPumpEvents","displayPumpSpeeds","setDisplayPumpSpeeds","displayNodeIds","setDisplayNodeIds","displayDropletInfo","setDisplayDropletInfo","displayDropletGaps","setDisplayDropletGaps","displayEdgeLabels","setDisplayEdgeLabels","isDisplayMenuOpen","setDisplayMenuOpen","displayTimelineDropletInfo","setDisplayTimelineDropletInfo","displayMenuRef","selectedNode","setSelectedNode","ws","setWs","pumpPanelPosition","setPumpPanelPosition","x","window","innerWidth","y","visiblePumpPanel","setVisiblePumpPanel","isSendingEvents","setIsSendingEvents","graphRefs","overlayComponent","setOverlayComponent","console","log","length","map","node","_node$data","id","type","dataType","data","websocket","WebSocket","onopen","onerror","error","close","sendingEventsToDevices","generateEventList","Object","values","current","forEach","graphRef","addToMemory","eventType","calculateVolumesBetweenThermostats","outletNode","visited","Set","queue","thermostatVolumes","currentNodeId","accumulatedVolume","thermostatPath","shift","currentNode","find","n","has","add","updatedPath","push","startThermostatId","endThermostatId","volume","connectedEdges","filter","link","source","target","edge","nextNodeId","nextNode","edgeVolume","divideDropletsIntoBlocks","thermostatId","totalVolume","reduce","acc","droplet","actualVolume","temperature","time","furthestNode","volumeToFurthestNode","blocks","currentBlock","finalizeBlock","lastDroplet","surfixParam","parameters","p","name","value","Math","max","i","_droplet$parameters$f","_droplet$parameters$f2","_droplet$parameters$f3","_droplet$parameters$f4","_droplet$parameters$f5","relevantVolume","tv","dropletVolume","printDropletFrontPositionsAndSpeeds","frontVolumetricPosition","frontTimeToReachNextNode","frontVolumetricDistanceToNextNode","rearVolumetricPosition","rearTimeToReachNextNode","rearVolumetricDistanceToNextNode","frontNextNodeID","rearNextNodeID","extractPumpEvents","eventList","flat","event","sort","a","b","recalculateEventListForDevices","deviceEventMap","Map","convertPumpEvent","deviceProperties","_deviceProperties$fin","_deviceProperties$fin2","_deviceProperties$fin3","_deviceProperties$fin4","syringeDiameter","default","syringeLength","stepsPerRevolution","lead","syringeArea","PI","pow","linearSpeed","abs","stepsPerMm","stepsPerSecond","delayMicroseconds","round","delay","convertThermostatEvent","convertLedEvent","intensity","convertDetectorEvent","setting","deviceEventList","targetId","deviceNode","deviceEvents","properties","warn","Boolean","set","Array","from","isArray","orderedNodes","dropletSnapshot","dropletWithParams","d","volumetricSpeedParam","commonVolumetricSpeed","inletVolumetricSpeed","outletVolumetricSpeed","pump","connectedPump","connectedPumpRatio","connectedPumpSpeedAtPause","pumpSpeedMultiplier","pauseLevel","carrierPumpConnector","connectorNode","position","_droplet$parameters$f6","_droplet$parameters$f7","prefixVolume","surfixVolume","frontVolumetricSpeed","rearVolumetricSpeed","frontVolumetricSpeedAtPause","rearVolumetricSpeedAtPause","stoppingDroplet","initialPumping","lastDropletRearPosition","outletNodePosition","volumetricPosition","timePassed","newTimePassed","smallestFrontTime","Infinity","smallestRearTime","smallestFrontTimeDroplet","smallestRearTimeDroplet","min","reachedNode","reachedNodeDistance","distance","index","indexOf","dropletsOlder","slice","dropletsNewer","ds","drops","JSON","parse","stringify","snappedNode","existingSnapshotIndex","findIndex","snapshot","nextEdge","_smallestFrontTimeDro","_smallestFrontTimeDro2","pumpRatio","param","nodeId","dropletDesiredVolume","_smallestFrontTimeDro3","_smallestFrontTimeDro4","rearTimeLeft","totalTimeLeft","thispumpspeed","accumulatedSpeed","reverse","editedNode","pumpBoost","speedDifference","accumulatedSpeedDecrease","pumpBreak","isFarthestThermostatOrLED","every","_smallestRearTimeDrop","waitTime","carrierPumpEvent","dropletState","_droplet$parameters$f8","prev","graphNodes","label","graphLinks","_edge$data","_edge$data$properties","_edge$data2","_edge$data2$propertie","diameter","nodesLength","linksLength","dropletsLength","mainLineNodes","includes","secondaryLineNodes","mainLineY","secondaryLineY","pumpSpacing","currentX","currentVolumetricPosition","graphNode","e","nodesByDistance","pumpOffset","entries","connectedEdge","connectedNodeId","connectedMainNode","thermoVol","dropletsCopy","eventListForDevices","startSimulation","stopSimulation","cancelAnimationFrame","restartSimulation","prevKey","getNodeColor","volumetricToXPosition","_graphData$nodes$find","_graphData$nodes$find2","outletX","furthestX","isNaN","undefined","clampedPosition","scaledX","isFinite","updateDropletPositions","timestamp","requestAnimationFrame","deltaTime","simulationDeltaTime","prevTime","newTime","lastHistoryTime","currentState","interpolateDropletState","updatedDroplets","frontX","rearX","dropletId","frontPosition","rearPosition","speed","state","beforeState","afterState","fraction","beforeDroplet","afterDroplet","jumpToTimepoint","nextTimepoint","previousTimepoint","handleNodeClick","_node$data2","_node$data3","nodeType","createRef","handleNodeAction","action","togglePumpSpeeds","toggleNodeIds","toggleDropletInfo","toggleDropletGaps","toggleEdgeLabels","toggleDisplayMenu","toggleTimelineDropletInfo","handleClickOutside","contains","document","addEventListener","removeEventListener","togglePumpPanel","pumpId","styles","container","mainBackground","padding","minHeight","dropletInfo","borderRadius","fontSize","panelBackground","color","minWidth","timelineContainer","display","flexDirection","gap","marginBottom","timeInput","width","inputBackground","marginLeft","buttonGroup","marginTop","timelineControls","timeControls","sliderContainer","alignItems","borderBottom","paddingBottom","timeStepButtons","justifyContent","timeScaleContainer","borderTop","paddingTop","svgContainer","background","navigationButtons","timeSlider","height","WebkitAppearance","appearance","outline","opacity","transition","cursor","displayMenuButton","infoButton","displayMenu","top","right","backgroundColor","border","zIndex","boxShadow","menuItem","checkmark","fontWeight","sliderStyle","style","children","onChange","Number","disabled","className","fileName","_jsxFileName","lineNumber","columnNumber","flexWrap","_graphData$nodes$find3","_graphData$nodes$find4","onClick","secondaryButton","marginRight","toFixed","primaryButton","ref","sourceNode","targetNode","midX","midY","x1","y1","x2","y2","stroke","strokeWidth","textAnchor","fill","cx","cy","r","centerX","distanceInfo","nextDropletFront","distanceLabelX","strokeLinecap","strokeDasharray","_dropletHistory","currentSpeed","maxTime","pumpSpecificEvents","transform","arr","nextEvent","timePosition","nextTimePosition","maxSpeed","normalizedHeight","initialPosition","title","onAction","detector","detectorId","detectorName","onClose","isVisible","left","bottom","pointerEvents","fallback","props","_c","$RefreshReg$"],"sources":["E:/flow chemistry/fluidicGUI/frontend/fluidicgui/src/components/Simulation/Simulation.js"],"sourcesContent":["import React, { useState, useEffect, useCallback, useRef, Suspense } from 'react';\r\nimport { ReactFlowProvider, useNodesState, useEdgesState } from 'react-flow-renderer';\r\nimport PumpActions from './NodeActions/PumpActions';\r\nimport DraggablePanel from './DraggablePanel';\r\nimport { convertToHardwareValuesPump } from '../../utils/pumpCalculations';\r\nimport { useButtonStyles } from '../../styles/ButtonStyleProvider';\r\nimport { backgroundVariants } from '../../styles/backgroundStyles';\r\nimport {\r\n  findOutletNode,\r\n  findFurthestNode,\r\n  orderNodesByDistance,\r\n  calculateEdgeVolume,\r\n  getVolumeBetweenNodes,\r\n  findConnectedPump,\r\n  getPumpSpeed,\r\n  getPumpsBetweenPositions,\r\n  cleanAndSortEventList,\r\n  getPumpSpeedAtTime,\r\n  sendEventsToDevices,\r\n  setOfMainLineNodes,\r\n  setOfSecondaryLineNodes\r\n} from '../../utils/simulationUtils';\r\nimport './simulation.css'; // We'll create this CSS file\r\nimport SvgDefs from './SvgDefs';\r\nimport { calculateEdgePoints, createLabels } from '../../utils/flowchartUtils';\r\nimport USBSpectrometer from './USBSpectrometer';\r\nimport SpectrometerMQTT from './SpectrometerMQTT';\r\nimport PumpPanel from './PumpPanel';\r\n\r\nconst Simulation = ({ nodes = [], edges = [], droplets = [], selectedCarrierPumps = [], onBack, onNext }) => {\r\n  const buttonVariants = useButtonStyles();\r\n  const [graphData, setGraphData] = useState({ nodes: [], links: [] });\r\n  const [simulationDroplets, setSimulationDroplets] = useState([]);\r\n  const [isSimulationRunning, setIsSimulationRunning] = useState(false);\r\n  const [key, setKey] = useState(0);\r\n  const [currentTime, setCurrentTime] = useState(0);\r\n  const [timeScale, setTimeScale] = useState(1); // Default 1x speed\r\n  const animationFrameRef = useRef();\r\n  const lastFrameTimeRef = useRef();\r\n  const [currentBlockDroplets, setCurrentBlockDroplets] = useState([]);\r\n  const [dropletHistory, setDropletHistory] = useState([]);\r\n  const [currentTimepoint, setCurrentTimepoint] = useState(0);\r\n  const [pumpEvents, setPumpEvents] = useState([]);\r\n  const [displayPumpSpeeds, setDisplayPumpSpeeds] = useState(false);\r\n  const [displayNodeIds, setDisplayNodeIds] = useState(false);\r\n  const [displayDropletInfo, setDisplayDropletInfo] = useState(false);\r\n  const [displayDropletGaps, setDisplayDropletGaps] = useState(true);\r\n  const [displayEdgeLabels, setDisplayEdgeLabels] = useState(false);\r\n  const [isDisplayMenuOpen, setDisplayMenuOpen] = useState(false);\r\n  const [displayTimelineDropletInfo, setDisplayTimelineDropletInfo] = useState(false);\r\n  const displayMenuRef = useRef(null);\r\n  const [selectedNode, setSelectedNode] = useState(null);\r\n  const [ws, setWs] = useState(null);\r\n  const [pumpPanelPosition, setPumpPanelPosition] = useState({ x: window.innerWidth - 300, y: 100 });\r\n  const [visiblePumpPanel, setVisiblePumpPanel] = useState(null);\r\n  const [isSendingEvents, setIsSendingEvents] = useState(false);\r\n  const graphRefs = useRef({});\r\n  const [overlayComponent, setOverlayComponent] = useState(null);\r\n\r\n  // Add at the beginning of the component, after the state initialization\r\n  useEffect(() => {\r\n    // Log all nodes and their types for debugging\r\n    console.log('All nodes:', nodes);\r\n    if (nodes && nodes.length > 0) {\r\n      console.log('Node types in simulation:', nodes.map(node => ({\r\n        id: node.id,\r\n        type: node.type,\r\n        dataType: node.data?.type\r\n      })));\r\n    }\r\n  }, [nodes]);\r\n\r\n  useEffect(() => {\r\n    // Create WebSocket connection\r\n    const websocket = new WebSocket('ws://localhost:4000');\r\n    \r\n    websocket.onopen = () => {\r\n      console.log('Connected to WebSocket server');\r\n    };\r\n\r\n    websocket.onerror = (error) => {\r\n      console.error('WebSocket error:', error);\r\n    };\r\n\r\n    setWs(websocket);\r\n\r\n    // Cleanup on unmount\r\n    return () => {\r\n      if (websocket) {\r\n        websocket.close();\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  const sendingEventsToDevices = () => {\r\n    setIsSendingEvents(true);\r\n    sendEventsToDevices(pumpEvents, ws, nodes);\r\n    // Reset simulation state\r\n    setCurrentTime(0);\r\n    setCurrentTimepoint(0);\r\n    setIsSimulationRunning(true);\r\n    setDropletHistory([]);\r\n    // Generate new event list\r\n    generateEventList([{ droplets: droplets }]);\r\n  };\r\n\r\n  // Add effect to handle automatic memory addition when events are being sent\r\n  useEffect(() => {\r\n    if (isSendingEvents) {\r\n      // Get all graph refs and add data to memory\r\n      Object.values(graphRefs.current).forEach(graphRef => {\r\n        if (graphRef && graphRef.current && graphRef.current.addToMemory) {\r\n          graphRef.current.addToMemory();\r\n        }\r\n      });\r\n    }\r\n  }, [isSendingEvents]);\r\n\r\n  const eventType = ['setPumpSpeed', 'setThermostatTemperature', 'setLedIntensity', 'wait', 'blockEnd'];\r\n\r\n  const calculateVolumesBetweenThermostats = (graphData) => {\r\n  \r\n    // Find outlet node first\r\n    const outletNode = findOutletNode(graphData.nodes);\r\n  \r\n    const visited = new Set();\r\n    const queue = [[outletNode.id, 0, []]]; // [nodeId, accumulated volume, path of thermostats]\r\n    const thermostatVolumes = [];\r\n  \r\n    while (queue.length > 0) {\r\n      let [currentNodeId, accumulatedVolume, thermostatPath] = queue.shift();\r\n      const currentNode = graphData.nodes.find(n => n.id === currentNodeId);\r\n  \r\n      if (!currentNode) continue;\r\n      \r\n      // Track all visited nodes to prevent infinite loops\r\n      if (visited.has(currentNodeId)) continue;\r\n      visited.add(currentNodeId);\r\n  \r\n      // If we found a thermostat, add it to the path\r\n      let updatedPath = [...thermostatPath];\r\n      if (currentNode.type === 'thermostat') {\r\n        if (thermostatPath.length > 0) {\r\n          thermostatVolumes.push({\r\n            startThermostatId: thermostatPath[thermostatPath.length - 1],\r\n            endThermostatId: currentNodeId,\r\n            volume: accumulatedVolume\r\n          });\r\n        }\r\n        updatedPath.push(currentNodeId);\r\n        // Reset accumulated volume after finding a thermostat\r\n        accumulatedVolume = 0;\r\n      }\r\n  \r\n      // Find all connected edges and nodes\r\n      const connectedEdges = graphData.links.filter(link => \r\n        link.source === currentNodeId || link.target === currentNodeId\r\n      );\r\n  \r\n      for (const edge of connectedEdges) {\r\n        const nextNodeId = edge.source === currentNodeId ? edge.target : edge.source;\r\n        const nextNode = graphData.nodes.find(n => n.id === nextNodeId);\r\n        \r\n        // Skip paths to pumps\r\n        if (nextNode && nextNode.type !== 'pump') {\r\n          const edgeVolume = calculateEdgeVolume(edge);\r\n          queue.push([nextNodeId, accumulatedVolume + edgeVolume, updatedPath]);\r\n        }\r\n      }\r\n    }\r\n  \r\n    return thermostatVolumes;\r\n  };\r\n//add something to handle lack of thermostat\r\n  const divideDropletsIntoBlocks = (droplets, thermostatVolumes) => {\r\n\r\n    if (thermostatVolumes.length === 0) {\r\n      return [{\r\n        droplets: droplets,\r\n        thermostatId: null,\r\n        totalVolume: droplets.reduce((acc, droplet) => acc + droplet.actualVolume, 0),\r\n        temperature: null,\r\n        time: null\r\n      }];\r\n    }\r\n\r\n    const furthestNode = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links);\r\n\r\n    const volumeToFurthestNode = getVolumeBetweenNodes(thermostatVolumes[0].endThermostatId, furthestNode.id, graphData.nodes, graphData.links);\r\n    \r\n    if (!droplets.length || !thermostatVolumes.length) return [];\r\n\r\n    const blocks = [];\r\n    let currentBlock = {\r\n      droplets: [],\r\n      thermostatId: thermostatVolumes[0].endThermostatId,\r\n      totalVolume: 0,\r\n      temperature: null,\r\n      time: null\r\n    };\r\n\r\n    // Helper to finalize a block and start a new one\r\n    const finalizeBlock = (thermostatId, temperature, time) => {\r\n      if (currentBlock.droplets.length > 0) {\r\n        // Add volumeToFurthestNode to the surfixVolume of the last droplet in the block\r\n        const lastDroplet = currentBlock.droplets[currentBlock.droplets.length - 1];\r\n        const surfixParam = lastDroplet.parameters.find(p => p.name === 'surfixVolume');\r\n        if (surfixParam) {\r\n          surfixParam.value = Math.max(volumeToFurthestNode, surfixParam.value);\r\n        } else {\r\n          lastDroplet.parameters.push({\r\n            name: 'surfixVolume',\r\n            value: volumeToFurthestNode\r\n          });\r\n        }\r\n        \r\n        blocks.push({ ...currentBlock });\r\n      }\r\n      currentBlock = {\r\n        droplets: [],\r\n        thermostatId: thermostatId,\r\n        totalVolume: 0,\r\n        temperature: temperature,\r\n        time: time\r\n      };\r\n    };\r\n\r\n    // Process droplets in order\r\n    for (let i = 0; i < droplets.length; i++) {\r\n      const droplet = droplets[i];\r\n      const temperature = droplet.parameters.find(p => p.name === 'temperature')?.value;\r\n      const time = droplet.parameters.find(p => p.name === 'time')?.value;\r\n\r\n      // Start new block if temperature or time changes, or if volume limit exceeded\r\n      const relevantVolume = thermostatVolumes.find(tv => \r\n        tv.startThermostatId === currentBlock.thermostatId || \r\n        tv.endThermostatId === currentBlock.thermostatId\r\n      );\r\n\r\n      let dropletVolume = droplet.parameters.find(p => p.name === 'volume')?.value;\r\n      dropletVolume += droplet.parameters.find(p => p.name === 'prefixVolume')?.value;\r\n      \r\n\r\n      if (\r\n        currentBlock.temperature !== temperature ||\r\n        currentBlock.time !== time ||\r\n        (relevantVolume && currentBlock.totalVolume + dropletVolume > relevantVolume.volume)\r\n      ) {\r\n        finalizeBlock(thermostatVolumes[0].endThermostatId, temperature, time);\r\n      }\r\n      dropletVolume += droplet.parameters.find(p => p.name === 'surfixVolume')?.value;\r\n      // Add droplet to current block\r\n      currentBlock.droplets.push(droplet);\r\n      currentBlock.totalVolume += dropletVolume;\r\n      currentBlock.temperature = temperature;\r\n      currentBlock.time = time;\r\n    }\r\n\r\n    // Finalize last block\r\n    finalizeBlock(null, null, null);\r\n\r\n    return blocks;\r\n  };\r\n\r\n  function printDropletFrontPositionsAndSpeeds(droplets) {\r\n    droplets.forEach(droplet => {\r\n      console.log(`Droplet ID: ${droplet.id}, Front Volumetric Position: ${droplet.frontVolumetricPosition}, Front time to next node  : ${droplet.frontTimeToReachNextNode}, Front Volumetric Distance to next node: ${droplet.frontVolumetricDistanceToNextNode}, Rear Volumetric Position: ${droplet.rearVolumetricPosition}, Rear time to next node: ${droplet.rearTimeToReachNextNode}, Rear Volumetric Distance to next node: ${droplet.rearVolumetricDistanceToNextNode}, frontNextNodeID: ${droplet.frontNextNodeID}, rearNextNodeID: ${droplet.rearNextNodeID}`);\r\n    });\r\n  }\r\n\r\n  const extractPumpEvents = (eventList) => {\r\n    // eventList is now an array of arrays, where each inner array contains events for a specific pump\r\n    return eventList\r\n      .flat() // Flatten the array of arrays\r\n      .filter(event => event.type === 'setPumpSpeed')\r\n      .sort((a, b) => a.time - b.time);\r\n  };\r\n\r\n  const recalculateEventListForDevices = (eventList) => {\r\n    const deviceEventMap = new Map();\r\n\r\n    const convertPumpEvent = (event, deviceProperties) => {\r\n      // Find properties by name from the properties array\r\n      const syringeDiameter = deviceProperties.find(p => p.name === 'diameter')?.default || 0;\r\n      const syringeLength = deviceProperties.find(p => p.name === 'length')?.default || 0;\r\n      const stepsPerRevolution = deviceProperties.find(p => p.name === 'steps per revolution')?.default || 0;\r\n      const lead = deviceProperties.find(p => p.name === 'lead')?.default || 0;\r\n\r\n      const syringeArea = Math.PI * Math.pow(syringeDiameter / 2, 2);\r\n      const linearSpeed = Math.abs(event.value) / syringeArea;\r\n      const stepsPerMm = stepsPerRevolution / lead;\r\n      const stepsPerSecond = linearSpeed * stepsPerMm;\r\n      const delayMicroseconds = stepsPerSecond > 0 ? \r\n        Math.round(1000000 / stepsPerSecond) : \r\n        0;\r\n\r\n      return {\r\n        target: event.target,\r\n        time: Math.round(event.time * 1000000),\r\n        delay: delayMicroseconds\r\n      };\r\n    };\r\n\r\n    const convertThermostatEvent = (event, deviceProperties) => {\r\n      // Placeholder for thermostat conversion logic\r\n      return {\r\n        target: event.target,\r\n        time: Math.round(event.time * 1000000),\r\n        temperature: event.value,\r\n        // Add other thermostat-specific parameters here\r\n      };\r\n    };\r\n\r\n    const convertLedEvent = (event, deviceProperties) => {\r\n      // Placeholder for LED conversion logic\r\n      return {\r\n        target: event.target,\r\n        time: Math.round(event.time * 1000000),\r\n        intensity: event.value,\r\n        // Add other LED-specific parameters here\r\n      };\r\n    };\r\n\r\n    const convertDetectorEvent = (event, deviceProperties) => {\r\n      // Placeholder for detector conversion logic\r\n      return {\r\n        target: event.target,\r\n        time: Math.round(event.time * 1000000),\r\n        setting: event.value,\r\n        // Add other detector-specific parameters here\r\n      };\r\n    };\r\n\r\n    eventList.forEach(deviceEventList => {\r\n      if (!deviceEventList.length) return;\r\n\r\n      const targetId = deviceEventList[0].target;\r\n      const deviceNode = nodes.find(node => node.id === targetId);\r\n      \r\n      if (!deviceNode || !deviceNode.data) {\r\n        console.error(`Device node or data not found for ID: ${targetId}`);\r\n        return;\r\n      }\r\n\r\n      const deviceEvents = deviceEventList.map(event => {\r\n        switch (event.type) {\r\n          case 'setPumpSpeed':\r\n            return convertPumpEvent(event, deviceNode.data.properties);\r\n          \r\n          case 'setThermostatTemperature':\r\n            return convertThermostatEvent(event, deviceNode.data.properties);\r\n          \r\n          case 'setLedIntensity':\r\n            return convertLedEvent(event, deviceNode.data.properties);\r\n          \r\n          case 'setDetectorSetting':\r\n            return convertDetectorEvent(event, deviceNode.data.properties);\r\n          \r\n          default:\r\n            console.warn(`Unknown event type: ${event.type}`);\r\n            return null;\r\n        }\r\n      }).filter(Boolean); // Remove any null events\r\n\r\n      if (deviceEvents.length > 0) {\r\n        deviceEventMap.set(targetId, deviceEvents);\r\n      }\r\n    });\r\n    console.log('deviceEventMap: ', Array.from(deviceEventMap.values()));\r\n    return Array.from(deviceEventMap.values());\r\n  };\r\n\r\n  const generateEventList = (blocks) => {\r\n    // Early exit if blocks array is invalid\r\n    if (!blocks || !Array.isArray(blocks) || blocks.length === 0) {\r\n      console.warn('No valid blocks found for event generation');\r\n      return [];\r\n    }\r\n\r\n    const orderedNodes = orderNodesByDistance(findOutletNode(graphData.nodes), graphData.nodes, graphData.links);\r\n    console.log('orderedNodes: ', orderedNodes);\r\n    \r\n    // Early exit if no ordered nodes\r\n    if (!orderedNodes || orderedNodes.length === 0) {\r\n      console.warn('No ordered nodes found for event generation');\r\n      return [];\r\n    }\r\n    \r\n    let eventList = [];\r\n    let dropletSnapshot = [];\r\n    \r\n    // Validate block droplets\r\n    if (!blocks[0] || !blocks[0].droplets || !Array.isArray(blocks[0].droplets) || blocks[0].droplets.length === 0) {\r\n      console.warn('No valid droplets found in blocks for event generation');\r\n      return [];\r\n    }\r\n    \r\n    const i = 0;\r\n    const currentBlockDroplets = blocks[i].droplets;\r\n    \r\n    // Add fallback for volumetricSpeed in case it's not found\r\n    const dropletWithParams = currentBlockDroplets.find(d => d && d.parameters && Array.isArray(d.parameters));\r\n    if (!dropletWithParams) {\r\n      console.warn('No droplet with valid parameters found');\r\n      return [];\r\n    }\r\n    \r\n    // Make sure we can find the volumetricSpeed parameter or use a default\r\n    const volumetricSpeedParam = dropletWithParams.parameters.find(p => p && p.name === 'volumetricSpeed');\r\n    const commonVolumetricSpeed = volumetricSpeedParam?.value || 1;\r\n    console.log('Using volumetricSpeed:', commonVolumetricSpeed);\r\n    \r\n    //adds some parameters to nodes\r\n    orderedNodes.forEach(node => {\r\n      node.inletVolumetricSpeed = commonVolumetricSpeed;\r\n      node.outletVolumetricSpeed = commonVolumetricSpeed;\r\n      const pump = findConnectedPump(node.node.id, graphData.nodes, graphData.links);\r\n      if (pump) {\r\n        node.connectedPump = pump;\r\n      }\r\n      else {\r\n        node.connectedPump = 0;\r\n      }\r\n      node.connectedPumpRatio = 0;\r\n      node.connectedPumpSpeedAtPause = 0;\r\n      node.pumpSpeedMultiplier = 1;\r\n      //node.requestedRatio = 0;\r\n      node.pauseLevel = 0;\r\n\r\n    });\r\n    //ustawia carrier pump na odpowiednią predkość\r\n    const carrierPumpConnector = graphData.links.find(link => link.source === selectedCarrierPumps[0]).target;\r\n    if (carrierPumpConnector) {\r\n      const connectorNode = orderedNodes.find(node => node.node.id === carrierPumpConnector);\r\n      connectorNode.inletVolumetricSpeed = commonVolumetricSpeed;\r\n      connectorNode.outletVolumetricSpeed = commonVolumetricSpeed;\r\n      connectorNode.connectedPump = graphData.nodes.find(node => node.id === selectedCarrierPumps[0]);\r\n      connectorNode.connectedPumpRatio = 1;\r\n      connectorNode.connectedPumpSpeedAtPause = commonVolumetricSpeed;\r\n      //connectorNode.requestedRatio = 0;\r\n      connectorNode.pauseLevel = 0;\r\n    }\r\n    let event = { //it is ok\r\n      type: 'setPumpSpeed',\r\n      target: selectedCarrierPumps[0],\r\n      time: 0,\r\n      value: commonVolumetricSpeed\r\n    };\r\n    eventList.push(event);\r\n\r\n    orderedNodes.filter(node => node.node.type === 'pump' && node.node.id !== selectedCarrierPumps[0]).forEach(pump => {\r\n      event = {//it is ok\r\n        type: 'setPumpSpeed',\r\n        target: pump.node.id,\r\n        time: 0,\r\n        value: 0\r\n      };\r\n      eventList.push(event);\r\n      \r\n    });\r\n\r\n    \r\n    let position = -0.001;\r\n    //prepares all droplets in block and calculates some parameters\r\n    currentBlockDroplets.forEach(droplet => {\r\n      const prefixVolume = droplet.parameters.find(p => p.name === 'prefixVolume')?.value;\r\n      const surfixVolume = droplet.parameters.find(p => p.name === 'surfixVolume')?.value;\r\n\r\n      droplet.frontVolumetricSpeed = commonVolumetricSpeed;\r\n      droplet.rearVolumetricSpeed = commonVolumetricSpeed;\r\n      droplet.frontVolumetricPosition = position - prefixVolume;\r\n      droplet.rearVolumetricPosition = droplet.frontVolumetricPosition;\r\n      droplet.frontVolumetricDistanceToNextNode = Math.abs(droplet.frontVolumetricPosition);\r\n      droplet.rearVolumetricDistanceToNextNode = Math.abs(droplet.rearVolumetricPosition); \r\n      droplet.frontTimeToReachNextNode = 0;\r\n      droplet.rearTimeToReachNextNode = 0;\r\n      droplet.frontNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\r\n      droplet.rearNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\r\n      droplet.pumpSpeedMultiplier = 1;\r\n      droplet.pauseLevel = 0;\r\n      droplet.frontVolumetricSpeedAtPause = 0;\r\n      droplet.rearVolumetricSpeedAtPause = 0;\r\n      droplet.stoppingDroplet = false;\r\n      droplet.initialPumping = false;\r\n\r\n      position -= ( prefixVolume + surfixVolume);\r\n    });\r\n    console.log('findFurthestNode: ', findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id);\r\n    console.log('Droplet positions initialized, nodes ready');\r\n\r\n    let lastDropletRearPosition = currentBlockDroplets[currentBlockDroplets.length - 1].rearVolumetricPosition;\r\n    let outletNodePosition = orderedNodes[0].node.volumetricPosition; \r\n    let timePassed = 0; //in s\r\n    let newTimePassed = 0;\r\n\r\n    // Simulate the movement of droplets in the current block\r\n    currentBlockDroplets.forEach(droplet => {\r\n      droplet.frontTimeToReachNextNode = Math.abs(droplet.frontVolumetricDistanceToNextNode / droplet.frontVolumetricSpeed);\r\n      droplet.rearTimeToReachNextNode = Math.abs(droplet.rearVolumetricDistanceToNextNode / droplet.rearVolumetricSpeed);\r\n    });\r\n\r\n    while (lastDropletRearPosition < outletNodePosition) {\r\n      \r\n      let smallestFrontTime = Infinity;\r\n      let smallestRearTime = Infinity;\r\n      let smallestFrontTimeDroplet = [];\r\n      let smallestRearTimeDroplet = [];\r\n\r\n      currentBlockDroplets.forEach(droplet => {// Update the smallest front and rear times and associated droplet(s) based on the current droplet's front and rear times to reach the next node.\r\n        \r\n        if (Math.abs(droplet.frontTimeToReachNextNode) < smallestFrontTime) {\r\n          smallestFrontTime = Math.abs(droplet.frontTimeToReachNextNode);\r\n          smallestFrontTimeDroplet = [droplet];\r\n        }\r\n        else if (Math.abs(droplet.frontTimeToReachNextNode) === smallestFrontTime) {\r\n          smallestFrontTimeDroplet.push(droplet);\r\n        }\r\n        if (Math.abs(droplet.rearTimeToReachNextNode) < smallestRearTime) {\r\n          smallestRearTime = Math.abs(droplet.rearTimeToReachNextNode);\r\n          smallestRearTimeDroplet = [droplet];\r\n        }\r\n        else if (Math.abs(droplet.rearTimeToReachNextNode) === smallestRearTime) {\r\n          smallestRearTimeDroplet.push(droplet);\r\n        }\r\n      });\r\n\r\n      newTimePassed += Math.min(Math.abs(smallestFrontTime), Math.abs(smallestRearTime));\r\n\r\n      if (smallestFrontTime === smallestRearTime) {//przypadek w ktorym wiele kropel ma ten sam czas do przejścia do nastepnego noda, rzadki\r\n        \r\n        if (smallestFrontTimeDroplet.length > 1 || smallestRearTimeDroplet.length > 1) {//sprawdź czy wśród nich jest kropla z rear i front\r\n          console.log('Multiple droplets have reached the next node simultaneously');\r\n          console.log('smallestFrontTimeDroplet: ', smallestFrontTimeDroplet);\r\n          console.log('smallestRearTimeDroplet: ', smallestRearTimeDroplet);\r\n          \r\n        }\r\n        else if (smallestFrontTimeDroplet[0] === smallestRearTimeDroplet[0]) {//przypadek gdy kropla ma 0 objętości\r\n          console.log('Both front and rear times are for the same droplet');\r\n          const reachedNode = orderedNodes.find(n => n.node.id === smallestFrontTimeDroplet[0].frontNextNodeID);\r\n          const reachedNodeDistance = orderedNodes.find(node => node.node.id === reachedNode.node.id).distance;\r\n          if (reachedNode.node.type === 'connector') {\r\n\r\n\r\n            const index = currentBlockDroplets.indexOf(smallestFrontTimeDroplet[0]);\r\n            const dropletsOlder = currentBlockDroplets.slice(0, index);\r\n            const dropletsNewer = currentBlockDroplets.slice(index + 1);\r\n\r\n            const ds = [];\r\n            ds.drops = JSON.parse(JSON.stringify(dropletsNewer)); // Create deep copy\r\n            ds.snappedNode = smallestFrontTimeDroplet[0].frontNextNodeID;\r\n            const existingSnapshotIndex = dropletSnapshot.findIndex(snapshot => snapshot.snappedNode === ds.snappedNode);\r\n            if (existingSnapshotIndex !== -1) {\r\n              dropletSnapshot[existingSnapshotIndex] = ds;\r\n            } else {\r\n              dropletSnapshot.push(ds);\r\n            }\r\n\r\n            //aktualizuje starsze krople\r\n            dropletsOlder.forEach(droplet => {\r\n              droplet.frontTimeToReachNextNode -= smallestFrontTime;\r\n              droplet.rearTimeToReachNextNode -= smallestFrontTime;\r\n              droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n              droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n              droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n              droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n            });\r\n\r\n            //aktualizuje kroplę\r\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n            const nextEdge = graphData.links.find(link => link.source === smallestFrontTimeDroplet[0].frontNextNodeID && link.target === nextNode.node.id);\r\n\r\n            if (reachedNode.connectedPump !== null){\r\n              const pumpRatio = smallestFrontTimeDroplet[0].parameters.find(param => param.nodeId === reachedNode.connectedPump.id && param.name === 'ratio')?.value || 0;\r\n              const dropletDesiredVolume = smallestFrontTimeDroplet[0].parameters.find(param => param.name === 'volume')?.value || 0;\r\n              \r\n              reachedNode.connectedPumpRatio = pumpRatio;\r\n              //reachedNode.inletVolumetricSpeed = 0;\r\n              //smallestFrontTimeDroplet[0].frontVolumetricSpeed = reachedNode.outletVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].frontVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].rearVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].rearVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].rearVolumetricSpeed = 0;\r\n              smallestFrontTimeDroplet[0].frontVolumetricPosition = reachedNode.node.volumetricPosition;\r\n              smallestFrontTimeDroplet[0].rearVolumetricPosition = reachedNode.node.volumetricPosition;\r\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n              smallestFrontTimeDroplet[0].rearVolumetricDistanceToNextNode = 0; \r\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode/smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].rearTimeToReachNextNode = dropletDesiredVolume*pumpRatio/smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\r\n              //smallestFrontTimeDroplet[0].rearNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\r\n              smallestFrontTimeDroplet[0].pumpSpeedMultiplier = 1;\r\n              //smallestFrontTimeDroplet[0].pauseLevel = 0;\r\n              smallestFrontTimeDroplet[0].stoppingDroplet = true;\r\n              smallestFrontTimeDroplet[0].initialPumping = true;\r\n              if (reachedNode.connectedPump.id !==selectedCarrierPumps[0]) {\r\n                event={\r\n                  type: 'setPumpSpeed',\r\n                  target: reachedNode.connectedPump.id,\r\n                  time: newTimePassed,\r\n                  value: smallestFrontTimeDroplet[0].frontVolumetricSpeed\r\n                };\r\n                eventList.push(event);\r\n              }\r\n\r\n              //update newer droplets\r\n              dropletsNewer.forEach(droplet => {\r\n                droplet.pauseLevel += 1;\r\n                if (droplet.pauseLevel===1){\r\n                  droplet.frontVolumetricSpeedAtPause = droplet.frontVolumetricSpeed;\r\n                  if (droplet.stoppingDroplet !== true){\r\n                    droplet.rearVolumetricSpeedAtPause = droplet.rearVolumetricSpeed;\r\n                  }\r\n                }\r\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricSpeed = 0;\r\n                droplet.rearVolumetricSpeed = 0;\r\n                droplet.frontTimeToReachNextNode += smallestFrontTimeDroplet[0].rearTimeToReachNextNode-smallestFrontTime;\r\n                droplet.rearTimeToReachNextNode += smallestFrontTimeDroplet[0].rearTimeToReachNextNode-smallestFrontTime;\r\n              });\r\n              getPumpsBetweenPositions(smallestFrontTimeDroplet[0].frontVolumetricPosition,-1, graphData.nodes, graphData.links).filter(pump => pump.id !== reachedNode.connectedPump.id, ).forEach(pump => {\r\n                \r\n                event={\r\n                  type: 'setPumpSpeed',\r\n                  target: pump.id,\r\n                  time: newTimePassed,\r\n                  value: 0\r\n                };\r\n                eventList.push(event);\r\n              });\r\n            }\r\n            \r\n          }\r\n          else if (reachedNode.type === 'thermostat' || reachedNode.type === 'LED') {\r\n            console.log('reachedNode is thermostat');\r\n          }\r\n          else if (reachedNode.type === 'outlet') {\r\n            console.log('reachedNode is outlet');\r\n          }\r\n          else if (reachedNode.type === 'detector' || reachedNode.type === 'USBSpectrometer' || reachedNode.type === 'MQTTSpectrometer') {\r\n            console.log('reachedNode is detector');\r\n          }\r\n        } \r\n        else {\r\n          console.log('Front and rear times are for different droplets');\r\n        }\r\n      } \r\n\r\n      else if (smallestFrontTime < smallestRearTime) { //przypadek gdzie przód jest przed tyłem\r\n        console.log('Front time is smaller than rear time');\r\n        if (smallestFrontTimeDroplet.length > 1) {\r\n          console.log(`Multiple droplets have reached the next node simultaneously`);\r\n          smallestFrontTimeDroplet.forEach(droplet => {\r\n            // Perform some action for each droplet in smallestFrontTimeDroplet\r\n          });\r\n        }\r\n        else { //przypadek gdy przód jednej kropelki dochodzi do noda\r\n          console.log(`Single droplet front has reached the next node`);\r\n          const reachedNode = orderedNodes.find(n => n.node.id === smallestFrontTimeDroplet[0].frontNextNodeID);\r\n          const reachedNodeDistance = orderedNodes.find(node => node.node.id === reachedNode.node.id).distance;\r\n\r\n          if (reachedNode.node.type === 'connector') { //przypadek gdy dochodzi do connectora\r\n            console.log('reachedNode is connector');\r\n\r\n            const index = currentBlockDroplets.indexOf(smallestFrontTimeDroplet[0]);\r\n            const dropletsOlder = currentBlockDroplets.slice(0, index);\r\n            const dropletsNewer = currentBlockDroplets.slice(index + 1);\r\n\r\n            //aktualizuje kroplę\r\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n            const nextEdge = graphData.links.find(link => link.source === reachedNode.node.id && link.target === nextNode.node.id);\r\n\r\n            if (reachedNode.connectedPump.id !== null){\r\n\r\n              const pumpRatio = smallestFrontTimeDroplet[0].parameters.find(param => param.nodeId === reachedNode.connectedPump.id && param.name === 'ratio')?.value || 0;\r\n              const dropletDesiredVolume = smallestFrontTimeDroplet[0].parameters.find(param => param.name === 'volume')?.value || 0;\r\n              smallestFrontTimeDroplet[0].frontVolumetricPosition = reachedNode.node.volumetricPosition;\r\n              smallestFrontTimeDroplet[0].rearVolumetricPosition += smallestFrontTime * smallestFrontTimeDroplet[0].rearVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].actualVolume =smallestFrontTimeDroplet[0].frontVolumetricPosition-smallestFrontTimeDroplet[0].rearVolumetricPosition;\r\n              reachedNode.inletVolumetricSpeed = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              reachedNode.connectedPumpRatio = pumpRatio;\r\n              smallestFrontTimeDroplet[0].rearTimeToReachNextNode -= smallestFrontTime;\r\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n              smallestFrontTimeDroplet[0].rearVolumetricDistanceToNextNode -= smallestFrontTime * smallestFrontTimeDroplet[0].rearVolumetricSpeed; \r\n\r\n              if (smallestFrontTimeDroplet[0].initialPumping === true){ //przypadek gdy kropla jest w pierwszej fazie pompowania (od 0uL)\r\n                console.log('Kropla jest w pierwszej fazie pompowania');\r\n                //smallestFrontTimeDroplet[0].initialPumping = false;\r\n                const rearTimeLeft = smallestFrontTimeDroplet[0].rearTimeToReachNextNode;\r\n                const totalTimeLeft = rearTimeLeft + smallestFrontTimeDroplet[0].actualVolume/commonVolumetricSpeed;\r\n                console.log('commonVolumetricSpeed: ', commonVolumetricSpeed);\r\n                console.log('smallestFrontTimeDroplet[0].actualVolume: ', smallestFrontTimeDroplet[0].actualVolume);\r\n                console.log('rearTimeLeft: ', rearTimeLeft);\r\n                console.log('totalTimeLeft: ', totalTimeLeft);\r\n                const thispumpspeed = pumpRatio*dropletDesiredVolume/totalTimeLeft;\r\n                console.log('thispumpspeed: ', thispumpspeed);\r\n                reachedNode.connectedPumpSpeedAtPause = thispumpspeed;\r\n              }\r\n\r\n              else {\r\n                console.log('Normalne pompowanie');\r\n                reachedNode.connectedPumpSpeedAtPause = (dropletDesiredVolume*pumpRatio) / (smallestFrontTimeDroplet[0].actualVolume / reachedNode.inletVolumetricSpeed);\r\n              }\r\n\r\n              reachedNode.outletVolumetricSpeed = reachedNode.inletVolumetricSpeed+reachedNode.connectedPumpSpeedAtPause;\r\n              smallestFrontTimeDroplet[0].frontVolumetricSpeed += reachedNode.connectedPumpSpeedAtPause;\r\n              //smallestFrontTimeDroplet[0].rearVolumetricSpeed = 0;\r\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode/smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\r\n              //smallestFrontTimeDroplet[0].rearNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\r\n              //smallestFrontTimeDroplet[0].pumpSpeedMultiplier = 1;\r\n              //smallestFrontTimeDroplet[0].pauseLevel = 0;\r\n              //smallestFrontTimeDroplet[0].frontVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              //smallestFrontTimeDroplet[0].rearVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              //smallestFrontTimeDroplet[0].stoppingDroplet = true;\r\n              event={\r\n                type: 'setPumpSpeed',\r\n                target: reachedNode.connectedPump.id,\r\n                time: newTimePassed,\r\n                value: reachedNode.connectedPumpSpeedAtPause \r\n              };\r\n              eventList.push(event);\r\n              //update newer droplets\r\n              dropletsNewer.forEach(droplet => {\r\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontTimeToReachNextNode -= smallestFrontTime;\r\n                droplet.rearTimeToReachNextNode -= smallestFrontTime;\r\n              });\r\n              //aktualizuje starsze krople\r\n              let accumulatedSpeed = reachedNode.connectedPumpSpeedAtPause;\r\n              dropletsOlder.reverse().forEach(droplet => {\r\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.rearVolumetricSpeed += accumulatedSpeed; \r\n                getPumpsBetweenPositions(droplet.frontVolumetricPosition,droplet.rearVolumetricPosition, graphData.nodes, graphData.links).forEach(pump => {\r\n                  const editedNode = orderedNodes.find(node => node.connectedPump.id === pump.id);\r\n                  //editedNode.pumpSpeedMultiplier = 1;\r\n                  const pumpBoost = editedNode.connectedPumpSpeedAtPause * accumulatedSpeed/editedNode.inletVolumetricSpeed;\r\n                  editedNode.connectedPumpSpeedAtPause += pumpBoost;\r\n                  editedNode.inletVolumetricSpeed += accumulatedSpeed;\r\n                  accumulatedSpeed += pumpBoost;\r\n                  editedNode.outletVolumetricSpeed += accumulatedSpeed;\r\n                  event={\r\n                    type: 'setPumpSpeed',\r\n                    target: pump.id,\r\n                    time: newTimePassed,\r\n                    value: editedNode.connectedPumpSpeedAtPause\r\n                  };\r\n                  eventList.push(event);\r\n                });\r\n                droplet.frontVolumetricSpeed += accumulatedSpeed;\r\n                droplet.frontTimeToReachNextNode = droplet.frontVolumetricDistanceToNextNode/droplet.frontVolumetricSpeed;\r\n                droplet.rearTimeToReachNextNode = droplet.rearVolumetricDistanceToNextNode/droplet.rearVolumetricSpeed;\r\n\r\n              });\r\n            }\r\n          }\r\n          else if (reachedNode.node.type === 'thermostat' || reachedNode.type === 'LED') {//przypadek gdy dochodzi do termostatu\r\n            console.log('reachedNode (thermostat, LED): ', reachedNode);\r\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n            if (nextNode) {\r\n              const nextEdge = graphData.links.find(link => link.source === smallestFrontTimeDroplet[0].frontNextNodeID && link.target === nextNode.node.id);\r\n              //aktualizuje krople\r\n              currentBlockDroplets.forEach(droplet => {\r\n                droplet.frontTimeToReachNextNode -= smallestFrontTime;\r\n                droplet.rearTimeToReachNextNode -= smallestFrontTime;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n              });\r\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\r\n            }\r\n          }\r\n          else if (reachedNode.node.type === 'outlet') { //jeśli ostatni node osiągnięty\r\n            console.log('reachedNode (outlet): ', reachedNode);\r\n            //typowe zaktualizowanie czasu do następnego noda dla reszty kropel i zestallowanie frontu\r\n            currentBlockDroplets.forEach(droplet => {\r\n              droplet.frontTimeToReachNextNode -= smallestFrontTime;\r\n              droplet.rearTimeToReachNextNode -= smallestFrontTime;\r\n              droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n              droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n              droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n              droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n            });\r\n            smallestFrontTimeDroplet[0].frontTimeToReachNextNode = Infinity;\r\n            smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = Infinity;\r\n            smallestFrontTimeDroplet[0].frontNextNodeID = null;\r\n          }\r\n          else if (reachedNode.node.type === 'detector' || reachedNode.node.type === 'USBSpectrometer' || reachedNode.node.type === 'MQTTSpectrometer') { //przypadek gdy dochodzi do detektora\r\n            console.log('reachedNode (detector): ', reachedNode);\r\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n            if (nextNode) {\r\n              const nextEdge = graphData.links.find(link => link.source === smallestFrontTimeDroplet[0].frontNextNodeID && link.target === nextNode.node.id);\r\n              //aktualizuje krople\r\n              currentBlockDroplets.forEach(droplet => {\r\n                droplet.frontTimeToReachNextNode -= smallestFrontTime;\r\n                droplet.rearTimeToReachNextNode -= smallestFrontTime;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n              });\r\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\r\n            }\r\n          }\r\n        }\r\n      } \r\n      \r\n      else {//przypadek gdzie tył jest przed przodem\r\n        console.log('Rear time is smaller than front time');\r\n        if (smallestRearTimeDroplet.length > 1) { //przypadek gdy dochodzi do noda wiele kropel\r\n          console.log(`Multiple droplets ends have reached the next node simultaneously`);\r\n          smallestRearTimeDroplet.forEach(droplet => {\r\n            // Perform some action for each droplet in smallestRearTimeDroplet\r\n          });\r\n        } \r\n        else { //przypadek gdy tył jednej kropelki dochodzi do noda\r\n          const reachedNode = orderedNodes.find(n => n.node.id === smallestRearTimeDroplet[0].rearNextNodeID);\r\n          const reachedNodeDistance = orderedNodes.find(node => node.node.id === reachedNode.node.id).distance;\r\n          \r\n          if (reachedNode.node.type === 'connector') { //przypadek gdy dochodzi do connectora\r\n            console.log('reachedNode is connector');\r\n\r\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n            const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\r\n            const index = currentBlockDroplets.indexOf(smallestRearTimeDroplet[0]);\r\n            const dropletsOlder = currentBlockDroplets.slice(0, index);\r\n            const dropletsNewer = currentBlockDroplets.slice(index + 1);\r\n            if (smallestRearTimeDroplet[0].stoppingDroplet === true){ //wznawia jeśli była zatrzymana\r\n              //aktualizuje starsze krople\r\n              dropletsOlder.forEach(droplet => {\r\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n              });\r\n\r\n              //aktualizuje nowsze krople\r\n              dropletsNewer.forEach(droplet => {\r\n                if (droplet.pauseLevel === 1){//\r\n                  droplet.pauseLevel = 0;\r\n                  droplet.frontVolumetricSpeed = droplet.frontVolumetricSpeedAtPause;\r\n                  droplet.rearVolumetricSpeed = droplet.rearVolumetricSpeedAtPause;\r\n                  getPumpsBetweenPositions(droplet.frontVolumetricPosition,droplet.rearVolumetricPosition, graphData.nodes, graphData.links).forEach(pump => {\r\n                    \r\n                    event={\r\n                      type: 'setPumpSpeed',\r\n                      target: pump.id,\r\n                      time: newTimePassed,\r\n                      value: orderedNodes.find(node => node.node.id === pump.id).connectedPumpSpeedAtPause\r\n                    };\r\n                    eventList.push(event);\r\n                  });\r\n                }\r\n                else {\r\n                  droplet.pauseLevel -= 1;\r\n                }\r\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n              });\r\n\r\n              reachedNode.connectedPumpRatio = 0; \r\n              //reachedNode.inletVolumetricSpeed = 0;\r\n              //smallestRearTimeDroplet[0].frontVolumetricSpeed = reachedNode.outletVolumetricSpeed;\r\n              smallestRearTimeDroplet[0].rearVolumetricSpeed = smallestRearTimeDroplet[0].rearVolumetricSpeedAtPause;\r\n              smallestRearTimeDroplet[0].frontVolumetricPosition += smallestRearTimeDroplet[0].frontVolumetricSpeed*smallestRearTime;\r\n              smallestRearTimeDroplet[0].rearVolumetricPosition = reachedNode.node.volumetricPosition;\r\n              smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode -= smallestRearTimeDroplet[0].frontVolumetricSpeed*smallestRearTime;\r\n              smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge); \r\n              smallestRearTimeDroplet[0].frontTimeToReachNextNode = smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode/smallestRearTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode/smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n              //smallestRearTimeDroplet[0].frontNextNodeID = nextNode.id;\r\n              smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\r\n              //smallestRearTimeDroplet[0].pumpSpeedMultiplier = 1;\r\n              //smallestRearTimeDroplet[0].pauseLevel = 0;\r\n              smallestRearTimeDroplet[0].frontVolumetricSpeedAtPause = smallestRearTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestRearTimeDroplet[0].rearVolumetricSpeedAtPause = smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n              smallestRearTimeDroplet[0].stoppingDroplet = false;\r\n              smallestRearTimeDroplet[0].initialPumping = false;\r\n\r\n              reachedNode.connectedPumpRatio = 0;\r\n              event = {\r\n                type: 'setPumpSpeed',\r\n                target: reachedNode.connectedPump.id,\r\n                time: newTimePassed,\r\n                value: 0\r\n              };\r\n              eventList.push(event);\r\n              event = {\r\n                type: 'setPumpSpeed',\r\n                target: selectedCarrierPumps[0],\r\n                time: newTimePassed,\r\n                value: commonVolumetricSpeed\r\n              };\r\n              eventList.push(event);\r\n\r\n            }\r\n            else {\r\n              console.log('it is not stopper');\r\n              if (reachedNode.connectedPump.id !== null){\r\n                \r\n                const speedDifference = reachedNode.outletVolumetricSpeed - reachedNode.inletVolumetricSpeed;\r\n                //reachedNode.inletVolumetricSpeed = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n                reachedNode.outletVolumetricSpeed = reachedNode.inletVolumetricSpeed;\r\n                reachedNode.connectedPumpRatio = 0;\r\n                reachedNode.connectedPumpSpeedAtPause = 0;\r\n                smallestRearTimeDroplet[0].frontVolumetricPosition += smallestRearTime * smallestRearTimeDroplet[0].frontVolumetricSpeed;\r\n                smallestRearTimeDroplet[0].rearVolumetricPosition = reachedNode.node.volumetricPosition;\r\n                smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode -= smallestRearTime * smallestRearTimeDroplet[0].frontVolumetricSpeed;\r\n                smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge); \r\n                //smallestRearTimeDroplet[0].frontNextNodeID = nextNode.id;\r\n                smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\r\n                //smallestRearTimeDroplet[0].pumpSpeedMultiplier = 1;\r\n                //smallestRearTimeDroplet[0].pauseLevel = 0; \r\n                //smallestRearTimeDroplet[0].stoppingDroplet = true;\r\n                smallestRearTimeDroplet[0].frontVolumetricSpeed = smallestRearTimeDroplet[0].frontVolumetricSpeed-speedDifference;\r\n                //smallestRearTimeDroplet[0].rearVolumetricSpeed = 0;\r\n                smallestRearTimeDroplet[0].frontVolumetricSpeedAtPause = smallestRearTimeDroplet[0].frontVolumetricSpeed;\r\n                //smallestRearTimeDroplet[0].rearVolumetricSpeedAtPause = smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n                smallestRearTimeDroplet[0].frontTimeToReachNextNode = smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].frontVolumetricSpeed;\r\n                smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n                event={\r\n                  type: 'setPumpSpeed',\r\n                  target: reachedNode.connectedPump.id,\r\n                  time: newTimePassed,\r\n                  value: reachedNode.connectedPumpSpeedAtPause \r\n                };\r\n                eventList.push(event);\r\n                //updte newer droplets\r\n                dropletsNewer.forEach(droplet => {\r\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                  droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n                  droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n                });\r\n                //aktualizuje starsze krople\r\n                let accumulatedSpeedDecrease = speedDifference;\r\n                dropletsOlder.reverse().forEach(droplet => {\r\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                  droplet.rearVolumetricSpeed -= accumulatedSpeedDecrease;\r\n                  getPumpsBetweenPositions(droplet.frontVolumetricPosition,droplet.rearVolumetricPosition, graphData.nodes, graphData.links).forEach(pump => {\r\n                    const editedNode = orderedNodes.find(node => node.connectedPump.id === pump.id);\r\n                    const pumpBreak = editedNode.connectedPumpSpeedAtPause * accumulatedSpeedDecrease/editedNode.inletVolumetricSpeed;\r\n                    editedNode.connectedPumpSpeedAtPause -= pumpBreak;\r\n                    editedNode.inletVolumetricSpeed -= accumulatedSpeedDecrease;\r\n                    accumulatedSpeedDecrease += pumpBreak;\r\n                    editedNode.outletVolumetricSpeed -= accumulatedSpeedDecrease;\r\n                    event={\r\n                      type: 'setPumpSpeed',\r\n                      target: pump.id,\r\n                      time: newTimePassed,\r\n                      value: editedNode.connectedPumpSpeedAtPause\r\n                    };\r\n                    eventList.push(event);\r\n                  });\r\n                  droplet.frontVolumetricSpeed -= accumulatedSpeedDecrease;\r\n                  droplet.frontTimeToReachNextNode = droplet.frontVolumetricDistanceToNextNode/droplet.frontVolumetricSpeed;\r\n                  droplet.rearTimeToReachNextNode = droplet.rearVolumetricDistanceToNextNode/droplet.rearVolumetricSpeed;\r\n  \r\n                });\r\n              }\r\n            }\r\n\r\n          }\r\n          else if (reachedNode.node.type === 'thermostat' || reachedNode.node.type === 'LED') {//przypadek gdy dochodzi do termostatu\r\n            console.log('reachedNode thermostat: ', reachedNode);\r\n            \r\n            const isFarthestThermostatOrLED = orderedNodes.filter(node => node.node.type === 'thermostat' || node.node.type === 'LED').every(node => node.distance <= reachedNodeDistance);\r\n            \r\n            // This line checks if the smallestRearTimeDroplet is the last droplet in the currentBlockDroplets array.\r\n            if (isFarthestThermostatOrLED && currentBlockDroplets.length === currentBlockDroplets.indexOf(smallestRearTimeDroplet[0])+1) {\r\n              console.log('This is the farthest thermostat or LED node. Also, last droplet just passed through it.');\r\n              const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n              const waitTime = smallestRearTimeDroplet[0].parameters.find(param => param.nodeId === reachedNode.node.id && param.name === 'time')?.value || 0;\r\n              if (nextNode) {\r\n                const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\r\n                smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n                smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode/smallestRearTimeDroplet[0].rearVolumetricSpeed + smallestRearTime;\r\n                smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\r\n                //aktualizuje resztę kropli\r\n                currentBlockDroplets.forEach(droplet => {\r\n                  droplet.frontTimeToReachNextNode += waitTime - smallestRearTime;\r\n                  droplet.rearTimeToReachNextNode += waitTime - smallestRearTime;\r\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed-waitTime * droplet.frontVolumetricSpeed;//to jest zrobione na razie aby czas się zgadzał\r\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed-waitTime * droplet.rearVolumetricSpeed;\r\n                });\r\n\r\n                let carrierPumpEvent = {\r\n                  type: 'setPumpSpeed',\r\n                  target: selectedCarrierPumps[0], // Assuming 'carrierPumpId' is the ID of the carrier pump\r\n                  time: newTimePassed,\r\n                  value: 0\r\n                };\r\n                eventList.push(carrierPumpEvent);\r\n                carrierPumpEvent = {\r\n                  type: 'setPumpSpeed',\r\n                  target: selectedCarrierPumps[0], // Assuming 'carrierPumpId' is the ID of the carrier pump\r\n                  time: newTimePassed+waitTime,\r\n                  value: commonVolumetricSpeed\r\n                };\r\n                eventList.push(carrierPumpEvent);\r\n              }\r\n            }\r\n            else { //droplet wasnt the last one\r\n              console.log('smallestRearTimeDroplet is not the last droplet in the currentBlockDroplets array');\r\n              const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n              if (nextNode) {\r\n                const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\r\n                //aktualizuje krople\r\n                currentBlockDroplets.forEach(droplet => {\r\n                  droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n                  droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n                });\r\n                smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n                smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n                smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\r\n              }\r\n            }\r\n          }\r\n          else if (reachedNode.node.type === 'outlet') { //jeśli ostatni node osiągnięty\r\n            //typowe zaktualizowanie czasu do następnego noda dla reszty kropel i zestallowanie reara\r\n            //aktualizuje resztę kropli\r\n            currentBlockDroplets.forEach(droplet => {\r\n              droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n              droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n              droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n              droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n              droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n              droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n            });\r\n            smallestRearTimeDroplet[0].frontTimeToReachNextNode = Infinity;\r\n            smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode = Infinity;\r\n            smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = Infinity;\r\n            smallestRearTimeDroplet[0].rearNextNodeID = null;\r\n            smallestRearTimeDroplet[0].rearTimeToReachNextNode = Infinity;\r\n          }\r\n          else if (reachedNode.node.type === 'detector' || reachedNode.node.type === 'USBSpectrometer' || reachedNode.node.type === 'MQTTSpectrometer') { //przypadek gdy dochodzi do detektora\r\n            console.log('reachedNode (detector): ', reachedNode);\r\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n            if (nextNode) {\r\n              const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\r\n              //aktualizuje krople\r\n              currentBlockDroplets.forEach(droplet => {\r\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n              });\r\n              smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n              smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n              smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      timePassed = newTimePassed;\r\n      // Update last droplet rear position\r\n      lastDropletRearPosition = currentBlockDroplets[currentBlockDroplets.length - 1].rearVolumetricPosition;\r\n\r\n      //add code that preserves droplets positions and speeds for visualization\r\n      const dropletState = {\r\n        time: timePassed,\r\n        droplets: currentBlockDroplets.map(droplet => ({\r\n          id: droplet.id,\r\n          frontVolumetricPosition: droplet.frontVolumetricPosition,\r\n          rearVolumetricPosition: droplet.rearVolumetricPosition,\r\n          frontVolumetricSpeed: droplet.frontVolumetricSpeed,\r\n          rearVolumetricSpeed: droplet.rearVolumetricSpeed,\r\n          pumpSpeedMultiplier: droplet.pumpSpeedMultiplier,\r\n          frontTimeToReachNextNode: droplet.frontTimeToReachNextNode,\r\n          rearTimeToReachNextNode: droplet.rearTimeToReachNextNode,\r\n          frontVolumetricDistanceToNextNode: droplet.frontVolumetricDistanceToNextNode,\r\n          rearVolumetricDistanceToNextNode: droplet.rearVolumetricDistanceToNextNode,\r\n          volume: droplet.parameters.find(p => p.name === 'volume')?.value || 0,\r\n          frontNextNodeID: droplet.frontNextNodeID,\r\n          rearNextNodeID: droplet.rearNextNodeID\r\n        }))\r\n      };\r\n      setDropletHistory(prev => [...prev, dropletState]);\r\n\r\n      \r\n\r\n      //if (timePassed > 9999) {//here for testing, preventing infinite loop\r\n      //  lastDropletRearPosition = 88100;\r\n      //}\r\n\r\n    }\r\n    event = {//it is ok\r\n      type: 'setPumpSpeed',\r\n      target: selectedCarrierPumps[0],\r\n      time: timePassed,\r\n      value: 0\r\n    };\r\n    eventList.push(event);\r\n\r\n    eventList = cleanAndSortEventList(eventList);\r\n    console.log('dropletHistory in event generator: ', dropletHistory);\r\n    console.log('eventList: ', eventList.sort((a, b) => a.time - b.time));\r\n    setPumpEvents(extractPumpEvents(eventList));\r\n    return eventList;\r\n  }\r\n  // First useEffect to set initial graphData\r\n  useEffect(() => {\r\n    setDropletHistory([]);\r\n    if (nodes.length > 0 && edges.length > 0) {\r\n      const graphNodes = nodes.map(node => ({\r\n        id: node.id,\r\n        label: node.data.label,\r\n        type: node.data.type,\r\n        x: 0,\r\n        y: 0,\r\n        volumetricPosition: 0\r\n      }));\r\n\r\n      const graphLinks = edges.map(edge => ({\r\n        source: edge.source,\r\n        target: edge.target,\r\n        length: edge.data?.properties?.length || 100,\r\n        diameter: edge.data?.properties?.diameter || 1,\r\n      }));\r\n\r\n      setGraphData({ nodes: graphNodes, links: graphLinks });\r\n    }\r\n    \r\n  }, [nodes, edges]);\r\n\r\n  // Second useEffect to calculate nodes positions and set up simulation data\r\n  useEffect(() => {\r\n    if (!graphData.nodes.length || !graphData.links.length || !droplets.length) {\r\n      console.log('Missing required data for simulation setup:', {\r\n        nodesLength: graphData.nodes.length,\r\n        linksLength: graphData.links.length,\r\n        dropletsLength: droplets.length\r\n      });\r\n      return;\r\n    }\r\n\r\n    const graphNodes = [...graphData.nodes];\r\n    \r\n    // Find outlet node first\r\n    const outletNode = findOutletNode(graphData.nodes);\r\n    if (!outletNode) {\r\n      console.error('No outlet node found. Cannot set up simulation.');\r\n      return;\r\n    }\r\n\r\n    // Get ordered nodes from outlet\r\n    const orderedNodes = orderNodesByDistance(outletNode, graphData.nodes, graphData.links);\r\n    \r\n    // Separate nodes into main line and secondary line\r\n    const mainLineNodes = orderedNodes\r\n      .filter(({node}) => \r\n        setOfMainLineNodes.includes(node.type))\r\n      .reverse();\r\n      \r\n    const secondaryLineNodes = orderedNodes\r\n      .filter(({node}) => setOfSecondaryLineNodes.includes(node.type))\r\n      .sort((a, b) => b.distance - a.distance);\r\n\r\n    // Position settings\r\n    const mainLineY = 300;\r\n    const secondaryLineY = 150;\r\n    const pumpSpacing = 100; // Increased horizontal spacing between pumps\r\n    let currentX = 100;\r\n\r\n    // Position main line nodes\r\n    let currentVolumetricPosition = 0;\r\n    mainLineNodes.forEach(({node}, index) => {\r\n      const graphNode = graphNodes.find(n => n.id === node.id);\r\n      if (!graphNode) return;\r\n\r\n      graphNode.x = currentX;\r\n      graphNode.y = mainLineY;\r\n      graphNode.volumetricPosition = currentVolumetricPosition;\r\n      \r\n      if (index < mainLineNodes.length - 1) {\r\n        const nextNode = mainLineNodes[index + 1];\r\n        const edge = graphData.links.find(e => \r\n          (e.source === graphNode.id && e.target === nextNode.node.id) ||\r\n          (e.target === graphNode.id && e.source === nextNode.node.id)\r\n        );\r\n        \r\n        if (edge && edge.length) {\r\n          currentX += edge.length * 2;\r\n          // Use existing calculateEdgeVolume function\r\n          const edgeVolume = calculateEdgeVolume(edge);\r\n          currentVolumetricPosition += edgeVolume;\r\n        } else {\r\n          currentX += 200;\r\n          currentVolumetricPosition += 150;\r\n        }\r\n      }\r\n    });\r\n\r\n    // Group secondary nodes by distance\r\n    const nodesByDistance = {};\r\n    secondaryLineNodes.forEach(({node, distance}) => {\r\n      if (!nodesByDistance[distance]) {\r\n        nodesByDistance[distance] = [];\r\n      }\r\n      nodesByDistance[distance].push(node);\r\n    });\r\n\r\n    // Position secondary nodes based on their connected main line nodes\r\n    const pumpOffset = 50; // Add this constant for pump spacing\r\n    Object.entries(nodesByDistance).forEach(([distance, nodes]) => {\r\n      nodes.forEach((node, index) => {\r\n        const graphNode = graphNodes.find(n => n.id === node.id);\r\n        if (!graphNode) return;\r\n\r\n        // Find connected main line node through edges\r\n        const connectedEdge = edges.find(e => \r\n          e.source === node.id || e.target === node.id\r\n        );\r\n        \r\n        if (connectedEdge) {\r\n          const connectedNodeId = connectedEdge.source === node.id ? connectedEdge.target : connectedEdge.source;\r\n          const connectedMainNode = graphNodes.find(n => n.id === connectedNodeId);\r\n          \r\n          if (connectedMainNode) {\r\n            // Position pump above its connected main line node with offset if needed\r\n            graphNode.x = connectedMainNode.x + (index * pumpOffset) - ((nodes.length - 1) * pumpOffset / 2);\r\n            graphNode.y = secondaryLineY;\r\n          }\r\n        }\r\n      });\r\n    });\r\n\r\n    setGraphData(prev => ({ ...prev, nodes: graphNodes }));\r\n    \r\n    // Only calculate volumes and blocks if not already done\r\n    if (currentBlockDroplets.length === 0) {\r\n      console.log('Calculating thermostat volumes and blocks for droplets:', droplets.length);\r\n      const thermoVol = calculateVolumesBetweenThermostats(graphData);\r\n      \r\n      // Create deep copy of droplets to avoid mutation issues\r\n      const dropletsCopy = JSON.parse(JSON.stringify(droplets));\r\n      const blocks = divideDropletsIntoBlocks(dropletsCopy, thermoVol);\r\n      \r\n      if (blocks.length > 0) {\r\n        setCurrentBlockDroplets(blocks[0].droplets);\r\n        // Generate event list only once when initializing\r\n        const eventList = generateEventList(blocks);\r\n        const eventListForDevices = recalculateEventListForDevices(eventList);\r\n      }\r\n    }\r\n    \r\n    // Important: the dependency array includes currentBlockDroplets.length to prevent infinite recalculations\r\n  }, [graphData.nodes.length, graphData.links.length, droplets, edges, currentBlockDroplets.length]);\r\n\r\n  const startSimulation = useCallback(() => {\r\n    setIsSimulationRunning(true);\r\n    lastFrameTimeRef.current = null; // Reset the last frame time\r\n  }, []);\r\n\r\n  const stopSimulation = useCallback(() => {\r\n    setIsSimulationRunning(false);\r\n    if (animationFrameRef.current) {\r\n      cancelAnimationFrame(animationFrameRef.current);\r\n      animationFrameRef.current = null;\r\n    }\r\n  }, []);\r\n\r\n  const restartSimulation = useCallback(() => {\r\n    stopSimulation();\r\n    setKey(prevKey => prevKey + 1);\r\n    setCurrentTime(0);\r\n    startSimulation();\r\n  }, [stopSimulation, startSimulation]);\r\n\r\n\r\n  const getNodeColor = (node) => {\r\n    switch (node.type) {\r\n      case 'pump': return '#4CAF50';\r\n      case 'connector': return '#2196F3';\r\n      case 'outlet': return '#F44336';\r\n      default: return '#FFA000'; // Default color for unknown types\r\n    }\r\n  };\r\n\r\n  // Update volumetricToXPosition function\r\n  const volumetricToXPosition = useCallback((volumetricPosition) => {\r\n    const outletNode = findOutletNode(graphData.nodes);\r\n    const furthestNode = findFurthestNode(outletNode, graphData.nodes, graphData.links);\r\n    \r\n    if (!outletNode || !furthestNode) return 0;\r\n\r\n    const totalVolume = getVolumeBetweenNodes(furthestNode.id, outletNode.id, graphData.nodes, graphData.links);\r\n    const outletX = graphData.nodes.find(n => n.id === outletNode.id)?.x || 0;\r\n    const furthestX = graphData.nodes.find(n => n.id === furthestNode.id)?.x || 0;\r\n    \r\n    // Handle edge cases\r\n    if (!totalVolume || totalVolume === 0 || isNaN(totalVolume)) {\r\n      console.warn('Total volume is invalid:', totalVolume);\r\n      return furthestX;\r\n    }\r\n\r\n    if (volumetricPosition === undefined || volumetricPosition === null || isNaN(volumetricPosition)) {\r\n      console.warn('Volumetric position is invalid:', volumetricPosition);\r\n      return furthestX;\r\n    }\r\n\r\n    // Clamp the position to valid range\r\n    const clampedPosition = Math.max(-totalVolume, Math.min(totalVolume, volumetricPosition));\r\n    \r\n    // Apply scaling factor to the position calculation\r\n    const scaledX = furthestX + ((clampedPosition / totalVolume) * (outletX - furthestX));\r\n    \r\n    // Ensure the returned value is a valid number\r\n    if (!isFinite(scaledX) || isNaN(scaledX)) {\r\n      console.warn('Invalid scaled position calculated:', {\r\n        scaledX,\r\n        clampedPosition,\r\n        totalVolume,\r\n        outletX,\r\n        furthestX\r\n      });\r\n      return furthestX;\r\n    }\r\n    \r\n    return scaledX;\r\n  }, [graphData.nodes]);    \r\n\r\n  // Update the updateDropletPositions function\r\n  const updateDropletPositions = useCallback((timestamp) => {\r\n    if (!isSimulationRunning || dropletHistory.length === 0) return;\r\n\r\n    if (!lastFrameTimeRef.current) {\r\n      lastFrameTimeRef.current = timestamp;\r\n      animationFrameRef.current = requestAnimationFrame(updateDropletPositions);\r\n      return;\r\n    }\r\n\r\n    const deltaTime = (timestamp - lastFrameTimeRef.current) / 1000; // Convert to seconds\r\n    const simulationDeltaTime = deltaTime * timeScale;\r\n    \r\n    setCurrentTime(prevTime => {\r\n      const newTime = prevTime + simulationDeltaTime;\r\n      \r\n      // Get the time range of our history\r\n      const lastHistoryTime = dropletHistory[dropletHistory.length - 1].time;\r\n      \r\n      // If we've reached the end, loop back to start\r\n      if (newTime >= lastHistoryTime) {\r\n        setCurrentTime(0);\r\n        return 0;\r\n      }\r\n\r\n      // Find the appropriate states to interpolate between\r\n      const currentState = interpolateDropletState(newTime);\r\n      // Update droplet visualization\r\n      const updatedDroplets = currentState.map(droplet => {\r\n        const frontX = volumetricToXPosition(droplet.frontVolumetricPosition);\r\n        const rearX = volumetricToXPosition(droplet.rearVolumetricPosition);\r\n\r\n        if (isNaN(frontX) || isNaN(rearX)) {\r\n          console.warn('Invalid droplet position calculated:', {\r\n            dropletId: droplet.id,\r\n            frontPosition: droplet.frontVolumetricPosition,\r\n            rearPosition: droplet.rearVolumetricPosition,\r\n            frontX,\r\n            rearX\r\n          });\r\n          return null;\r\n        }\r\n\r\n        return {\r\n          id: droplet.id,\r\n          frontX,\r\n          rearX,\r\n          y: 300,\r\n          volume: droplet.frontVolumetricPosition-droplet.rearVolumetricPosition,\r\n          speed: droplet.frontVolumetricSpeed\r\n        };\r\n      }).filter(Boolean);\r\n\r\n      setSimulationDroplets(updatedDroplets);\r\n      return newTime;\r\n    });\r\n\r\n    lastFrameTimeRef.current = timestamp;\r\n    animationFrameRef.current = requestAnimationFrame(updateDropletPositions);\r\n  }, [isSimulationRunning, timeScale, volumetricToXPosition, dropletHistory]);\r\n\r\n  // Add animation effect\r\n  useEffect(() => {\r\n    if (isSimulationRunning) {\r\n      lastFrameTimeRef.current = null;\r\n      animationFrameRef.current = requestAnimationFrame(updateDropletPositions);\r\n    }\r\n    return () => {\r\n      if (animationFrameRef.current) {\r\n        cancelAnimationFrame(animationFrameRef.current);\r\n      }\r\n    };\r\n  }, [isSimulationRunning, updateDropletPositions]);\r\n\r\n  // Add this helper function for interpolation\r\n  const interpolateDropletState = (time) => {\r\n    if (!dropletHistory.length) return [];\r\n    \r\n    // Find the two closest states\r\n    const index = dropletHistory.findIndex(state => state.time > time);\r\n    if (index === -1) return dropletHistory[dropletHistory.length - 1].droplets;\r\n    if (index === 0) return dropletHistory[0].droplets;\r\n    \r\n    const beforeState = dropletHistory[index - 1];\r\n    const afterState = dropletHistory[index];\r\n    const fraction = (time - beforeState.time) / (afterState.time - beforeState.time);\r\n    \r\n    return beforeState.droplets.map(beforeDroplet => {\r\n      const afterDroplet = afterState.droplets.find(d => d.id === beforeDroplet.id);\r\n      if (!afterDroplet) return beforeDroplet;\r\n      \r\n      return {\r\n        ...beforeDroplet,\r\n        frontVolumetricPosition: beforeDroplet.frontVolumetricPosition + \r\n          (afterDroplet.frontVolumetricPosition - beforeDroplet.frontVolumetricPosition) * fraction,\r\n        rearVolumetricPosition: beforeDroplet.rearVolumetricPosition + \r\n          (afterDroplet.rearVolumetricPosition - beforeDroplet.rearVolumetricPosition) * fraction,\r\n      };\r\n    });\r\n  };\r\n\r\n  // Add navigation functions\r\n  const jumpToTimepoint = useCallback((index) => {\r\n    if (index >= 0 && index < dropletHistory.length) {\r\n      setCurrentTimepoint(index);\r\n      setCurrentTime(dropletHistory[index].time);\r\n    }\r\n  }, [dropletHistory]);\r\n\r\n  const nextTimepoint = useCallback(() => {\r\n    jumpToTimepoint(currentTimepoint + 1);\r\n  }, [currentTimepoint, jumpToTimepoint]);\r\n\r\n  const previousTimepoint = useCallback(() => {\r\n    jumpToTimepoint(currentTimepoint - 1);\r\n  }, [currentTimepoint, jumpToTimepoint]);\r\n\r\n\r\n\r\n  const handleNodeClick = (node) => {\r\n    console.log('Node clicked:', node);\r\n    console.log('Node type:', node.type);\r\n    console.log('Node data type:', node.data?.type);\r\n    \r\n    // Check both node.type and node.data.type\r\n    const nodeType = node.type || node.data?.type;\r\n    console.log('Determined node type:', nodeType);\r\n    \r\n    if (nodeType === 'pump' || nodeType === 'USBSpectrometer' || nodeType === 'MQTTSpectrometer') {\r\n      setSelectedNode(node);\r\n      console.log('Selected node set:', node.id, nodeType);\r\n    }\r\n    if (node.type === 'detector' || node.type === 'USBSpectrometer' || node.type === 'MQTTSpectrometer') {\r\n      // Store the graph ref when opening a spectrometer\r\n      const graphRef = React.createRef();\r\n      graphRefs.current[node.id] = graphRef;\r\n      \r\n      // ... rest of the existing handleNodeClick code ...\r\n    }\r\n  };\r\n\r\n  const handleNodeAction = (action) => {\r\n    console.log('Node action:', action);\r\n    // Here you would implement the actual device communication\r\n    // based on the action type and parameters\r\n  };\r\n\r\n  const togglePumpSpeeds = () => {\r\n    setDisplayPumpSpeeds(!displayPumpSpeeds);\r\n  };\r\n\r\n  // Toggle functions for each display option\r\n  const toggleNodeIds = () => {\r\n    setDisplayNodeIds(!displayNodeIds);\r\n  };\r\n  \r\n  const toggleDropletInfo = () => {\r\n    setDisplayDropletInfo(!displayDropletInfo);\r\n  };\r\n  \r\n  const toggleDropletGaps = () => {\r\n    setDisplayDropletGaps(!displayDropletGaps);\r\n  };\r\n  \r\n  const toggleEdgeLabels = () => {\r\n    setDisplayEdgeLabels(!displayEdgeLabels);\r\n  };\r\n  \r\n  const toggleDisplayMenu = () => {\r\n    setDisplayMenuOpen(!isDisplayMenuOpen);\r\n  };\r\n  \r\n  const toggleTimelineDropletInfo = () => {\r\n    setDisplayTimelineDropletInfo(!displayTimelineDropletInfo);\r\n  };\r\n  \r\n  // Close menu when clicking outside\r\n  useEffect(() => {\r\n    const handleClickOutside = (event) => {\r\n      if (displayMenuRef.current && !displayMenuRef.current.contains(event.target)) {\r\n        setDisplayMenuOpen(false);\r\n      }\r\n    };\r\n    \r\n    document.addEventListener('mousedown', handleClickOutside);\r\n    return () => {\r\n      document.removeEventListener('mousedown', handleClickOutside);\r\n    };\r\n  }, []);\r\n\r\n  // Function to toggle pump panel visibility\r\n  const togglePumpPanel = (pumpId) => {\r\n    setVisiblePumpPanel((prev) => (prev === pumpId ? null : pumpId));\r\n  };\r\n\r\n  // Add styles for the display menu\r\n  const styles = {\r\n    container: {\r\n      ...backgroundVariants.mainBackground,\r\n      padding: '20px',\r\n      minHeight: '100vh'\r\n    },\r\n    dropletInfo: {\r\n      padding: '8px',\r\n      borderRadius: '4px',\r\n      fontSize: '12px',\r\n      ...backgroundVariants.panelBackground,\r\n      color: '#fff',\r\n      minWidth: '150px'\r\n    },\r\n    timelineContainer: {\r\n      display: 'flex',\r\n      flexDirection: 'column',\r\n      gap: '10px',\r\n      marginBottom: '20px'\r\n    },\r\n    timeInput: {\r\n      width: '100px',\r\n      ...backgroundVariants.inputBackground,\r\n      padding: '5px',\r\n      borderRadius: '4px',\r\n      marginLeft: '8px'\r\n    },\r\n    buttonGroup: {\r\n      display: 'flex',\r\n      gap: '10px',\r\n      marginTop: '20px',\r\n      marginBottom: '20px'\r\n    },\r\n    timelineControls: {\r\n      display: 'flex',\r\n      flexDirection: 'column',\r\n      gap: '15px',\r\n      marginBottom: '20px',\r\n      ...backgroundVariants.panelBackground,\r\n      padding: '15px',\r\n      borderRadius: '4px'\r\n    },\r\n    timeControls: {\r\n      display: 'flex',\r\n      flexDirection: 'column',\r\n      gap: '15px'\r\n    },\r\n    sliderContainer: {\r\n      display: 'flex',\r\n      gap: '10px',\r\n      alignItems: 'center',\r\n      borderBottom: '1px solid rgba(255,255,255,0.1)',\r\n      paddingBottom: '15px'\r\n    },\r\n    timeStepButtons: {\r\n      display: 'flex',\r\n      gap: '5px',\r\n      alignItems: 'center',\r\n      justifyContent: 'flex-start'\r\n    },\r\n    timeScaleContainer: {\r\n      display: 'flex',\r\n      alignItems: 'center',\r\n      gap: '15px',\r\n      justifyContent: 'flex-start',\r\n      borderTop: '1px solid rgba(255,255,255,0.1)',\r\n      paddingTop: '15px'\r\n    },\r\n    svgContainer: {\r\n      background: backgroundVariants.panelBackground.background,\r\n      borderRadius: '4px',\r\n      padding: '10px'\r\n    },\r\n    navigationButtons: {\r\n      display: 'flex',\r\n      justifyContent: 'space-between',\r\n      marginBottom: '20px'\r\n    },\r\n    timeSlider: {\r\n      width: '33%',\r\n      ...backgroundVariants.inputBackground,\r\n      height: '20px',\r\n      borderRadius: '10px',\r\n      WebkitAppearance: 'none',\r\n      appearance: 'none',\r\n      background: backgroundVariants.inputBackground.background,\r\n      outline: 'none',\r\n      opacity: '0.7',\r\n      transition: 'opacity .2s',\r\n      '&:hover': {\r\n        opacity: '1'\r\n      },\r\n      '&::-webkit-slider-thumb': {\r\n        WebkitAppearance: 'none',\r\n        appearance: 'none',\r\n        width: '20px',\r\n        height: '20px',\r\n        background: '#4CAF50',\r\n        cursor: 'pointer',\r\n        borderRadius: '50%'\r\n      },\r\n      '&::-moz-range-thumb': {\r\n        width: '20px',\r\n        height: '20px',\r\n        background: '#4CAF50',\r\n        cursor: 'pointer',\r\n        borderRadius: '50%'\r\n      }\r\n    },\r\n    // Add styles for display menu\r\n    displayMenuButton: {\r\n      ...buttonVariants.infoButton,\r\n      position: 'relative'\r\n    },\r\n    displayMenu: {\r\n      position: 'absolute',\r\n      top: '100%',\r\n      right: 0,\r\n      backgroundColor: '#333',\r\n      border: '1px solid #555',\r\n      borderRadius: '4px',\r\n      padding: '8px 0',\r\n      zIndex: 1000,\r\n      width: '220px',\r\n      boxShadow: '0 2px 10px rgba(0, 0, 0, 0.3)'\r\n    },\r\n    menuItem: {\r\n      padding: '8px 16px',\r\n      cursor: 'pointer',\r\n      display: 'flex',\r\n      alignItems: 'center',\r\n      justifyContent: 'space-between',\r\n      color: 'white',\r\n      transition: 'background-color 0.2s',\r\n      '&:hover': {\r\n        backgroundColor: '#444'\r\n      }\r\n    },\r\n    checkmark: {\r\n      color: '#4CAF50',\r\n      fontWeight: 'bold'\r\n    }\r\n  };\r\n\r\n  const sliderStyle = {\r\n    width: '100%',\r\n    height: '10px',\r\n    borderRadius: '5px', \r\n    background: '#333',\r\n    outline: 'none',\r\n    opacity: '0.7',\r\n    transition: 'opacity .2s'\r\n    // Remove all pseudo-element styles that were here\r\n  };\r\n\r\n  return (\r\n    <div style={styles.container}>\r\n      <div style={styles.timelineControls}>\r\n        <div style={styles.timeControls}>\r\n          <div style={styles.sliderContainer}>\r\n            <input\r\n              type=\"range\"\r\n              min={0}\r\n              max={Math.max(0, dropletHistory.length - 1)}\r\n              value={currentTimepoint}\r\n              onChange={(e) => jumpToTimepoint(Number(e.target.value))}\r\n              disabled={isSimulationRunning}\r\n              style={styles.timeSlider}\r\n              className=\"time-slider\" // Add this className\r\n            />\r\n            {displayTimelineDropletInfo && (\r\n              <div style={{ display: 'flex', gap: '10px', flexWrap: 'wrap' }}>\r\n                {dropletHistory.length > 0 && dropletHistory[currentTimepoint]?.droplets.map((droplet, index) => (\r\n                  <div key={droplet.id} style={styles.dropletInfo}>\r\n                    <div>Droplet {index + 1}:</div>\r\n                    {droplet.frontNextNodeID && (\r\n                      <div>Front → {graphData.nodes.find(n => n.id === droplet.frontNextNodeID)?.label || droplet.frontNextNodeID}</div>\r\n                    )}\r\n                    {droplet.rearNextNodeID && (\r\n                      <div>Rear → {graphData.nodes.find(n => n.id === droplet.rearNextNodeID)?.label || droplet.rearNextNodeID}</div>\r\n                    )}\r\n                  </div>\r\n                ))}\r\n              </div>\r\n            )}\r\n          </div>\r\n\r\n          <div style={styles.timeStepButtons}>\r\n            <button\r\n              onClick={() => jumpToTimepoint(0)}\r\n              disabled={currentTimepoint === 0 || isSimulationRunning}\r\n              style={{ ...buttonVariants.secondaryButton, padding: '4px 8px' }}\r\n            >\r\n              ⏮️ Start\r\n            </button>\r\n            <button\r\n              onClick={() => jumpToTimepoint(currentTimepoint - 1)}\r\n              disabled={currentTimepoint === 0 || isSimulationRunning}\r\n              style={{ ...buttonVariants.secondaryButton, padding: '4px 8px' }}\r\n            >\r\n              ⏪ Previous\r\n            </button>\r\n            <button\r\n              onClick={() => jumpToTimepoint(currentTimepoint + 1)}\r\n              disabled={currentTimepoint >= dropletHistory.length - 1 || isSimulationRunning}\r\n              style={{ ...buttonVariants.secondaryButton, padding: '4px 8px' }}\r\n            >\r\n              Next ⏩\r\n            </button>\r\n            <button\r\n              onClick={() => jumpToTimepoint(dropletHistory.length - 1)}\r\n              disabled={currentTimepoint >= dropletHistory.length - 1 || isSimulationRunning}\r\n              style={{ ...buttonVariants.secondaryButton, padding: '4px 8px' }}\r\n            >\r\n              End ⏭️\r\n            </button>\r\n          </div>\r\n\r\n          <div style={styles.timeScaleContainer}>\r\n            <label style={{ color: '#fff', marginRight: '10px' }}>\r\n              Time Scale:\r\n              <select\r\n                value={timeScale}\r\n                onChange={(e) => setTimeScale(Number(e.target.value))}\r\n                style={styles.timeInput}\r\n              >\r\n                <option value={0.0625}>1/16x</option>\r\n                <option value={0.25}>1/4x</option>\r\n                <option value={1}>1x</option>\r\n                <option value={4}>4x</option>\r\n                <option value={16}>16x</option>\r\n                <option value={64}>64x</option>\r\n                <option value={256}>256x</option>\r\n                <option value={1024}>1024x</option>\r\n              </select>\r\n            </label>\r\n            <label style={{ color: '#fff', marginRight: '10px' }}>\r\n              Current Time: {currentTime.toFixed(2)}s\r\n            </label>\r\n            <label style={{ color: '#fff' }}>\r\n              Step: {currentTimepoint + 1}/{dropletHistory.length}\r\n            </label>\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      <div style={styles.buttonGroup}>\r\n        <button \r\n          onClick={isSimulationRunning ? stopSimulation : startSimulation} \r\n          style={{ ...buttonVariants.primaryButton }}\r\n        >\r\n          {isSimulationRunning ? 'Stop Simulation' : 'Start Simulation'}\r\n        </button>\r\n        <button \r\n          onClick={restartSimulation} \r\n          style={{ ...buttonVariants.secondaryButton }}\r\n        >\r\n          Restart simulation\r\n        </button>\r\n        <button \r\n          onClick={sendingEventsToDevices} \r\n          style={{ ...buttonVariants.primaryButton }}\r\n        >\r\n          Send Events to Devices\r\n        </button>\r\n        <div ref={displayMenuRef} style={{ position: 'relative', display: 'inline-block' }}>\r\n          <button \r\n            onClick={toggleDisplayMenu} \r\n            style={styles.displayMenuButton}\r\n          >\r\n            Display Settings\r\n          </button>\r\n          {isDisplayMenuOpen && (\r\n            <div style={styles.displayMenu}>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={toggleNodeIds}\r\n              >\r\n                <span>Show Node IDs</span>\r\n                <span style={styles.checkmark}>{displayNodeIds ? '✓' : ''}</span>\r\n              </div>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={toggleDropletInfo}\r\n              >\r\n                <span>Show Droplet Info</span>\r\n                <span style={styles.checkmark}>{displayDropletInfo ? '✓' : ''}</span>\r\n              </div>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={toggleDropletGaps}\r\n              >\r\n                <span>Show Droplet Gaps</span>\r\n                <span style={styles.checkmark}>{displayDropletGaps ? '✓' : ''}</span>\r\n              </div>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={toggleEdgeLabels}\r\n              >\r\n                <span>Show Tube Dimensions</span>\r\n                <span style={styles.checkmark}>{displayEdgeLabels ? '✓' : ''}</span>\r\n              </div>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={togglePumpSpeeds}\r\n              >\r\n                <span>Show Pump Speeds</span>\r\n                <span style={styles.checkmark}>{displayPumpSpeeds ? '✓' : ''}</span>\r\n              </div>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={toggleTimelineDropletInfo}\r\n              >\r\n                <span>Show Timeline Droplet Info</span>\r\n                <span style={styles.checkmark}>{displayTimelineDropletInfo ? '✓' : ''}</span>\r\n              </div>\r\n            </div>\r\n          )}\r\n        </div>\r\n      </div>\r\n\r\n      {/* Rest of the SVG rendering code */}\r\n      {graphData.nodes.length > 0 && (\r\n        <div style={styles.svgContainer}>\r\n          <svg width=\"2000\" height=\"400\">\r\n            {/* Render edges first (background) */}\r\n            {graphData.links.map((link, index) => {\r\n              const sourceNode = graphData.nodes.find(node => node.id === link.source);\r\n              const targetNode = graphData.nodes.find(node => node.id === link.target);\r\n              if (!sourceNode || !targetNode) return null;\r\n              \r\n              const midX = (sourceNode.x + targetNode.x) / 2;\r\n              const midY = (sourceNode.y + targetNode.y) / 2;\r\n              \r\n              return (\r\n                <g key={`edge-${index}`}>\r\n                  <line\r\n                    x1={sourceNode.x}\r\n                    y1={sourceNode.y}\r\n                    x2={targetNode.x}\r\n                    y2={targetNode.y}\r\n                    stroke=\"#999\"\r\n                    strokeWidth={2}\r\n                  />\r\n                  <text\r\n                    x={midX}\r\n                    y={midY - 20}\r\n                    textAnchor=\"middle\"\r\n                    fill=\"#fff\"\r\n                    fontSize=\"12px\"\r\n                    style={{ display: displayEdgeLabels ? 'block' : 'none' }}\r\n                  >\r\n                    {`${link.length} mm (Ø ${link.diameter} mm)`}\r\n                  </text>\r\n                </g>\r\n              );\r\n            })}\r\n\r\n            {/* Render nodes (on top) */}\r\n            {graphData.nodes.map((node, index) => (\r\n              <g key={`node-${index}`}>\r\n                <circle\r\n                  cx={node.x}\r\n                  cy={node.y}\r\n                  r={15}\r\n                  fill={getNodeColor(node)}\r\n                  stroke={selectedNode && selectedNode.id === node.id ? '#FFA500' : 'none'}\r\n                  strokeWidth={selectedNode && selectedNode.id === node.id ? '3' : '0'}\r\n                  onClick={() => handleNodeClick(node)}\r\n                  style={{ cursor: 'pointer' }}\r\n                />\r\n                <text\r\n                  x={node.x}\r\n                  y={node.y - 25}\r\n                  textAnchor=\"middle\"\r\n                  fill=\"#fff\"\r\n                  fontSize=\"12px\"\r\n                >\r\n                  {node.label}\r\n                </text>\r\n                <text\r\n                  x={node.x}\r\n                  y={node.y - 10}\r\n                  textAnchor=\"middle\"\r\n                  fill=\"#fff\"\r\n                  fontSize=\"10px\"\r\n                  style={{ display: displayNodeIds ? 'block' : 'none' }}\r\n                >\r\n                  {`ID: ${node.id}`}\r\n                </text>\r\n              </g>\r\n            ))}\r\n\r\n            {/* Render droplets and distances between them */}\r\n            {interpolateDropletState(currentTime).map((droplet, index, droplets) => {\r\n              const frontX = volumetricToXPosition(droplet.frontVolumetricPosition);\r\n              const rearX = volumetricToXPosition(droplet.rearVolumetricPosition);\r\n              const centerX = (frontX + rearX) / 2;\r\n              \r\n              // Calculate distance to next droplet if this isn't the last droplet\r\n              const distanceInfo = index < droplets.length - 1 ? {\r\n                nextDropletFront: droplets[index + 1].frontVolumetricPosition,\r\n                distance: Math.abs(droplets[index + 1].frontVolumetricPosition - droplet.rearVolumetricPosition)\r\n              } : null;\r\n              \r\n              // Calculate midpoint for distance label\r\n              const distanceLabelX = distanceInfo ? \r\n                (volumetricToXPosition(droplet.rearVolumetricPosition) + \r\n                 volumetricToXPosition(distanceInfo.nextDropletFront)) / 2 : null;\r\n\r\n              return (\r\n                <g key={`droplet-${droplet.id}`}>\r\n                  {/* Droplet body */}\r\n                  <line\r\n                    x1={rearX}\r\n                    y1={300}\r\n                    x2={frontX}\r\n                    y2={300}\r\n                    stroke=\"rgba(255, 100, 100, 0.9)\"\r\n                    strokeWidth={8}\r\n                    strokeLinecap=\"butt\"\r\n                  />\r\n                  \r\n                  {/* Distance to next droplet */}\r\n                  {distanceInfo && displayDropletGaps && (\r\n                    <g>\r\n                      {/* Distance line */}\r\n                      <line\r\n                        x1={rearX}\r\n                        y1={320}\r\n                        x2={volumetricToXPosition(distanceInfo.nextDropletFront)}\r\n                        y2={320}\r\n                        stroke=\"#fff\"\r\n                        strokeWidth={1}\r\n                        strokeDasharray=\"5,5\"\r\n                      />\r\n                      {/* Distance arrows */}\r\n                      <line\r\n                        x1={rearX}\r\n                        y1={315}\r\n                        x2={rearX}\r\n                        y2={325}\r\n                        stroke=\"#fff\"\r\n                        strokeWidth={1}\r\n                      />\r\n                      <line\r\n                        x1={volumetricToXPosition(distanceInfo.nextDropletFront)}\r\n                        y1={315}\r\n                        x2={volumetricToXPosition(distanceInfo.nextDropletFront)}\r\n                        y2={325}\r\n                        stroke=\"#666\"\r\n                        strokeWidth={1}\r\n                      />\r\n                      {/* Distance label */}\r\n                      <text\r\n                        x={distanceLabelX}\r\n                        y={335}\r\n                        textAnchor=\"middle\"\r\n                        fill=\"#666\"\r\n                        fontSize=\"12px\"\r\n                      >\r\n                        {`${distanceInfo.distance.toFixed(2)} μL`}\r\n                      </text>\r\n                    </g>\r\n                  )}\r\n                  \r\n                  {/* Droplet info - wrap all info texts in conditional rendering */}\r\n                  {displayDropletInfo && (\r\n                    <>\r\n                      <text\r\n                        x={centerX}\r\n                        y={270}\r\n                        textAnchor=\"middle\"\r\n                        fill=\"#6f6\"\r\n                        fontSize=\"12px\"\r\n                      >\r\n                        {`Vol: ${(droplet.frontVolumetricPosition-droplet.rearVolumetricPosition).toFixed(2)} μL`}\r\n                      </text>\r\n                      <text\r\n                        x={centerX}\r\n                        y={255}\r\n                        textAnchor=\"middle\"\r\n                        fill=\"#6f6\"\r\n                        fontSize=\"12px\"\r\n                      >\r\n                        {`Spd f: ${droplet.frontVolumetricSpeed.toFixed(2)} μL/s`}\r\n                      </text>\r\n                      <text\r\n                        x={centerX}\r\n                        y={240}\r\n                        textAnchor=\"middle\"\r\n                        fill=\"#6f6\"\r\n                        fontSize=\"12px\"\r\n                      >\r\n                        {`Spd r: ${droplet.rearVolumetricSpeed.toFixed(2)} μL/s`}\r\n                      </text>\r\n                      <text\r\n                        x={centerX}\r\n                        y={225}\r\n                        textAnchor=\"middle\"\r\n                        fill=\"#6f6\"\r\n                        fontSize=\"12px\"\r\n                      >\r\n                        {`mlt: ${droplet.pumpSpeedMultiplier.toFixed(2)}`}\r\n                      </text>\r\n                    </>\r\n                  )}\r\n                </g>\r\n              );\r\n            })}\r\n\r\n            {displayPumpSpeeds && graphData.nodes.map((node, index) => {\r\n              if (node.type === 'pump') {\r\n                const currentSpeed = getPumpSpeedAtTime(node.id, pumpEvents, currentTime);\r\n                const maxTime = dropletHistory[dropletHistory.length - 1]?.time || 1;\r\n                const pumpSpecificEvents = pumpEvents.filter(event => event.target === node.id);\r\n                \r\n                return (\r\n                  <g key={`pump-speed-${node.id}`}>\r\n                    {/* Current pump speed value */}\r\n                    <text\r\n                      x={node.x}\r\n                      y={node.y - 35}\r\n                      textAnchor=\"middle\"\r\n                      fill=\"#4CAF50\"\r\n                      fontSize=\"12px\"\r\n                    >\r\n                      {`${currentSpeed.toFixed(2)} μL/s`}\r\n                    </text>\r\n                    \r\n                    {/* Speed history visualization */}\r\n                    <g transform={`translate(${node.x - 40}, ${node.y - 65})`}>\r\n                      {pumpSpecificEvents.map((event, i, arr) => {\r\n                        const nextEvent = arr[i + 1];\r\n                        const width = 80;\r\n                        const x = 0;\r\n                        const y = 0;\r\n                        \r\n                        // Calculate position based on time\r\n                        const timePosition = (event.time / maxTime) * width;\r\n                        const nextTimePosition = nextEvent \r\n                          ? (nextEvent.time / maxTime) * width\r\n                          : width;\r\n                        \r\n                        // Calculate height based on speed value (normalized)\r\n                        const maxSpeed = Math.max(...pumpSpecificEvents.map(e => e.value));\r\n                        const normalizedHeight = event.value / (maxSpeed || 1) * 20;\r\n                        \r\n                        return (\r\n                          <g key={`pump-event-${i}`}>\r\n                            {/* Speed segment */}\r\n                            <line\r\n                              x1={x + timePosition}\r\n                              y1={y - normalizedHeight}\r\n                              x2={x + nextTimePosition}\r\n                              y2={y - normalizedHeight}\r\n                              stroke=\"#4CAF50\"\r\n                              strokeWidth={2}\r\n                            />\r\n                            {/* Event point */}\r\n                            <circle\r\n                              cx={x + timePosition}\r\n                              cy={y - normalizedHeight}\r\n                              r={2}\r\n                              fill=\"#4CAF50\"\r\n                            />\r\n                            {/* Time marker */}\r\n                            <text\r\n                              x={x + timePosition}\r\n                              y={y + 12}\r\n                              textAnchor=\"middle\"\r\n                              fill=\"#666\"\r\n                              fontSize=\"10px\"\r\n                            >\r\n                              {event.time.toFixed(1)}s\r\n                            </text>\r\n                            {/* Speed value */}\r\n                            <text\r\n                              x={x + timePosition}\r\n                              y={y - normalizedHeight - 5}\r\n                              textAnchor=\"middle\"\r\n                              fill=\"#4CAF50\"\r\n                              fontSize=\"8px\"\r\n                            >\r\n                              {event.value.toFixed(1)}\r\n                            </text>\r\n                          </g>\r\n                        );\r\n                      })}\r\n                      {/* Current time indicator */}\r\n                      <line\r\n                        x1={(currentTime / maxTime) * 80}\r\n                        y1={-25}\r\n                        x2={(currentTime / maxTime) * 80}\r\n                        y2={15}\r\n                        stroke=\"red\"\r\n                        strokeWidth={1}\r\n                        strokeDasharray=\"2,2\"\r\n                      />\r\n                    </g>\r\n                  </g>\r\n                );\r\n              }\r\n              return null;\r\n            })}\r\n          </svg>\r\n        </div>\r\n      )}\r\n      \r\n      {selectedNode && (selectedNode.type === 'pump' || selectedNode.data?.type === 'pump') && (\r\n        <DraggablePanel \r\n          initialPosition={pumpPanelPosition}\r\n          title={`Pump Controls - ${selectedNode.label || selectedNode.id}`}\r\n        >\r\n          <PumpActions\r\n            node={selectedNode}\r\n            nodes={nodes}\r\n            edges={edges}\r\n            onAction={handleNodeAction}\r\n          />\r\n        </DraggablePanel>\r\n      )}\r\n      {selectedNode && (selectedNode.type === 'USBSpectrometer' || selectedNode.data?.type === 'USBSpectrometer') && (\r\n        <>\r\n          {console.log('Rendering USBSpectrometer component for node:', selectedNode)}\r\n          <USBSpectrometer\r\n            detector={selectedNode}\r\n            detectorId={selectedNode.id}\r\n            detectorName={selectedNode.label || selectedNode.id}\r\n            onClose={() => setSelectedNode(null)}\r\n            initialPosition={{ x: 150, y: 100 }}\r\n            isVisible={true}\r\n          />\r\n        </>\r\n      )}\r\n      {selectedNode && (selectedNode.type === 'MQTTSpectrometer' || selectedNode.data?.type === 'MQTTSpectrometer') && (\r\n        <>\r\n          {console.log('Rendering SpectrometerMQTT component for node:', selectedNode)}\r\n          <SpectrometerMQTT\r\n            detector={selectedNode}\r\n            detectorId={selectedNode.id}\r\n            detectorName={selectedNode.label || selectedNode.id}\r\n            onClose={() => setSelectedNode(null)}\r\n            initialPosition={{ x: 150, y: 100 }}\r\n            isVisible={true}\r\n          />\r\n        </>\r\n      )}\r\n      {/* Add styles for PumpActions */}\r\n      <style>\r\n        {`\r\n          .node-actions {\r\n            position: fixed;\r\n            top: 20px;\r\n            right: 20px;\r\n            background: black;\r\n            padding: 20px;\r\n            border: 1px solid #ccc;\r\n            border-radius: 5px;\r\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\r\n          }\r\n          .node-actions h3 {\r\n            margin: 0 0 15px 0;\r\n            color: #333;\r\n          }\r\n          .node-actions button {\r\n            margin: 5px;\r\n            padding: 8px 16px;\r\n            background: #4CAF50;\r\n            color: white;\r\n            border: none;\r\n            border-radius: 4px;\r\n            cursor: pointer;\r\n          }\r\n          .node-actions button:disabled {\r\n            background: #ccc;\r\n            cursor: not-allowed;\r\n          }\r\n          .node-actions input {\r\n            margin: 5px;\r\n            padding: 8px;\r\n            border: 1px solid #ccc;\r\n            border-radius: 4px;\r\n            width: 80px;\r\n          }\r\n          .move-controls {\r\n            display: flex;\r\n            flex-direction: column;\r\n            gap: 10px;\r\n            margin-top: 10px;\r\n          }\r\n          .input-group {\r\n            display: flex;\r\n            align-items: center;\r\n            gap: 10px;\r\n          }\r\n          .input-group label {\r\n            min-width: 100px;\r\n            text-align: right;\r\n            color: #666;\r\n          }\r\n        `}\r\n      </style>\r\n      {overlayComponent && (\r\n        <div style={{\r\n          position: 'fixed',\r\n          top: 0,\r\n          left: 0,\r\n          right: 0,\r\n          bottom: 0,\r\n          zIndex: 9999,\r\n          pointerEvents: 'none'\r\n        }}>\r\n          <Suspense fallback={\r\n            <div style={{\r\n              position: 'fixed',\r\n              top: '50%',\r\n              left: '50%',\r\n              transform: 'translate(-50%, -50%)',\r\n              background: 'rgba(0,0,0,0.8)',\r\n              padding: '20px',\r\n              borderRadius: '8px',\r\n              color: 'white',\r\n              pointerEvents: 'auto'\r\n            }}>\r\n              <h2>Loading Component...</h2>\r\n            </div>\r\n          }>\r\n            {overlayComponent.type === 'USBSpectrometer' && (\r\n              <div style={{ pointerEvents: 'auto' }}>\r\n                <USBSpectrometer {...overlayComponent.props} />\r\n              </div>\r\n            )}\r\n            {overlayComponent.type === 'MQTTSpectrometer' && (\r\n              <div style={{ pointerEvents: 'auto' }}>\r\n                <SpectrometerMQTT \r\n                  {...overlayComponent.props} \r\n                  graphRef={graphRefs.current[overlayComponent.props.detector.id]}\r\n                />\r\n              </div>\r\n            )}\r\n            {overlayComponent.type === 'PumpPanel' && (\r\n              <div style={{ pointerEvents: 'auto' }}>\r\n                <PumpPanel {...overlayComponent.props} />\r\n              </div>\r\n            )}\r\n          </Suspense>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Simulation;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}