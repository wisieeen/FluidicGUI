{"ast":null,"code":"var _jsxFileName = \"E:\\\\flow chemistry\\\\fluidicGUI\\\\frontend\\\\fluidicgui\\\\src\\\\components\\\\Simulation\\\\SpectrometerMQTT.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useRef, useEffect } from 'react';\nimport DraggablePanel from './DraggablePanel';\nimport { useButtonStyles } from '../../styles/ButtonStyleProvider';\nimport { backgroundVariants } from '../../styles/backgroundStyles';\nimport styles from './styles/USBSpectrometerStyles';\nimport { WS_URL } from '../../config'; // Import WS_URL\nimport spectralConfig from './SpectrometerMQTT/spectral_config.json'; // Import spectral config\n\n// Import subcomponents\nimport MQTTCameraComponent from './SpectrometerMQTT/MQTTCameraComponent';\nimport MQTTGraphComponent from './SpectrometerMQTT/MQTTGraphComponent';\nimport MQTTWaterfallComponent from './SpectrometerMQTT/MQTTWaterfallComponent';\nimport MQTTSettingsComponent from './SpectrometerMQTT/MQTTSettingsComponent';\n\n// Add MQTT-specific styles to complement the existing styles\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst mqttStyles = {\n  cameraSettings: {\n    marginTop: '10px',\n    padding: '8px',\n    backgroundColor: 'rgba(0, 0, 0, 0.3)',\n    borderRadius: '4px'\n  },\n  mqttInputs: {\n    display: 'flex',\n    alignItems: 'center',\n    marginBottom: '8px'\n  },\n  inputLabel: {\n    width: '90px',\n    color: '#ccc',\n    fontSize: '14px'\n  },\n  input: {\n    flex: 1,\n    backgroundColor: 'rgba(60, 60, 60, 0.7)',\n    border: '1px solid rgba(100, 100, 100, 0.5)',\n    borderRadius: '4px',\n    padding: '4px 8px',\n    color: 'white',\n    fontSize: '14px'\n  }\n};\n\n// Available waterfall color schemes\nconst waterfallColorSchemeOptions = {\n  grayscale: 'Grayscale',\n  viridis: 'Viridis',\n  plasma: 'Plasma',\n  inferno: 'Inferno',\n  cividis: 'Cividis',\n  turbo: 'Turbo'\n};\nconst SpectrometerMQTT = ({\n  detector,\n  readings = [],\n  onClose,\n  initialPosition = {\n    x: 150,\n    y: 100\n  },\n  detectorId,\n  detectorName,\n  isVisible,\n  position,\n  onMove,\n  onResize,\n  detectorStatus\n}) => {\n  _s();\n  const buttonVariants = useButtonStyles();\n  const [detectorReadings, setDetectorReadings] = useState([]);\n\n  // Panel resizing state\n  const [panelSize, setPanelSize] = useState({\n    width: 1100,\n    height: 750\n  });\n  const [isResizingPanel, setIsResizingPanel] = useState(false);\n  const panelRef = useRef(null);\n\n  // Add state for resize feedback\n  const [showResizeInfo, setShowResizeInfo] = useState(false);\n\n  // Subcomponent visibility toggles\n  const [showCamera, setShowCamera] = useState(true);\n  const [showGraph, setShowGraph] = useState(true);\n  const [showWaterfall, setShowWaterfall] = useState(false);\n  const [showSettings, setShowSettings] = useState(false);\n\n  // Data state - replace lineData with spectrumData\n  const [spectrumData, setSpectrumData] = useState(null); // Data from spectrometer\n  const [processedData, setProcessedData] = useState(null); // Data from crop processing\n\n  // Track if we're currently using processed crop data\n  const [usingCropData, setUsingCropData] = useState(false);\n\n  // Add sensitivity factors lookup table\n  const [sensitivityFactorsLookup, setSensitivityFactorsLookup] = useState(null);\n\n  // Save/load settings state\n  const [saveMessage, setSaveMessage] = useState('');\n  const [cameraSettings, setCameraSettings] = useState(null);\n  const [calibrationSettings, setCalibrationSettings] = useState(null);\n\n  // Frame accumulation state (shared between Graph and Waterfall)\n  const [frameAccumCount, setFrameAccumCount] = useState(10);\n  const [isAccumulating, setIsAccumulating] = useState(true);\n\n  // Waterfall color scheme state\n  const [waterfallColorScheme, setWaterfallColorScheme] = useState('cividis');\n  const [showWaterfallColorMenu, setShowWaterfallColorMenu] = useState(false);\n\n  // References to component methods\n  const wsRef = useRef(null); // Ref to hold the WebSocket instance\n  const mqttTopicRef = useRef('spectrometer_1'); // Ref to hold the current MQTT topic\n  const cameraRef = useRef(null);\n  const graphRef = useRef(null);\n\n  // Handle frame accumulation change\n  const handleFrameAccumCountChange = count => {\n    setFrameAccumCount(count);\n  };\n\n  // Handle accumulation mode toggle\n  const handleAccumulationToggle = isActive => {\n    setIsAccumulating(isActive);\n  };\n\n  // Handle waterfall color scheme change\n  const handleWaterfallColorSchemeChange = scheme => {\n    setWaterfallColorScheme(scheme);\n    setShowWaterfallColorMenu(false);\n  };\n\n  // Process readings when they change\n  useEffect(() => {\n    var _detector$data;\n    if (readings && readings.length > 0 && detector !== null && detector !== void 0 && (_detector$data = detector.data) !== null && _detector$data !== void 0 && _detector$data.properties) {\n      // Process readings here\n      setDetectorReadings(readings);\n    }\n  }, [readings, detector]);\n\n  // Effect for WebSocket connection and message handling\n  useEffect(() => {\n    if (!detectorId) return; // Need detectorId to form topic\n\n    const mainDataTopic = `${detectorId}/response/data`; // Default data topic\n    mqttTopicRef.current = mainDataTopic;\n\n    // Flag to track if the component is still mounted\n    let isMounted = true;\n    console.log('[SpectrometerMQTT] Connecting WebSocket...', WS_URL);\n    const newWs = new WebSocket(WS_URL);\n    wsRef.current = newWs;\n    newWs.onopen = () => {\n      // Check if the component is still mounted and connection wasn't closed\n      if (!isMounted || newWs.readyState !== WebSocket.OPEN) {\n        console.log('[SpectrometerMQTT] WebSocket connected but component unmounted or connection closed');\n        return;\n      }\n      console.log('[SpectrometerMQTT] WebSocket connected');\n      try {\n        // Subscribe to the data topic\n        const subscribeData = {\n          topic: \"common/subscribe\",\n          payload: mainDataTopic\n        };\n\n        // Make sure WebSocket is still valid before sending\n        if (newWs && newWs.readyState === WebSocket.OPEN) {\n          newWs.send(JSON.stringify(subscribeData));\n          console.log(`[SpectrometerMQTT] Subscribed to: ${mainDataTopic}`);\n        } else {\n          console.warn('[SpectrometerMQTT] Cannot subscribe: WebSocket not available or not open');\n        }\n      } catch (err) {\n        console.error('[SpectrometerMQTT] Error in onopen handler:', err);\n      }\n    };\n    newWs.onmessage = event => {\n      if (!isMounted) return;\n      try {\n        const data = JSON.parse(event.data);\n\n        // Check if the message is on the subscribed data topic\n        if (data.topic === mqttTopicRef.current) {\n          let parsedPayload = null;\n          if (data.payload && typeof data.payload === 'string') {\n            try {\n              parsedPayload = JSON.parse(data.payload);\n            } catch (e) {/* Ignore if not JSON */}\n          } else if (data.payload && typeof data.payload === 'object') {\n            parsedPayload = data.payload;\n          }\n\n          // Check if payload contains spectral data\n          if (parsedPayload) {\n            // Check if this is processed graph data (from crop)\n            if (parsedPayload.red && parsedPayload.green && parsedPayload.blue && parsedPayload.intensities) {\n              console.log('[SpectrometerMQTT] Received processed graph data from crop');\n\n              // Transform data to expected format for the graph\n              const graphData = {\n                pixelData: {\n                  timestamp: parsedPayload.timestamp,\n                  positions: parsedPayload.wavelengths,\n                  red: parsedPayload.red,\n                  green: parsedPayload.green,\n                  blue: parsedPayload.blue,\n                  intensity: parsedPayload.intensities,\n                  lineLength: parsedPayload.wavelengths.length\n                }\n              };\n              setProcessedData(graphData);\n              setUsingCropData(true); // Flag that we're using crop data\n            } else if (parsedPayload.red && parsedPayload.green && parsedPayload.blue) {\n              console.log('[SpectrometerMQTT] Received processed graph data from crop');\n\n              // Get calibration data from graph component if available\n              let minWavelength = 450; // Default min wavelength\n              let maxWavelength = 650; // Default max wavelength\n\n              // Try to use calibration points from graph component if it exists\n              if (graphRef.current && graphRef.current.getCalibrationSettings) {\n                const calibrationSettings = graphRef.current.getCalibrationSettings();\n                if (calibrationSettings.calibrationPoints && calibrationSettings.calibrationPoints.length >= 2) {\n                  const calibrationPoint1Position = calibrationSettings.calibrationPoints[0].position;\n                  const calibrationPoint2Position = calibrationSettings.calibrationPoints[1].position;\n                  const calibrationPoint1Wavelength = calibrationSettings.calibrationPoints[0].wavelength;\n                  const calibrationPoint2Wavelength = calibrationSettings.calibrationPoints[1].wavelength;\n                  // Get wavelengths from calibration points\n                  const wavelengthPerPosition = (calibrationPoint2Wavelength - calibrationPoint1Wavelength) / (calibrationPoint2Position - calibrationPoint1Position);\n                  minWavelength = calibrationPoint1Wavelength - calibrationPoint1Position * wavelengthPerPosition;\n                  maxWavelength = calibrationPoint2Wavelength + (1 - calibrationPoint2Position) * wavelengthPerPosition;\n                  console.log('[SpectrometerMQTT] Calibration settings:', calibrationSettings);\n\n                  // Create lookup table for sensitivity factors based on calibration\n                  // This is more efficient than searching for closest matches for every point in every frame\n                  const wavelengthKeys = Object.keys(spectralConfig.SENSITIVITY_FACTORS).map(key => parseFloat(key));\n                  const wavelengthRange = maxWavelength - minWavelength;\n                  const dataLength = parsedPayload.wavelengths.length;\n\n                  // Create an array of the same length as wavelengths with the pre-computed closest sensitivity factor\n                  const lookup = new Array(dataLength);\n                  for (let i = 0; i < dataLength; i++) {\n                    // Scale position to calibrated wavelength range\n                    const scaledPosition = i / (dataLength - 1);\n                    const mappedWavelength = minWavelength + scaledPosition * wavelengthRange;\n\n                    // Find closest sensitivity factor (only done once per calibration)\n                    let closestWavelength = wavelengthKeys[0];\n                    let minDiff = Math.abs(mappedWavelength - closestWavelength);\n                    for (let j = 1; j < wavelengthKeys.length; j++) {\n                      const diff = Math.abs(mappedWavelength - wavelengthKeys[j]);\n                      if (diff < minDiff) {\n                        minDiff = diff;\n                        closestWavelength = wavelengthKeys[j];\n                      }\n                    }\n\n                    // Store the sensitivity factor directly in the lookup table\n                    lookup[i] = spectralConfig.SENSITIVITY_FACTORS[closestWavelength.toString()];\n                  }\n\n                  // Save the lookup table for future use\n                  setSensitivityFactorsLookup(lookup);\n                }\n              }\n\n              // Define channel wavelength ranges from spectral_config.json\n              const CHANNEL_RANGES = spectralConfig.CHANNEL_RANGES;\n\n              // Map wavelengths to fit exactly within minWavelength and maxWavelength range\n              const mappedWavelengths = parsedPayload.wavelengths.map(w => {\n                // Scale the wavelength to fit in the calibrated range\n                return minWavelength + (w - parsedPayload.wavelengths[0]) / (parsedPayload.wavelengths[parsedPayload.wavelengths.length - 1] - parsedPayload.wavelengths[0]) * (maxWavelength - minWavelength);\n              });\n\n              // Calculate intensity by selecting the appropriate channel based on mapped wavelength\n              const intensity = mappedWavelengths.map((wavelength, idx) => {\n                // Determine which channel to use based on wavelength\n                if (wavelength >= CHANNEL_RANGES.b[0] && wavelength < CHANNEL_RANGES.b[1]) {\n                  return parsedPayload.blue[idx]; // Blue channel\n                } else if (wavelength >= CHANNEL_RANGES.g[0] && wavelength < CHANNEL_RANGES.g[1]) {\n                  return parsedPayload.green[idx]; // Green channel\n                } else if (wavelength >= CHANNEL_RANGES.r[0] && wavelength <= CHANNEL_RANGES.r[1]) {\n                  return parsedPayload.red[idx]; // Red channel\n                } else {\n                  // Fallback to average if outside defined ranges\n                  return (parsedPayload.red[idx] + parsedPayload.green[idx] + parsedPayload.blue[idx]) / 3;\n                }\n              });\n\n              // Apply sensitivity correction using pre-computed lookup table\n              let correctedIntensity;\n              if (sensitivityFactorsLookup && sensitivityFactorsLookup.length === intensity.length) {\n                // Fast path: use pre-computed lookup table\n                correctedIntensity = intensity.map((value, idx) => value / sensitivityFactorsLookup[idx]);\n              } else {\n                // Try to rebuild the lookup table if it doesn't exist or doesn't match the data length\n                try {\n                  console.log('[SpectrometerMQTT] Rebuilding sensitivity factors lookup table...');\n\n                  // Get calibration data from graph component if available\n                  let minWavelength = 450; // Default min wavelength\n                  let maxWavelength = 650; // Default max wavelength\n\n                  if (graphRef.current && graphRef.current.getCalibrationSettings) {\n                    const calibrationSettings = graphRef.current.getCalibrationSettings();\n                    if (calibrationSettings.calibrationPoints && calibrationSettings.calibrationPoints.length >= 2) {\n                      const calibrationPoint1Position = calibrationSettings.calibrationPoints[0].position;\n                      const calibrationPoint2Position = calibrationSettings.calibrationPoints[1].position;\n                      const calibrationPoint1Wavelength = calibrationSettings.calibrationPoints[0].wavelength;\n                      const calibrationPoint2Wavelength = calibrationSettings.calibrationPoints[1].wavelength;\n                      // Get wavelengths from calibration points\n                      const wavelengthPerPosition = (calibrationPoint2Wavelength - calibrationPoint1Wavelength) / (calibrationPoint2Position - calibrationPoint1Position);\n                      minWavelength = calibrationPoint1Wavelength - calibrationPoint1Position * wavelengthPerPosition;\n                      maxWavelength = calibrationPoint2Wavelength + (1 - calibrationPoint2Position) * wavelengthPerPosition;\n                    }\n                  }\n\n                  // Create lookup table with current data length\n                  const dataLength = intensity.length;\n                  const wavelengthKeys = Object.keys(spectralConfig.SENSITIVITY_FACTORS).map(key => parseFloat(key));\n                  const wavelengthRange = maxWavelength - minWavelength;\n                  const newLookup = new Array(dataLength);\n                  for (let i = 0; i < dataLength; i++) {\n                    // Scale position to calibrated wavelength range\n                    const scaledPosition = i / (dataLength - 1);\n                    const mappedWavelength = minWavelength + scaledPosition * wavelengthRange;\n\n                    // Find closest sensitivity factor\n                    let closestWavelength = wavelengthKeys[0];\n                    let minDiff = Math.abs(mappedWavelength - closestWavelength);\n                    for (let j = 1; j < wavelengthKeys.length; j++) {\n                      const diff = Math.abs(mappedWavelength - wavelengthKeys[j]);\n                      if (diff < minDiff) {\n                        minDiff = diff;\n                        closestWavelength = wavelengthKeys[j];\n                      }\n                    }\n\n                    // Store the sensitivity factor\n                    newLookup[i] = spectralConfig.SENSITIVITY_FACTORS[closestWavelength.toString()];\n                  }\n\n                  // Update the lookup table state for future use\n                  setSensitivityFactorsLookup(newLookup);\n                  console.log('[SpectrometerMQTT] Rebuilt sensitivity factors lookup table with', newLookup.length, 'entries');\n\n                  // Use the newly created lookup table\n                  correctedIntensity = intensity.map((value, idx) => value / newLookup[idx]);\n                } catch (error) {\n                  // Fallback path if rebuilding fails\n                  console.error('[SpectrometerMQTT] Failed to rebuild sensitivity factors lookup table:', error);\n                  console.warn('[SpectrometerMQTT] Using uncorrected intensity values');\n                  correctedIntensity = intensity;\n                }\n              }\n\n              // Transform data to expected format for the graph\n              const graphData = {\n                pixelData: {\n                  timestamp: parsedPayload.timestamp,\n                  positions: parsedPayload.wavelengths,\n                  red: parsedPayload.red,\n                  green: parsedPayload.green,\n                  blue: parsedPayload.blue,\n                  intensity: correctedIntensity,\n                  lineLength: parsedPayload.wavelengths.length\n                }\n              };\n              setProcessedData(graphData);\n              setUsingCropData(true); // Flag that we're using crop data\n            }\n\n            // Check if this has raw data from crop\n            else if (parsedPayload.raw_data) {\n              console.log('[SpectrometerMQTT] Received raw pixel data from crop');\n\n              // Process raw data based on data_type\n              if (parsedPayload.data_type === 'raw_mono') {\n                // Extract first row if raw_data is 2D array, otherwise use as is\n                const rawIntensity = Array.isArray(parsedPayload.raw_data[0]) ? parsedPayload.raw_data[0] : parsedPayload.raw_data;\n                const graphData = {\n                  pixelData: {\n                    timestamp: parsedPayload.timestamp,\n                    positions: parsedPayload.wavelengths,\n                    // Use raw data as the intensity values\n                    red: rawIntensity,\n                    green: rawIntensity,\n                    blue: rawIntensity,\n                    intensity: rawIntensity,\n                    lineLength: rawIntensity.length,\n                    isRawData: true,\n                    bitDepth: parsedPayload.bit_depth || 12,\n                    dataType: parsedPayload.data_type\n                  }\n                };\n                setProcessedData(graphData);\n                setUsingCropData(true);\n              }\n            }\n            // Check if this is raw spectral data (wavelengths + raw channels)\n            else if (parsedPayload.wavelengths && (parsedPayload.raw_data || parsedPayload.raw_red)) {\n              console.log('[SpectrometerMQTT] Received raw spectral data');\n              setSpectrumData(parsedPayload);\n\n              // Only switch to spectral data if we're not actively using crop data\n              if (!usingCropData) {\n                // Create graph data format for raw data\n                const graphData = {\n                  pixelData: {\n                    timestamp: parsedPayload.timestamp || Date.now(),\n                    positions: parsedPayload.wavelengths,\n                    isRawData: true,\n                    bitDepth: parsedPayload.bit_depth || 12,\n                    dataType: parsedPayload.data_type\n                  }\n                };\n\n                // Handle different raw data formats\n                if (parsedPayload.data_type === 'raw_mono' && parsedPayload.raw_data) {\n                  // For monochrome, use raw_data for all channels\n                  graphData.pixelData.red = parsedPayload.raw_data;\n                  graphData.pixelData.green = parsedPayload.raw_data;\n                  graphData.pixelData.blue = parsedPayload.raw_data;\n                  graphData.pixelData.intensity = parsedPayload.raw_data;\n                  graphData.pixelData.lineLength = parsedPayload.raw_data.length;\n                } else if ((parsedPayload.data_type === 'raw_rgb' || parsedPayload.data_type === 'raw_rgba') && parsedPayload.raw_red && parsedPayload.raw_green && parsedPayload.raw_blue) {\n                  // For RGB, use separate channels\n                  graphData.pixelData.red = parsedPayload.raw_red;\n                  graphData.pixelData.green = parsedPayload.raw_green;\n                  graphData.pixelData.blue = parsedPayload.raw_blue;\n                  // Calculate intensity as average of RGB channels\n                  const intensity = parsedPayload.red.map((val, idx) => (val + parsedPayload.green[idx] + parsedPayload.blue[idx]) / 3);\n                  graphData.pixelData.intensity = intensity;\n                  graphData.pixelData.lineLength = parsedPayload.raw_red.length;\n                }\n                setProcessedData(graphData);\n              }\n            }\n            // Legacy support for traditional spectral data (wavelengths + intensities)\n            else if (parsedPayload.wavelengths && parsedPayload.intensities) {\n              console.log('[SpectrometerMQTT] Received traditional spectral data');\n              setSpectrumData(parsedPayload);\n\n              // Only switch to spectral data if we're not actively using crop data\n              if (!usingCropData) {\n                // Normalize positions to 0-1 range\n                const wavelengthRange = [Math.min(...parsedPayload.wavelengths), Math.max(...parsedPayload.wavelengths)];\n                const positions = parsedPayload.wavelengths.map(w => (w - wavelengthRange[0]) / (wavelengthRange[1] - wavelengthRange[0]));\n\n                // Create uniform intensity arrays for RGB\n                const intensity = parsedPayload.intensities;\n\n                // Create graph data format\n                const graphData = {\n                  pixelData: {\n                    timestamp: parsedPayload.timestamp || Date.now(),\n                    positions: positions,\n                    red: intensity,\n                    green: intensity,\n                    blue: intensity,\n                    intensity: intensity,\n                    lineLength: intensity.length,\n                    isRawData: false\n                  }\n                };\n                setProcessedData(graphData);\n              }\n            } else if (parsedPayload.error) {\n              console.warn(`[SpectrometerMQTT] Received error from backend: ${parsedPayload.error}`);\n              // Don't clear data on error - just leave the previous data\n            } else {\n              console.warn('[SpectrometerMQTT] Received data message with unexpected payload:', parsedPayload);\n            }\n          }\n        }\n      } catch (error) {\n        console.error('[SpectrometerMQTT] Error processing WebSocket message:', error, 'Raw:', event.data);\n      }\n    };\n    newWs.onerror = error => {\n      if (!isMounted) return;\n      console.error('[SpectrometerMQTT] WebSocket error:', error);\n    };\n    newWs.onclose = event => {\n      if (!isMounted) return;\n      console.log('[SpectrometerMQTT] WebSocket closed:', event.code, event.reason);\n      if (wsRef.current === newWs) {\n        wsRef.current = null;\n      }\n      // Don't clear data on disconnect - just keep the last values\n    };\n\n    // Cleanup function\n    return () => {\n      isMounted = false;\n\n      // Store a reference to the current WebSocket\n      const ws = wsRef.current;\n\n      // Important: Set wsRef.current to null BEFORE closing\n      // This prevents race conditions with the onopen callback\n      wsRef.current = null;\n      if (ws) {\n        console.log('[SpectrometerMQTT] Closing WebSocket connection...');\n        try {\n          // Only close if it's still in a state that can be closed\n          if (ws.readyState === WebSocket.CONNECTING || ws.readyState === WebSocket.OPEN) {\n            ws.close();\n          }\n        } catch (err) {\n          console.error('[SpectrometerMQTT] Error closing WebSocket:', err);\n        }\n      }\n    };\n  }, [detectorId]); // Reconnect if detectorId changes\n\n  // Handle crop data toggle\n  const handleCropDataToggle = isEnabled => {\n    setUsingCropData(isEnabled);\n  };\n\n  // Save camera and calibration settings\n  const saveSettings = () => {\n    try {\n      var _cameraRef$current, _cameraRef$current2, _graphRef$current, _graphRef$current2, _graphRef$current2$ge;\n      // Get camera settings\n      const camSettings = (_cameraRef$current = cameraRef.current) === null || _cameraRef$current === void 0 ? void 0 : _cameraRef$current.getSettings();\n\n      // Get crop frame settings\n      const cropSettings = (_cameraRef$current2 = cameraRef.current) === null || _cameraRef$current2 === void 0 ? void 0 : _cameraRef$current2.getCropSettings();\n\n      // Get calibration settings from graph component\n      const calSettings = (_graphRef$current = graphRef.current) === null || _graphRef$current === void 0 ? void 0 : _graphRef$current.getCalibrationSettings();\n      if (!camSettings && !calSettings && !cropSettings) {\n        console.warn('No settings to save - components may not be mounted');\n        setSaveMessage('No settings to save');\n        setTimeout(() => setSaveMessage(''), 3000);\n        return;\n      }\n\n      // Create a settings object to save\n      const settings = {\n        camera: camSettings || null,\n        calibration: calSettings || null,\n        cropFrame: cropSettings || null,\n        timestamp: new Date().toISOString(),\n        detectorId: detectorId || 'default',\n        // Save waterfall settings\n        waterfall: {\n          colorScheme: waterfallColorScheme\n        },\n        // Save frame accumulation settings\n        frameAccumulation: {\n          count: frameAccumCount,\n          isEnabled: isAccumulating\n        },\n        // Save peak markers settings if available from graph component\n        peakMarkers: ((_graphRef$current2 = graphRef.current) === null || _graphRef$current2 === void 0 ? void 0 : (_graphRef$current2$ge = _graphRef$current2.getPeakSettings) === null || _graphRef$current2$ge === void 0 ? void 0 : _graphRef$current2$ge.call(_graphRef$current2)) || {\n          count: 3,\n          showMarkers: true\n        },\n        // Save component visibility states\n        visibilityState: {\n          camera: showCamera,\n          graph: showGraph,\n          waterfall: showWaterfall,\n          settings: showSettings\n        },\n        // Save crop data state\n        usingCropData: usingCropData\n      };\n\n      // Save to localStorage\n      localStorage.setItem(`detector_settings_${detectorId || 'default'}`, JSON.stringify(settings));\n\n      // Set save message for user feedback\n      setSaveMessage('Settings saved successfully');\n      setTimeout(() => setSaveMessage(''), 3000);\n    } catch (error) {\n      console.error('Failed to save settings:', error);\n      setSaveMessage('Error saving settings');\n      setTimeout(() => setSaveMessage(''), 3000);\n    }\n  };\n\n  // Export settings to JSON file\n  const exportSettings = () => {\n    try {\n      var _cameraRef$current3, _cameraRef$current4, _graphRef$current3, _graphRef$current4, _graphRef$current4$ge;\n      // Get camera settings\n      const camSettings = (_cameraRef$current3 = cameraRef.current) === null || _cameraRef$current3 === void 0 ? void 0 : _cameraRef$current3.getSettings();\n\n      // Get crop frame settings\n      const cropSettings = (_cameraRef$current4 = cameraRef.current) === null || _cameraRef$current4 === void 0 ? void 0 : _cameraRef$current4.getCropSettings();\n\n      // Get calibration settings from graph component\n      const calSettings = (_graphRef$current3 = graphRef.current) === null || _graphRef$current3 === void 0 ? void 0 : _graphRef$current3.getCalibrationSettings();\n      if (!camSettings && !calSettings && !cropSettings) {\n        console.warn('No settings to export - components may not be mounted');\n        setSaveMessage('No settings to export');\n        setTimeout(() => setSaveMessage(''), 3000);\n        return;\n      }\n\n      // Create a settings object to export\n      const settings = {\n        camera: camSettings || null,\n        calibration: calSettings || null,\n        cropFrame: cropSettings || null,\n        timestamp: new Date().toISOString(),\n        detectorId: detectorId || 'default',\n        // Export waterfall settings\n        waterfall: {\n          colorScheme: waterfallColorScheme\n        },\n        // Export frame accumulation settings\n        frameAccumulation: {\n          count: frameAccumCount,\n          isEnabled: isAccumulating\n        },\n        // Export peak markers settings if available from graph component\n        peakMarkers: ((_graphRef$current4 = graphRef.current) === null || _graphRef$current4 === void 0 ? void 0 : (_graphRef$current4$ge = _graphRef$current4.getPeakSettings) === null || _graphRef$current4$ge === void 0 ? void 0 : _graphRef$current4$ge.call(_graphRef$current4)) || {\n          count: 3,\n          showMarkers: true\n        },\n        // Export component visibility states\n        visibilityState: {\n          camera: showCamera,\n          graph: showGraph,\n          waterfall: showWaterfall,\n          settings: showSettings\n        },\n        // Export crop data state\n        usingCropData: usingCropData\n      };\n\n      // Create a file name with timestamp\n      const timestamp = new Date().toISOString().replace(/:/g, '-').replace(/\\./g, '_');\n      const fileName = `detector_settings_${detectorId || 'default'}_${timestamp}.json`;\n\n      // Create a Blob with the JSON data\n      const blob = new Blob([JSON.stringify(settings, null, 2)], {\n        type: 'application/json'\n      });\n\n      // Create a URL for the Blob\n      const url = URL.createObjectURL(blob);\n\n      // Create a temporary link element to trigger the download\n      const link = document.createElement('a');\n      link.href = url;\n      link.download = fileName;\n\n      // Append to the document, click, and remove\n      document.body.appendChild(link);\n      link.click();\n\n      // Clean up\n      setTimeout(() => {\n        document.body.removeChild(link);\n        URL.revokeObjectURL(url);\n      }, 100);\n\n      // Set save message for user feedback\n      setSaveMessage('Settings exported to file');\n      setTimeout(() => setSaveMessage(''), 3000);\n    } catch (error) {\n      console.error('Failed to export settings:', error);\n      setSaveMessage('Error exporting settings');\n      setTimeout(() => setSaveMessage(''), 3000);\n    }\n  };\n\n  // Load saved camera and calibration settings\n  const loadSettings = () => {\n    try {\n      var _cameraRef$current5, _savedSettings$waterf, _graphRef$current5;\n      // Get settings from localStorage\n      const savedSettingsStr = localStorage.getItem(`detector_settings_${detectorId || 'default'}`);\n      if (!savedSettingsStr) {\n        setSaveMessage('No saved settings found');\n        setTimeout(() => setSaveMessage(''), 3000);\n        return;\n      }\n\n      // Parse the settings\n      const savedSettings = JSON.parse(savedSettingsStr);\n\n      // Apply camera settings if available\n      if (savedSettings.camera && cameraRef.current) {\n        try {\n          cameraRef.current.applySettings(savedSettings.camera);\n        } catch (err) {\n          console.error('Error applying camera settings:', err);\n        }\n      }\n\n      // Apply crop frame settings if available\n      if (savedSettings.cropFrame && (_cameraRef$current5 = cameraRef.current) !== null && _cameraRef$current5 !== void 0 && _cameraRef$current5.applyCropSettings) {\n        try {\n          cameraRef.current.applyCropSettings(savedSettings.cropFrame);\n        } catch (err) {\n          console.error('Error applying crop frame settings:', err);\n        }\n      }\n\n      // Apply calibration settings if available\n      if (savedSettings.calibration && graphRef.current) {\n        try {\n          graphRef.current.applyCalibrationSettings(savedSettings.calibration);\n\n          // Rebuild sensitivity factors lookup when calibration is loaded\n          if (savedSettings.calibration.calibrationPoints && savedSettings.calibration.calibrationPoints.length >= 2) {\n            var _processedData$pixelD;\n            const point1 = savedSettings.calibration.calibrationPoints[0];\n            const point2 = savedSettings.calibration.calibrationPoints[1];\n            const minWavelength = point1.wavelength - point1.position * (point2.wavelength - point1.wavelength) / (point2.position - point1.position);\n            const maxWavelength = point2.wavelength + (1 - point2.position) * (point2.wavelength - point1.wavelength) / (point2.position - point1.position);\n\n            // Estimate the data length from the current processed data or use a reasonable default\n            const dataLength = (processedData === null || processedData === void 0 ? void 0 : (_processedData$pixelD = processedData.pixelData) === null || _processedData$pixelD === void 0 ? void 0 : _processedData$pixelD.lineLength) || 1024;\n\n            // Create lookup table for sensitivity factors\n            const wavelengthKeys = Object.keys(spectralConfig.SENSITIVITY_FACTORS).map(key => parseFloat(key));\n            const wavelengthRange = maxWavelength - minWavelength;\n            const lookup = new Array(dataLength);\n            for (let i = 0; i < dataLength; i++) {\n              // Scale position to calibrated wavelength range\n              const scaledPosition = i / (dataLength - 1);\n              const mappedWavelength = minWavelength + scaledPosition * wavelengthRange;\n\n              // Find closest sensitivity factor\n              let closestWavelength = wavelengthKeys[0];\n              let minDiff = Math.abs(mappedWavelength - closestWavelength);\n              for (let j = 1; j < wavelengthKeys.length; j++) {\n                const diff = Math.abs(mappedWavelength - wavelengthKeys[j]);\n                if (diff < minDiff) {\n                  minDiff = diff;\n                  closestWavelength = wavelengthKeys[j];\n                }\n              }\n\n              // Store the sensitivity factor\n              lookup[i] = spectralConfig.SENSITIVITY_FACTORS[closestWavelength.toString()];\n            }\n            setSensitivityFactorsLookup(lookup);\n            console.log('[SpectrometerMQTT] Built sensitivity factors lookup table with', lookup.length, 'entries');\n          }\n        } catch (err) {\n          console.error('Error applying calibration settings:', err);\n        }\n      }\n\n      // Apply waterfall settings if available\n      if ((_savedSettings$waterf = savedSettings.waterfall) !== null && _savedSettings$waterf !== void 0 && _savedSettings$waterf.colorScheme) {\n        setWaterfallColorScheme(savedSettings.waterfall.colorScheme);\n      }\n\n      // Apply frame accumulation settings if available\n      if (savedSettings.frameAccumulation) {\n        if (typeof savedSettings.frameAccumulation.count === 'number') {\n          setFrameAccumCount(savedSettings.frameAccumulation.count);\n        }\n        if (typeof savedSettings.frameAccumulation.isEnabled === 'boolean') {\n          setIsAccumulating(savedSettings.frameAccumulation.isEnabled);\n        }\n      }\n\n      // Apply peak markers settings if available\n      if (savedSettings.peakMarkers && (_graphRef$current5 = graphRef.current) !== null && _graphRef$current5 !== void 0 && _graphRef$current5.applyPeakSettings) {\n        try {\n          graphRef.current.applyPeakSettings(savedSettings.peakMarkers);\n        } catch (err) {\n          console.error('Error applying peak markers settings:', err);\n        }\n      }\n\n      // Apply component visibility state if available\n      if (savedSettings.visibilityState) {\n        if (typeof savedSettings.visibilityState.camera === 'boolean') {\n          setShowCamera(savedSettings.visibilityState.camera);\n        }\n        if (typeof savedSettings.visibilityState.graph === 'boolean') {\n          setShowGraph(savedSettings.visibilityState.graph);\n        }\n        if (typeof savedSettings.visibilityState.waterfall === 'boolean') {\n          setShowWaterfall(savedSettings.visibilityState.waterfall);\n        }\n        if (typeof savedSettings.visibilityState.settings === 'boolean') {\n          setShowSettings(savedSettings.visibilityState.settings);\n        }\n      }\n\n      // Apply crop data state if available\n      if (typeof savedSettings.usingCropData === 'boolean') {\n        setUsingCropData(savedSettings.usingCropData);\n      }\n\n      // Make sure camera is started automatically\n      setTimeout(async () => {\n        if (cameraRef.current && typeof cameraRef.current.startCamera === 'function') {\n          try {\n            await cameraRef.current.startCamera();\n            console.log('Camera started automatically after loading settings');\n          } catch (err) {\n            console.error('Failed to auto-start camera:', err);\n          }\n        }\n      }, 500); // Short delay to allow settings to be applied\n\n      // Set save message for user feedback\n      setSaveMessage('Settings loaded successfully');\n      setTimeout(() => setSaveMessage(''), 3000);\n    } catch (error) {\n      console.error('Failed to load settings:', error);\n      setSaveMessage('Error loading settings');\n      setTimeout(() => setSaveMessage(''), 3000);\n    }\n  };\n\n  // Import settings from a JSON file\n  const importSettings = () => {\n    try {\n      // Create a file input element\n      const fileInput = document.createElement('input');\n      fileInput.type = 'file';\n      fileInput.accept = '.json';\n\n      // Handle file selection\n      fileInput.onchange = event => {\n        const file = event.target.files[0];\n        if (!file) return;\n        const reader = new FileReader();\n        reader.onload = e => {\n          try {\n            var _cameraRef$current6, _importedSettings$wat, _graphRef$current6;\n            // Parse the file contents\n            const importedSettings = JSON.parse(e.target.result);\n\n            // Apply camera settings if available\n            if (importedSettings.camera && cameraRef.current) {\n              try {\n                cameraRef.current.applySettings(importedSettings.camera);\n              } catch (err) {\n                console.error('Error applying imported camera settings:', err);\n              }\n            }\n\n            // Apply crop frame settings if available\n            if (importedSettings.cropFrame && (_cameraRef$current6 = cameraRef.current) !== null && _cameraRef$current6 !== void 0 && _cameraRef$current6.applyCropSettings) {\n              try {\n                cameraRef.current.applyCropSettings(importedSettings.cropFrame);\n              } catch (err) {\n                console.error('Error applying imported crop frame settings:', err);\n              }\n            }\n\n            // Apply calibration settings if available\n            if (importedSettings.calibration && graphRef.current) {\n              try {\n                graphRef.current.applyCalibrationSettings(importedSettings.calibration);\n              } catch (err) {\n                console.error('Error applying imported calibration settings:', err);\n              }\n            }\n\n            // Apply waterfall settings if available\n            if ((_importedSettings$wat = importedSettings.waterfall) !== null && _importedSettings$wat !== void 0 && _importedSettings$wat.colorScheme) {\n              setWaterfallColorScheme(importedSettings.waterfall.colorScheme);\n            }\n\n            // Apply frame accumulation settings if available\n            if (importedSettings.frameAccumulation) {\n              if (typeof importedSettings.frameAccumulation.count === 'number') {\n                setFrameAccumCount(importedSettings.frameAccumulation.count);\n              }\n              if (typeof importedSettings.frameAccumulation.isEnabled === 'boolean') {\n                setIsAccumulating(importedSettings.frameAccumulation.isEnabled);\n              }\n            }\n\n            // Apply peak markers settings if available\n            if (importedSettings.peakMarkers && (_graphRef$current6 = graphRef.current) !== null && _graphRef$current6 !== void 0 && _graphRef$current6.applyPeakSettings) {\n              try {\n                graphRef.current.applyPeakSettings(importedSettings.peakMarkers);\n              } catch (err) {\n                console.error('Error applying peak markers settings:', err);\n              }\n            }\n\n            // Apply component visibility state if available\n            if (importedSettings.visibilityState) {\n              if (typeof importedSettings.visibilityState.camera === 'boolean') {\n                setShowCamera(importedSettings.visibilityState.camera);\n              }\n              if (typeof importedSettings.visibilityState.graph === 'boolean') {\n                setShowGraph(importedSettings.visibilityState.graph);\n              }\n              if (typeof importedSettings.visibilityState.waterfall === 'boolean') {\n                setShowWaterfall(importedSettings.visibilityState.waterfall);\n              }\n              if (typeof importedSettings.visibilityState.settings === 'boolean') {\n                setShowSettings(importedSettings.visibilityState.settings);\n              }\n            }\n\n            // Apply crop data state if available\n            if (typeof importedSettings.usingCropData === 'boolean') {\n              setUsingCropData(importedSettings.usingCropData);\n            }\n\n            // Make sure camera is started automatically\n            setTimeout(async () => {\n              if (cameraRef.current && typeof cameraRef.current.startCamera === 'function') {\n                try {\n                  await cameraRef.current.startCamera();\n                  console.log('Camera started automatically after loading settings');\n                } catch (err) {\n                  console.error('Failed to auto-start camera:', err);\n                }\n              }\n            }, 500); // Short delay to allow settings to be applied\n\n            // Set save message for user feedback\n            setSaveMessage('Settings imported successfully');\n            setTimeout(() => setSaveMessage(''), 3000);\n          } catch (parseError) {\n            console.error('Failed to parse imported settings file:', parseError);\n            setSaveMessage('Error: Invalid settings file');\n            setTimeout(() => setSaveMessage(''), 3000);\n          }\n        };\n        reader.onerror = () => {\n          setSaveMessage('Error reading file');\n          setTimeout(() => setSaveMessage(''), 3000);\n        };\n\n        // Read the file as text\n        reader.readAsText(file);\n      };\n\n      // Trigger file selection dialog\n      fileInput.click();\n    } catch (error) {\n      console.error('Failed to import settings:', error);\n      setSaveMessage('Error importing settings');\n      setTimeout(() => setSaveMessage(''), 3000);\n    }\n  };\n\n  // Handler for panel resizing - completely rewritten for reliability\n  const handlePanelResizeStart = e => {\n    var _panelRef$current, _panelRef$current2;\n    e.preventDefault();\n    e.stopPropagation();\n\n    // Get initial coordinates and size\n    const startX = e.clientX;\n    const startY = e.clientY;\n    const startWidth = ((_panelRef$current = panelRef.current) === null || _panelRef$current === void 0 ? void 0 : _panelRef$current.offsetWidth) || panelSize.width;\n    const startHeight = ((_panelRef$current2 = panelRef.current) === null || _panelRef$current2 === void 0 ? void 0 : _panelRef$current2.offsetHeight) || panelSize.height;\n\n    // Show resize feedback\n    setIsResizingPanel(true);\n    setShowResizeInfo(true);\n\n    // Define move handler\n    function handleMouseMove(moveEvent) {\n      const deltaX = moveEvent.clientX - startX;\n      const deltaY = moveEvent.clientY - startY;\n      const newWidth = Math.max(400, startWidth + deltaX);\n      const newHeight = Math.max(300, startHeight + deltaY);\n\n      // Update panel size\n      setPanelSize({\n        width: newWidth,\n        height: newHeight\n      });\n\n      // Prevent default to avoid text selection during resize\n      moveEvent.preventDefault();\n    }\n\n    // Define up handler\n    function handleMouseUp() {\n      // Clean up\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n      setIsResizingPanel(false);\n      setTimeout(() => setShowResizeInfo(false), 800);\n    }\n\n    // Attach handlers to document to capture events outside component\n    document.addEventListener('mousemove', handleMouseMove);\n    document.addEventListener('mouseup', handleMouseUp);\n  };\n\n  // Toggle visibility of subcomponents\n  const toggleCamera = () => setShowCamera(!showCamera);\n  const toggleGraph = () => setShowGraph(!showGraph);\n  const toggleWaterfall = () => setShowWaterfall(!showWaterfall);\n  const toggleSettings = () => setShowSettings(!showSettings);\n\n  // Styles for toggle buttons\n  const getToggleButtonStyle = isActive => ({\n    ...buttonVariants.smallSecondary,\n    opacity: isActive ? 1 : 0.5,\n    marginRight: '4px',\n    marginBottom: '4px'\n  });\n\n  // Handle subcomponent resize events\n  const handleCameraResize = newSize => {\n    console.log('Camera resized:', newSize);\n    // Additional logic if needed\n  };\n  const handleGraphResize = newSize => {\n    console.log('Graph resized:', newSize);\n    // Additional logic if needed\n  };\n  const handleWaterfallResize = newSize => {\n    console.log('Waterfall resized:', newSize);\n    // Additional logic if needed\n  };\n\n  // Handle settings changes\n  const handleSettingsChange = settings => {\n    console.log('Settings changed:', settings);\n    // Update relevant state/behavior based on settings\n  };\n\n  // Render panel content\n  if (!detector) return null;\n  return /*#__PURE__*/_jsxDEV(DraggablePanel, {\n    title: `MQTT Spectrometer: ${detector.label || detector.id}`,\n    initialPosition: initialPosition,\n    width: panelSize.width,\n    height: panelSize.height,\n    onClose: onClose,\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      ref: panelRef,\n      style: {\n        ...styles.container,\n        width: `${panelSize.width}px`,\n        height: `${panelSize.height}px`,\n        minHeight: '300px',\n        position: 'relative',\n        border: isResizingPanel ? '1px dashed #4CAF50' : 'none',\n        transition: isResizingPanel ? 'none' : 'border 0.3s ease'\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        style: styles.controlBar,\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          children: [/*#__PURE__*/_jsxDEV(\"span\", {\n            style: styles.controlLabel,\n            children: \"Components:\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1088,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: toggleCamera,\n            style: getToggleButtonStyle(showCamera),\n            children: showCamera ? '📹 Hide Camera' : '📹 Show Camera'\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1090,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: toggleGraph,\n            style: getToggleButtonStyle(showGraph),\n            children: showGraph ? '📊 Hide Graph' : '📊 Show Graph'\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1097,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: toggleWaterfall,\n            style: getToggleButtonStyle(showWaterfall),\n            children: showWaterfall ? '🌊 Hide Waterfall' : '🌊 Show Waterfall'\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1104,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: toggleSettings,\n            style: getToggleButtonStyle(showSettings),\n            children: showSettings ? '⚙️ Hide Settings' : '⚙️ Show Settings'\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1111,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n            style: {\n              marginLeft: '15px',\n              borderLeft: '1px solid rgba(255, 255, 255, 0.2)',\n              paddingLeft: '10px'\n            },\n            children: [/*#__PURE__*/_jsxDEV(\"button\", {\n              onClick: saveSettings,\n              style: {\n                ...buttonVariants.smallPrimary,\n                marginRight: '4px',\n                marginBottom: '4px',\n                backgroundColor: 'rgba(50, 150, 50, 0.7)'\n              },\n              title: \"Save camera and calibration settings to browser storage\",\n              children: \"\\uD83D\\uDCBE Save Settings\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1119,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n              onClick: exportSettings,\n              style: {\n                ...buttonVariants.smallPrimary,\n                marginRight: '4px',\n                marginBottom: '4px',\n                backgroundColor: 'rgba(120, 120, 30, 0.7)'\n              },\n              title: \"Export camera and calibration settings to JSON file\",\n              children: \"\\uD83D\\uDCE4 Export Settings\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1132,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n              onClick: loadSettings,\n              style: {\n                ...buttonVariants.smallPrimary,\n                marginRight: '4px',\n                marginBottom: '4px',\n                backgroundColor: 'rgba(50, 100, 150, 0.7)'\n              },\n              title: \"Load saved camera and calibration settings from browser storage\",\n              children: \"\\uD83D\\uDCE5 Load Settings\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1145,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n              onClick: importSettings,\n              style: {\n                ...buttonVariants.smallPrimary,\n                marginRight: '4px',\n                marginBottom: '4px',\n                backgroundColor: 'rgba(120, 70, 150, 0.7)'\n              },\n              title: \"Import camera and calibration settings from JSON file\",\n              children: \"\\uD83D\\uDCC1 Import File\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1158,\n              columnNumber: 15\n            }, this), saveMessage && /*#__PURE__*/_jsxDEV(\"span\", {\n              style: {\n                fontSize: '12px',\n                backgroundColor: 'rgba(0, 0, 0, 0.6)',\n                padding: '2px 6px',\n                borderRadius: '3px',\n                marginLeft: '8px'\n              },\n              children: saveMessage\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1172,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1118,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1087,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1086,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: styles.columnsContainer,\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            display: showCamera ? 'block' : 'none',\n            flex: '1 1 50%',\n            minWidth: '320px',\n            maxWidth: '650px',\n            marginRight: '10px'\n          },\n          children: /*#__PURE__*/_jsxDEV(MQTTCameraComponent, {\n            ref: cameraRef,\n            onResize: handleCameraResize,\n            detectorId: detectorId\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1196,\n            columnNumber: 13\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1189,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            ...styles.rightColumn,\n            flex: '1 1 50%'\n          },\n          children: [showGraph && /*#__PURE__*/_jsxDEV(MQTTGraphComponent, {\n            ref: graphRef,\n            onResize: handleGraphResize,\n            lineData: processedData // Use processedData instead of spectrumData\n            // Pass the frame accumulation props up to parent to manage\n            ,\n            onFrameAccumCountChange: handleFrameAccumCountChange,\n            onAccumulationToggle: handleAccumulationToggle\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1210,\n            columnNumber: 15\n          }, this), showWaterfall && /*#__PURE__*/_jsxDEV(MQTTWaterfallComponent, {\n            onResize: handleWaterfallResize,\n            lineData: processedData // Use processedData instead of spectrumData\n            ,\n            frameAccumCount: frameAccumCount,\n            isAccumulating: isAccumulating,\n            colorScale: waterfallColorScheme,\n            onColorScaleChange: handleWaterfallColorSchemeChange\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1222,\n            columnNumber: 15\n          }, this), showSettings && /*#__PURE__*/_jsxDEV(MQTTSettingsComponent, {\n            onSettingChange: (setting, value) => console.log('Setting changed:', setting, value)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1234,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1204,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1187,\n        columnNumber: 9\n      }, this), showResizeInfo && /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          position: 'absolute',\n          right: '30px',\n          bottom: '30px',\n          padding: '4px 8px',\n          background: 'rgba(0, 0, 0, 0.6)',\n          color: 'white',\n          borderRadius: '3px',\n          fontSize: '12px',\n          zIndex: 1000\n        },\n        children: [Math.round(panelSize.width), \" x \", Math.round(panelSize.height)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1243,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: styles.resizeHandle,\n        onMouseDown: handlePanelResizeStart,\n        title: \"Drag to resize panel\",\n        children: /*#__PURE__*/_jsxDEV(\"svg\", {\n          width: \"20\",\n          height: \"20\",\n          viewBox: \"0 0 20 20\",\n          style: {\n            display: 'block'\n          },\n          children: [/*#__PURE__*/_jsxDEV(\"rect\", {\n            width: \"20\",\n            height: \"20\",\n            fill: \"transparent\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1270,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"path\", {\n            d: \"M14,6 L6,14 M17,9 L9,17 M17,13 L13,17\",\n            stroke: \"white\",\n            strokeWidth: \"2\",\n            strokeLinecap: \"round\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1271,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1264,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1259,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1073,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1066,\n    columnNumber: 5\n  }, this);\n};\n_s(SpectrometerMQTT, \"w/0PCO0eQO+0PYDyhsJRPhWyowE=\", false, function () {\n  return [useButtonStyles];\n});\n_c = SpectrometerMQTT;\nexport default SpectrometerMQTT;\nvar _c;\n$RefreshReg$(_c, \"SpectrometerMQTT\");","map":{"version":3,"names":["React","useState","useRef","useEffect","DraggablePanel","useButtonStyles","backgroundVariants","styles","WS_URL","spectralConfig","MQTTCameraComponent","MQTTGraphComponent","MQTTWaterfallComponent","MQTTSettingsComponent","jsxDEV","_jsxDEV","mqttStyles","cameraSettings","marginTop","padding","backgroundColor","borderRadius","mqttInputs","display","alignItems","marginBottom","inputLabel","width","color","fontSize","input","flex","border","waterfallColorSchemeOptions","grayscale","viridis","plasma","inferno","cividis","turbo","SpectrometerMQTT","detector","readings","onClose","initialPosition","x","y","detectorId","detectorName","isVisible","position","onMove","onResize","detectorStatus","_s","buttonVariants","detectorReadings","setDetectorReadings","panelSize","setPanelSize","height","isResizingPanel","setIsResizingPanel","panelRef","showResizeInfo","setShowResizeInfo","showCamera","setShowCamera","showGraph","setShowGraph","showWaterfall","setShowWaterfall","showSettings","setShowSettings","spectrumData","setSpectrumData","processedData","setProcessedData","usingCropData","setUsingCropData","sensitivityFactorsLookup","setSensitivityFactorsLookup","saveMessage","setSaveMessage","setCameraSettings","calibrationSettings","setCalibrationSettings","frameAccumCount","setFrameAccumCount","isAccumulating","setIsAccumulating","waterfallColorScheme","setWaterfallColorScheme","showWaterfallColorMenu","setShowWaterfallColorMenu","wsRef","mqttTopicRef","cameraRef","graphRef","handleFrameAccumCountChange","count","handleAccumulationToggle","isActive","handleWaterfallColorSchemeChange","scheme","_detector$data","length","data","properties","mainDataTopic","current","isMounted","console","log","newWs","WebSocket","onopen","readyState","OPEN","subscribeData","topic","payload","send","JSON","stringify","warn","err","error","onmessage","event","parse","parsedPayload","e","red","green","blue","intensities","graphData","pixelData","timestamp","positions","wavelengths","intensity","lineLength","minWavelength","maxWavelength","getCalibrationSettings","calibrationPoints","calibrationPoint1Position","calibrationPoint2Position","calibrationPoint1Wavelength","wavelength","calibrationPoint2Wavelength","wavelengthPerPosition","wavelengthKeys","Object","keys","SENSITIVITY_FACTORS","map","key","parseFloat","wavelengthRange","dataLength","lookup","Array","i","scaledPosition","mappedWavelength","closestWavelength","minDiff","Math","abs","j","diff","toString","CHANNEL_RANGES","mappedWavelengths","w","idx","b","g","r","correctedIntensity","value","newLookup","raw_data","data_type","rawIntensity","isArray","isRawData","bitDepth","bit_depth","dataType","raw_red","Date","now","raw_green","raw_blue","val","min","max","onerror","onclose","code","reason","ws","CONNECTING","close","handleCropDataToggle","isEnabled","saveSettings","_cameraRef$current","_cameraRef$current2","_graphRef$current","_graphRef$current2","_graphRef$current2$ge","camSettings","getSettings","cropSettings","getCropSettings","calSettings","setTimeout","settings","camera","calibration","cropFrame","toISOString","waterfall","colorScheme","frameAccumulation","peakMarkers","getPeakSettings","call","showMarkers","visibilityState","graph","localStorage","setItem","exportSettings","_cameraRef$current3","_cameraRef$current4","_graphRef$current3","_graphRef$current4","_graphRef$current4$ge","replace","fileName","blob","Blob","type","url","URL","createObjectURL","link","document","createElement","href","download","body","appendChild","click","removeChild","revokeObjectURL","loadSettings","_cameraRef$current5","_savedSettings$waterf","_graphRef$current5","savedSettingsStr","getItem","savedSettings","applySettings","applyCropSettings","applyCalibrationSettings","_processedData$pixelD","point1","point2","applyPeakSettings","startCamera","importSettings","fileInput","accept","onchange","file","target","files","reader","FileReader","onload","_cameraRef$current6","_importedSettings$wat","_graphRef$current6","importedSettings","result","parseError","readAsText","handlePanelResizeStart","_panelRef$current","_panelRef$current2","preventDefault","stopPropagation","startX","clientX","startY","clientY","startWidth","offsetWidth","startHeight","offsetHeight","handleMouseMove","moveEvent","deltaX","deltaY","newWidth","newHeight","handleMouseUp","removeEventListener","addEventListener","toggleCamera","toggleGraph","toggleWaterfall","toggleSettings","getToggleButtonStyle","smallSecondary","opacity","marginRight","handleCameraResize","newSize","handleGraphResize","handleWaterfallResize","handleSettingsChange","title","label","id","children","ref","style","container","minHeight","transition","controlBar","controlLabel","_jsxFileName","lineNumber","columnNumber","onClick","marginLeft","borderLeft","paddingLeft","smallPrimary","columnsContainer","minWidth","maxWidth","rightColumn","lineData","onFrameAccumCountChange","onAccumulationToggle","colorScale","onColorScaleChange","onSettingChange","setting","right","bottom","background","zIndex","round","resizeHandle","onMouseDown","viewBox","fill","d","stroke","strokeWidth","strokeLinecap","_c","$RefreshReg$"],"sources":["E:/flow chemistry/fluidicGUI/frontend/fluidicgui/src/components/Simulation/SpectrometerMQTT.js"],"sourcesContent":["import React, { useState, useRef, useEffect } from 'react';\nimport DraggablePanel from './DraggablePanel';\nimport { useButtonStyles } from '../../styles/ButtonStyleProvider';\nimport { backgroundVariants } from '../../styles/backgroundStyles';\nimport styles from './styles/USBSpectrometerStyles';\nimport { WS_URL } from '../../config'; // Import WS_URL\nimport spectralConfig from './SpectrometerMQTT/spectral_config.json'; // Import spectral config\n\n// Import subcomponents\nimport MQTTCameraComponent from './SpectrometerMQTT/MQTTCameraComponent';\nimport MQTTGraphComponent from './SpectrometerMQTT/MQTTGraphComponent';\nimport MQTTWaterfallComponent from './SpectrometerMQTT/MQTTWaterfallComponent';\nimport MQTTSettingsComponent from './SpectrometerMQTT/MQTTSettingsComponent';\n\n// Add MQTT-specific styles to complement the existing styles\nconst mqttStyles = {\n  cameraSettings: {\n    marginTop: '10px',\n    padding: '8px',\n    backgroundColor: 'rgba(0, 0, 0, 0.3)',\n    borderRadius: '4px'\n  },\n  mqttInputs: {\n    display: 'flex',\n    alignItems: 'center',\n    marginBottom: '8px'\n  },\n  inputLabel: {\n    width: '90px',\n    color: '#ccc',\n    fontSize: '14px'\n  },\n  input: {\n    flex: 1,\n    backgroundColor: 'rgba(60, 60, 60, 0.7)',\n    border: '1px solid rgba(100, 100, 100, 0.5)',\n    borderRadius: '4px',\n    padding: '4px 8px',\n    color: 'white',\n    fontSize: '14px'\n  }\n};\n\n// Available waterfall color schemes\nconst waterfallColorSchemeOptions = {\n  grayscale: 'Grayscale',\n  viridis: 'Viridis',\n  plasma: 'Plasma',\n  inferno: 'Inferno',\n  cividis: 'Cividis',\n  turbo: 'Turbo'\n};\n\nconst SpectrometerMQTT = ({ detector, readings = [], onClose, initialPosition = { x: 150, y: 100 }, detectorId, detectorName, isVisible, position, onMove, onResize, detectorStatus }) => {\n  const buttonVariants = useButtonStyles();\n  const [detectorReadings, setDetectorReadings] = useState([]);\n  \n  // Panel resizing state\n  const [panelSize, setPanelSize] = useState({ width: 1100, height: 750 });\n  const [isResizingPanel, setIsResizingPanel] = useState(false);\n  const panelRef = useRef(null);\n  \n  // Add state for resize feedback\n  const [showResizeInfo, setShowResizeInfo] = useState(false);\n  \n  // Subcomponent visibility toggles\n  const [showCamera, setShowCamera] = useState(true);\n  const [showGraph, setShowGraph] = useState(true);\n  const [showWaterfall, setShowWaterfall] = useState(false);\n  const [showSettings, setShowSettings] = useState(false);\n  \n  // Data state - replace lineData with spectrumData\n  const [spectrumData, setSpectrumData] = useState(null); // Data from spectrometer\n  const [processedData, setProcessedData] = useState(null); // Data from crop processing\n\n  // Track if we're currently using processed crop data\n  const [usingCropData, setUsingCropData] = useState(false);\n  \n  // Add sensitivity factors lookup table\n  const [sensitivityFactorsLookup, setSensitivityFactorsLookup] = useState(null);\n  \n  // Save/load settings state\n  const [saveMessage, setSaveMessage] = useState('');\n  const [cameraSettings, setCameraSettings] = useState(null);\n  const [calibrationSettings, setCalibrationSettings] = useState(null);\n  \n  // Frame accumulation state (shared between Graph and Waterfall)\n  const [frameAccumCount, setFrameAccumCount] = useState(10);\n  const [isAccumulating, setIsAccumulating] = useState(true);\n  \n  // Waterfall color scheme state\n  const [waterfallColorScheme, setWaterfallColorScheme] = useState('cividis');\n  const [showWaterfallColorMenu, setShowWaterfallColorMenu] = useState(false);\n  \n  // References to component methods\n  const wsRef = useRef(null); // Ref to hold the WebSocket instance\n  const mqttTopicRef = useRef('spectrometer_1'); // Ref to hold the current MQTT topic\n  const cameraRef = useRef(null);\n  const graphRef = useRef(null);\n  \n  // Handle frame accumulation change\n  const handleFrameAccumCountChange = (count) => {\n    setFrameAccumCount(count);\n  };\n  \n  // Handle accumulation mode toggle\n  const handleAccumulationToggle = (isActive) => {\n    setIsAccumulating(isActive);\n  };\n  \n  // Handle waterfall color scheme change\n  const handleWaterfallColorSchemeChange = (scheme) => {\n    setWaterfallColorScheme(scheme);\n    setShowWaterfallColorMenu(false);\n  };\n  \n  // Process readings when they change\n  useEffect(() => {\n    if (readings && readings.length > 0 && detector?.data?.properties) {\n      // Process readings here\n      setDetectorReadings(readings);\n    }\n  }, [readings, detector]);\n  \n  // Effect for WebSocket connection and message handling\n  useEffect(() => {\n    if (!detectorId) return; // Need detectorId to form topic\n\n    const mainDataTopic = `${detectorId}/response/data`; // Default data topic\n    mqttTopicRef.current = mainDataTopic;\n\n    // Flag to track if the component is still mounted\n    let isMounted = true;\n\n    console.log('[SpectrometerMQTT] Connecting WebSocket...', WS_URL);\n    const newWs = new WebSocket(WS_URL);\n    wsRef.current = newWs;\n\n    newWs.onopen = () => {\n      // Check if the component is still mounted and connection wasn't closed\n      if (!isMounted || newWs.readyState !== WebSocket.OPEN) {\n        console.log('[SpectrometerMQTT] WebSocket connected but component unmounted or connection closed');\n        return;\n      }\n\n      console.log('[SpectrometerMQTT] WebSocket connected');\n\n      try {\n        // Subscribe to the data topic\n        const subscribeData = {\n          topic: \"common/subscribe\",\n          payload: mainDataTopic\n        };\n        \n        // Make sure WebSocket is still valid before sending\n        if (newWs && newWs.readyState === WebSocket.OPEN) {\n          newWs.send(JSON.stringify(subscribeData));\n          console.log(`[SpectrometerMQTT] Subscribed to: ${mainDataTopic}`);\n        } else {\n          console.warn('[SpectrometerMQTT] Cannot subscribe: WebSocket not available or not open');\n        }\n      } catch (err) {\n        console.error('[SpectrometerMQTT] Error in onopen handler:', err);\n      }\n    };\n\n    newWs.onmessage = (event) => {\n      if (!isMounted) return;\n      \n      try {\n        const data = JSON.parse(event.data);\n\n        // Check if the message is on the subscribed data topic\n        if (data.topic === mqttTopicRef.current) {\n          let parsedPayload = null;\n          if (data.payload && typeof data.payload === 'string') {\n            try {\n              parsedPayload = JSON.parse(data.payload);\n            } catch (e) { /* Ignore if not JSON */ }\n          } else if (data.payload && typeof data.payload === 'object') {\n            parsedPayload = data.payload;\n          }\n\n          // Check if payload contains spectral data\n          if (parsedPayload) {\n            // Check if this is processed graph data (from crop)\n            if (parsedPayload.red && parsedPayload.green && parsedPayload.blue && parsedPayload.intensities) {\n              console.log('[SpectrometerMQTT] Received processed graph data from crop');\n              \n              // Transform data to expected format for the graph\n              const graphData = {\n                pixelData: {\n                  timestamp: parsedPayload.timestamp,\n                  positions: parsedPayload.wavelengths,\n                  red: parsedPayload.red,\n                  green: parsedPayload.green,\n                  blue: parsedPayload.blue,\n                  intensity: parsedPayload.intensities,\n                  lineLength: parsedPayload.wavelengths.length\n                }\n              };\n              \n              setProcessedData(graphData);\n              setUsingCropData(true);  // Flag that we're using crop data\n            }\n            else if (parsedPayload.red && parsedPayload.green && parsedPayload.blue ) {\n              console.log('[SpectrometerMQTT] Received processed graph data from crop');\n\n              // Get calibration data from graph component if available\n              let minWavelength = 450; // Default min wavelength\n              let maxWavelength = 650; // Default max wavelength\n              \n              // Try to use calibration points from graph component if it exists\n              if (graphRef.current && graphRef.current.getCalibrationSettings) {\n                const calibrationSettings = graphRef.current.getCalibrationSettings();\n                if (calibrationSettings.calibrationPoints && calibrationSettings.calibrationPoints.length >= 2) {\n                  const calibrationPoint1Position = calibrationSettings.calibrationPoints[0].position;\n                  const calibrationPoint2Position = calibrationSettings.calibrationPoints[1].position;\n                  const calibrationPoint1Wavelength = calibrationSettings.calibrationPoints[0].wavelength;\n                  const calibrationPoint2Wavelength = calibrationSettings.calibrationPoints[1].wavelength;\n                  // Get wavelengths from calibration points\n                  const wavelengthPerPosition = (calibrationPoint2Wavelength - calibrationPoint1Wavelength)/(calibrationPoint2Position - calibrationPoint1Position);\n                  minWavelength = calibrationPoint1Wavelength - calibrationPoint1Position * wavelengthPerPosition;\n                  maxWavelength = calibrationPoint2Wavelength + (1 - calibrationPoint2Position) * wavelengthPerPosition;\n                  console.log('[SpectrometerMQTT] Calibration settings:', calibrationSettings);\n                  \n                  // Create lookup table for sensitivity factors based on calibration\n                  // This is more efficient than searching for closest matches for every point in every frame\n                  const wavelengthKeys = Object.keys(spectralConfig.SENSITIVITY_FACTORS).map(key => parseFloat(key));\n                  const wavelengthRange = maxWavelength - minWavelength;\n                  const dataLength = parsedPayload.wavelengths.length;\n                  \n                  // Create an array of the same length as wavelengths with the pre-computed closest sensitivity factor\n                  const lookup = new Array(dataLength);\n                  \n                  for (let i = 0; i < dataLength; i++) {\n                    // Scale position to calibrated wavelength range\n                    const scaledPosition = i / (dataLength - 1);\n                    const mappedWavelength = minWavelength + scaledPosition * wavelengthRange;\n                    \n                    // Find closest sensitivity factor (only done once per calibration)\n                    let closestWavelength = wavelengthKeys[0];\n                    let minDiff = Math.abs(mappedWavelength - closestWavelength);\n                    \n                    for (let j = 1; j < wavelengthKeys.length; j++) {\n                      const diff = Math.abs(mappedWavelength - wavelengthKeys[j]);\n                      if (diff < minDiff) {\n                        minDiff = diff;\n                        closestWavelength = wavelengthKeys[j];\n                      }\n                    }\n                    \n                    // Store the sensitivity factor directly in the lookup table\n                    lookup[i] = spectralConfig.SENSITIVITY_FACTORS[closestWavelength.toString()];\n                  }\n                  \n                  // Save the lookup table for future use\n                  setSensitivityFactorsLookup(lookup);\n                }\n              }\n              \n              \n              // Define channel wavelength ranges from spectral_config.json\n              const CHANNEL_RANGES = spectralConfig.CHANNEL_RANGES;\n              \n              // Map wavelengths to fit exactly within minWavelength and maxWavelength range\n              const mappedWavelengths = parsedPayload.wavelengths.map(w => {\n                // Scale the wavelength to fit in the calibrated range\n                return minWavelength + (w - parsedPayload.wavelengths[0]) / \n                  (parsedPayload.wavelengths[parsedPayload.wavelengths.length - 1] - parsedPayload.wavelengths[0]) * \n                  (maxWavelength - minWavelength);\n              });\n              \n              // Calculate intensity by selecting the appropriate channel based on mapped wavelength\n              const intensity = mappedWavelengths.map((wavelength, idx) => {\n                // Determine which channel to use based on wavelength\n                if (wavelength >= CHANNEL_RANGES.b[0] && wavelength < CHANNEL_RANGES.b[1]) {\n                  return parsedPayload.blue[idx]; // Blue channel\n                } else if (wavelength >= CHANNEL_RANGES.g[0] && wavelength < CHANNEL_RANGES.g[1]) {\n                  return parsedPayload.green[idx]; // Green channel\n                } else if (wavelength >= CHANNEL_RANGES.r[0] && wavelength <= CHANNEL_RANGES.r[1]) {\n                  return parsedPayload.red[idx]; // Red channel\n                } else {\n                  // Fallback to average if outside defined ranges\n                  return (parsedPayload.red[idx] + parsedPayload.green[idx] + parsedPayload.blue[idx]) / 3;\n                }\n              });\n              \n              // Apply sensitivity correction using pre-computed lookup table\n              let correctedIntensity;\n              if (sensitivityFactorsLookup && sensitivityFactorsLookup.length === intensity.length) {\n                // Fast path: use pre-computed lookup table\n                correctedIntensity = intensity.map((value, idx) => value / sensitivityFactorsLookup[idx]);\n              } else {\n                // Try to rebuild the lookup table if it doesn't exist or doesn't match the data length\n                try {\n                  console.log('[SpectrometerMQTT] Rebuilding sensitivity factors lookup table...');\n                  \n                  // Get calibration data from graph component if available\n                  let minWavelength = 450; // Default min wavelength\n                  let maxWavelength = 650; // Default max wavelength\n                  \n                  if (graphRef.current && graphRef.current.getCalibrationSettings) {\n                    const calibrationSettings = graphRef.current.getCalibrationSettings();\n                    if (calibrationSettings.calibrationPoints && calibrationSettings.calibrationPoints.length >= 2) {\n                      const calibrationPoint1Position = calibrationSettings.calibrationPoints[0].position;\n                      const calibrationPoint2Position = calibrationSettings.calibrationPoints[1].position;\n                      const calibrationPoint1Wavelength = calibrationSettings.calibrationPoints[0].wavelength;\n                      const calibrationPoint2Wavelength = calibrationSettings.calibrationPoints[1].wavelength;\n                      // Get wavelengths from calibration points\n                      const wavelengthPerPosition = (calibrationPoint2Wavelength - calibrationPoint1Wavelength)/(calibrationPoint2Position - calibrationPoint1Position);\n                      minWavelength = calibrationPoint1Wavelength - calibrationPoint1Position * wavelengthPerPosition;\n                      maxWavelength = calibrationPoint2Wavelength + (1 - calibrationPoint2Position) * wavelengthPerPosition;\n                    }\n                  }\n                  \n                  // Create lookup table with current data length\n                  const dataLength = intensity.length;\n                  const wavelengthKeys = Object.keys(spectralConfig.SENSITIVITY_FACTORS).map(key => parseFloat(key));\n                  const wavelengthRange = maxWavelength - minWavelength;\n                  const newLookup = new Array(dataLength);\n                  \n                  for (let i = 0; i < dataLength; i++) {\n                    // Scale position to calibrated wavelength range\n                    const scaledPosition = i / (dataLength - 1);\n                    const mappedWavelength = minWavelength + scaledPosition * wavelengthRange;\n                    \n                    // Find closest sensitivity factor\n                    let closestWavelength = wavelengthKeys[0];\n                    let minDiff = Math.abs(mappedWavelength - closestWavelength);\n                    \n                    for (let j = 1; j < wavelengthKeys.length; j++) {\n                      const diff = Math.abs(mappedWavelength - wavelengthKeys[j]);\n                      if (diff < minDiff) {\n                        minDiff = diff;\n                        closestWavelength = wavelengthKeys[j];\n                      }\n                    }\n                    \n                    // Store the sensitivity factor\n                    newLookup[i] = spectralConfig.SENSITIVITY_FACTORS[closestWavelength.toString()];\n                  }\n                  \n                  // Update the lookup table state for future use\n                  setSensitivityFactorsLookup(newLookup);\n                  console.log('[SpectrometerMQTT] Rebuilt sensitivity factors lookup table with', newLookup.length, 'entries');\n                  \n                  // Use the newly created lookup table\n                  correctedIntensity = intensity.map((value, idx) => value / newLookup[idx]);\n                } catch (error) {\n                  // Fallback path if rebuilding fails\n                  console.error('[SpectrometerMQTT] Failed to rebuild sensitivity factors lookup table:', error);\n                  console.warn('[SpectrometerMQTT] Using uncorrected intensity values');\n                  correctedIntensity = intensity;\n                }\n              }\n              \n              // Transform data to expected format for the graph\n              const graphData = {\n                pixelData: {\n                  timestamp: parsedPayload.timestamp,\n                  positions: parsedPayload.wavelengths,\n                  red: parsedPayload.red,\n                  green: parsedPayload.green,\n                  blue: parsedPayload.blue,\n                  intensity: correctedIntensity,\n                  lineLength: parsedPayload.wavelengths.length\n                }\n              };\n              \n              setProcessedData(graphData);\n              setUsingCropData(true);  // Flag that we're using crop data\n            }\n            \n            // Check if this has raw data from crop\n            else if (parsedPayload.raw_data) {\n              console.log('[SpectrometerMQTT] Received raw pixel data from crop');\n              \n              // Process raw data based on data_type\n              if (parsedPayload.data_type === 'raw_mono') {\n                // Extract first row if raw_data is 2D array, otherwise use as is\n                const rawIntensity = Array.isArray(parsedPayload.raw_data[0]) ? \n                  parsedPayload.raw_data[0] : parsedPayload.raw_data;\n                \n                const graphData = {\n                  pixelData: {\n                    timestamp: parsedPayload.timestamp,\n                    positions: parsedPayload.wavelengths,\n                    // Use raw data as the intensity values\n                    red: rawIntensity,\n                    green: rawIntensity,\n                    blue: rawIntensity,\n                    intensity: rawIntensity,\n                    lineLength: rawIntensity.length,\n                    isRawData: true,\n                    bitDepth: parsedPayload.bit_depth || 12,\n                    dataType: parsedPayload.data_type\n                  }\n                };\n                \n                setProcessedData(graphData);\n                setUsingCropData(true);\n              }\n            }\n            // Check if this is raw spectral data (wavelengths + raw channels)\n            else if (parsedPayload.wavelengths && (parsedPayload.raw_data || parsedPayload.raw_red)) {\n              console.log('[SpectrometerMQTT] Received raw spectral data');\n              setSpectrumData(parsedPayload);\n              \n              // Only switch to spectral data if we're not actively using crop data\n              if (!usingCropData) {\n                // Create graph data format for raw data\n                const graphData = {\n                  pixelData: {\n                    timestamp: parsedPayload.timestamp || Date.now(),\n                    positions: parsedPayload.wavelengths,\n                    isRawData: true,\n                    bitDepth: parsedPayload.bit_depth || 12,\n                    dataType: parsedPayload.data_type\n                  }\n                };\n                \n                // Handle different raw data formats\n                if (parsedPayload.data_type === 'raw_mono' && parsedPayload.raw_data) {\n                  // For monochrome, use raw_data for all channels\n                  graphData.pixelData.red = parsedPayload.raw_data;\n                  graphData.pixelData.green = parsedPayload.raw_data;\n                  graphData.pixelData.blue = parsedPayload.raw_data;\n                  graphData.pixelData.intensity = parsedPayload.raw_data;\n                  graphData.pixelData.lineLength = parsedPayload.raw_data.length;\n                } \n                else if ((parsedPayload.data_type === 'raw_rgb' || parsedPayload.data_type === 'raw_rgba') && \n                         parsedPayload.raw_red && parsedPayload.raw_green && parsedPayload.raw_blue) {\n                  // For RGB, use separate channels\n                  graphData.pixelData.red = parsedPayload.raw_red;\n                  graphData.pixelData.green = parsedPayload.raw_green;\n                  graphData.pixelData.blue = parsedPayload.raw_blue;\n                  // Calculate intensity as average of RGB channels\n                  const intensity = parsedPayload.red.map((val, idx) => \n                    (val + parsedPayload.green[idx] + parsedPayload.blue[idx]) / 3\n                  );\n                  graphData.pixelData.intensity = intensity;\n                  graphData.pixelData.lineLength = parsedPayload.raw_red.length;\n                }\n                \n                setProcessedData(graphData);\n              }\n            }\n            // Legacy support for traditional spectral data (wavelengths + intensities)\n            else if (parsedPayload.wavelengths && parsedPayload.intensities) {\n              console.log('[SpectrometerMQTT] Received traditional spectral data');\n              setSpectrumData(parsedPayload);\n              \n              // Only switch to spectral data if we're not actively using crop data\n              if (!usingCropData) {\n                // Normalize positions to 0-1 range\n                const wavelengthRange = [\n                  Math.min(...parsedPayload.wavelengths), \n                  Math.max(...parsedPayload.wavelengths)\n                ];\n                \n                const positions = parsedPayload.wavelengths.map(w => \n                  (w - wavelengthRange[0]) / (wavelengthRange[1] - wavelengthRange[0])\n                );\n                \n                // Create uniform intensity arrays for RGB\n                const intensity = parsedPayload.intensities;\n                \n                // Create graph data format\n                const graphData = {\n                  pixelData: {\n                    timestamp: parsedPayload.timestamp || Date.now(),\n                    positions: positions,\n                    red: intensity,\n                    green: intensity,\n                    blue: intensity,\n                    intensity: intensity,\n                    lineLength: intensity.length,\n                    isRawData: false\n                  }\n                };\n                \n                setProcessedData(graphData);\n              }\n            } else if (parsedPayload.error) {\n              console.warn(`[SpectrometerMQTT] Received error from backend: ${parsedPayload.error}`);\n              // Don't clear data on error - just leave the previous data\n            } else {\n              console.warn('[SpectrometerMQTT] Received data message with unexpected payload:', parsedPayload);\n            }\n          }\n        }\n\n      } catch (error) {\n        console.error('[SpectrometerMQTT] Error processing WebSocket message:', error, 'Raw:', event.data);\n      }\n    };\n\n    newWs.onerror = (error) => {\n      if (!isMounted) return;\n      console.error('[SpectrometerMQTT] WebSocket error:', error);\n    };\n\n    newWs.onclose = (event) => {\n      if (!isMounted) return;\n      console.log('[SpectrometerMQTT] WebSocket closed:', event.code, event.reason);\n      if (wsRef.current === newWs) {\n        wsRef.current = null;\n      }\n      // Don't clear data on disconnect - just keep the last values\n    };\n\n    // Cleanup function\n    return () => {\n      isMounted = false;\n      \n      // Store a reference to the current WebSocket\n      const ws = wsRef.current;\n      \n      // Important: Set wsRef.current to null BEFORE closing\n      // This prevents race conditions with the onopen callback\n      wsRef.current = null;\n      \n      if (ws) {\n        console.log('[SpectrometerMQTT] Closing WebSocket connection...');\n        try {\n          // Only close if it's still in a state that can be closed\n          if (ws.readyState === WebSocket.CONNECTING || \n              ws.readyState === WebSocket.OPEN) {\n            ws.close();\n          }\n        } catch (err) {\n          console.error('[SpectrometerMQTT] Error closing WebSocket:', err);\n        }\n      }\n    };\n\n  }, [detectorId]); // Reconnect if detectorId changes\n\n  // Handle crop data toggle\n  const handleCropDataToggle = (isEnabled) => {\n    setUsingCropData(isEnabled);\n  };\n  \n  // Save camera and calibration settings\n  const saveSettings = () => {\n    try {\n      // Get camera settings\n      const camSettings = cameraRef.current?.getSettings();\n      \n      // Get crop frame settings\n      const cropSettings = cameraRef.current?.getCropSettings();\n      \n      // Get calibration settings from graph component\n      const calSettings = graphRef.current?.getCalibrationSettings();\n      \n      if (!camSettings && !calSettings && !cropSettings) {\n        console.warn('No settings to save - components may not be mounted');\n        setSaveMessage('No settings to save');\n        setTimeout(() => setSaveMessage(''), 3000);\n        return;\n      }\n      \n      // Create a settings object to save\n      const settings = {\n        camera: camSettings || null,\n        calibration: calSettings || null,\n        cropFrame: cropSettings || null,\n        timestamp: new Date().toISOString(),\n        detectorId: detectorId || 'default',\n        // Save waterfall settings\n        waterfall: {\n          colorScheme: waterfallColorScheme\n        },\n        // Save frame accumulation settings\n        frameAccumulation: {\n          count: frameAccumCount,\n          isEnabled: isAccumulating\n        },\n        // Save peak markers settings if available from graph component\n        peakMarkers: graphRef.current?.getPeakSettings?.() || {\n          count: 3,\n          showMarkers: true\n        },\n        // Save component visibility states\n        visibilityState: {\n          camera: showCamera,\n          graph: showGraph,\n          waterfall: showWaterfall,\n          settings: showSettings\n        },\n        // Save crop data state\n        usingCropData: usingCropData\n      };\n      \n      // Save to localStorage\n      localStorage.setItem(`detector_settings_${detectorId || 'default'}`, JSON.stringify(settings));\n      \n      // Set save message for user feedback\n      setSaveMessage('Settings saved successfully');\n      setTimeout(() => setSaveMessage(''), 3000);\n    } catch (error) {\n      console.error('Failed to save settings:', error);\n      setSaveMessage('Error saving settings');\n      setTimeout(() => setSaveMessage(''), 3000);\n    }\n  };\n  \n  // Export settings to JSON file\n  const exportSettings = () => {\n    try {\n      // Get camera settings\n      const camSettings = cameraRef.current?.getSettings();\n      \n      // Get crop frame settings\n      const cropSettings = cameraRef.current?.getCropSettings();\n      \n      // Get calibration settings from graph component\n      const calSettings = graphRef.current?.getCalibrationSettings();\n      \n      if (!camSettings && !calSettings && !cropSettings) {\n        console.warn('No settings to export - components may not be mounted');\n        setSaveMessage('No settings to export');\n        setTimeout(() => setSaveMessage(''), 3000);\n        return;\n      }\n      \n      // Create a settings object to export\n      const settings = {\n        camera: camSettings || null,\n        calibration: calSettings || null,\n        cropFrame: cropSettings || null,\n        timestamp: new Date().toISOString(),\n        detectorId: detectorId || 'default',\n        // Export waterfall settings\n        waterfall: {\n          colorScheme: waterfallColorScheme\n        },\n        // Export frame accumulation settings\n        frameAccumulation: {\n          count: frameAccumCount,\n          isEnabled: isAccumulating\n        },\n        // Export peak markers settings if available from graph component\n        peakMarkers: graphRef.current?.getPeakSettings?.() || {\n          count: 3,\n          showMarkers: true\n        },\n        // Export component visibility states\n        visibilityState: {\n          camera: showCamera,\n          graph: showGraph,\n          waterfall: showWaterfall,\n          settings: showSettings\n        },\n        // Export crop data state\n        usingCropData: usingCropData\n      };\n      \n      // Create a file name with timestamp\n      const timestamp = new Date().toISOString().replace(/:/g, '-').replace(/\\./g, '_');\n      const fileName = `detector_settings_${detectorId || 'default'}_${timestamp}.json`;\n      \n      // Create a Blob with the JSON data\n      const blob = new Blob([JSON.stringify(settings, null, 2)], { type: 'application/json' });\n      \n      // Create a URL for the Blob\n      const url = URL.createObjectURL(blob);\n      \n      // Create a temporary link element to trigger the download\n      const link = document.createElement('a');\n      link.href = url;\n      link.download = fileName;\n      \n      // Append to the document, click, and remove\n      document.body.appendChild(link);\n      link.click();\n      \n      // Clean up\n      setTimeout(() => {\n        document.body.removeChild(link);\n        URL.revokeObjectURL(url);\n      }, 100);\n      \n      // Set save message for user feedback\n      setSaveMessage('Settings exported to file');\n      setTimeout(() => setSaveMessage(''), 3000);\n    } catch (error) {\n      console.error('Failed to export settings:', error);\n      setSaveMessage('Error exporting settings');\n      setTimeout(() => setSaveMessage(''), 3000);\n    }\n  };\n  \n  // Load saved camera and calibration settings\n  const loadSettings = () => {\n    try {\n      // Get settings from localStorage\n      const savedSettingsStr = localStorage.getItem(`detector_settings_${detectorId || 'default'}`);\n      if (!savedSettingsStr) {\n        setSaveMessage('No saved settings found');\n        setTimeout(() => setSaveMessage(''), 3000);\n        return;\n      }\n      \n      // Parse the settings\n      const savedSettings = JSON.parse(savedSettingsStr);\n      \n      // Apply camera settings if available\n      if (savedSettings.camera && cameraRef.current) {\n        try {\n          cameraRef.current.applySettings(savedSettings.camera);\n        } catch (err) {\n          console.error('Error applying camera settings:', err);\n        }\n      }\n      \n      // Apply crop frame settings if available\n      if (savedSettings.cropFrame && cameraRef.current?.applyCropSettings) {\n        try {\n          cameraRef.current.applyCropSettings(savedSettings.cropFrame);\n        } catch (err) {\n          console.error('Error applying crop frame settings:', err);\n        }\n      }\n      \n      // Apply calibration settings if available\n      if (savedSettings.calibration && graphRef.current) {\n        try {\n          graphRef.current.applyCalibrationSettings(savedSettings.calibration);\n          \n          // Rebuild sensitivity factors lookup when calibration is loaded\n          if (savedSettings.calibration.calibrationPoints && savedSettings.calibration.calibrationPoints.length >= 2) {\n            const point1 = savedSettings.calibration.calibrationPoints[0];\n            const point2 = savedSettings.calibration.calibrationPoints[1];\n            \n            const minWavelength = point1.wavelength - point1.position * \n              (point2.wavelength - point1.wavelength) / (point2.position - point1.position);\n            const maxWavelength = point2.wavelength + (1 - point2.position) * \n              (point2.wavelength - point1.wavelength) / (point2.position - point1.position);\n              \n            // Estimate the data length from the current processed data or use a reasonable default\n            const dataLength = processedData?.pixelData?.lineLength || 1024;\n            \n            // Create lookup table for sensitivity factors\n            const wavelengthKeys = Object.keys(spectralConfig.SENSITIVITY_FACTORS).map(key => parseFloat(key));\n            const wavelengthRange = maxWavelength - minWavelength;\n            const lookup = new Array(dataLength);\n            \n            for (let i = 0; i < dataLength; i++) {\n              // Scale position to calibrated wavelength range\n              const scaledPosition = i / (dataLength - 1);\n              const mappedWavelength = minWavelength + scaledPosition * wavelengthRange;\n              \n              // Find closest sensitivity factor\n              let closestWavelength = wavelengthKeys[0];\n              let minDiff = Math.abs(mappedWavelength - closestWavelength);\n              \n              for (let j = 1; j < wavelengthKeys.length; j++) {\n                const diff = Math.abs(mappedWavelength - wavelengthKeys[j]);\n                if (diff < minDiff) {\n                  minDiff = diff;\n                  closestWavelength = wavelengthKeys[j];\n                }\n              }\n              \n              // Store the sensitivity factor\n              lookup[i] = spectralConfig.SENSITIVITY_FACTORS[closestWavelength.toString()];\n            }\n            \n            setSensitivityFactorsLookup(lookup);\n            console.log('[SpectrometerMQTT] Built sensitivity factors lookup table with', lookup.length, 'entries');\n          }\n        } catch (err) {\n          console.error('Error applying calibration settings:', err);\n        }\n      }\n      \n      // Apply waterfall settings if available\n      if (savedSettings.waterfall?.colorScheme) {\n        setWaterfallColorScheme(savedSettings.waterfall.colorScheme);\n      }\n      \n      // Apply frame accumulation settings if available\n      if (savedSettings.frameAccumulation) {\n        if (typeof savedSettings.frameAccumulation.count === 'number') {\n          setFrameAccumCount(savedSettings.frameAccumulation.count);\n        }\n        if (typeof savedSettings.frameAccumulation.isEnabled === 'boolean') {\n          setIsAccumulating(savedSettings.frameAccumulation.isEnabled);\n        }\n      }\n      \n      // Apply peak markers settings if available\n      if (savedSettings.peakMarkers && graphRef.current?.applyPeakSettings) {\n        try {\n          graphRef.current.applyPeakSettings(savedSettings.peakMarkers);\n        } catch (err) {\n          console.error('Error applying peak markers settings:', err);\n        }\n      }\n      \n      // Apply component visibility state if available\n      if (savedSettings.visibilityState) {\n        if (typeof savedSettings.visibilityState.camera === 'boolean') {\n          setShowCamera(savedSettings.visibilityState.camera);\n        }\n        if (typeof savedSettings.visibilityState.graph === 'boolean') {\n          setShowGraph(savedSettings.visibilityState.graph);\n        }\n        if (typeof savedSettings.visibilityState.waterfall === 'boolean') {\n          setShowWaterfall(savedSettings.visibilityState.waterfall);\n        }\n        if (typeof savedSettings.visibilityState.settings === 'boolean') {\n          setShowSettings(savedSettings.visibilityState.settings);\n        }\n      }\n      \n      // Apply crop data state if available\n      if (typeof savedSettings.usingCropData === 'boolean') {\n        setUsingCropData(savedSettings.usingCropData);\n      }\n      \n      // Make sure camera is started automatically\n      setTimeout(async () => {\n        if (cameraRef.current && typeof cameraRef.current.startCamera === 'function') {\n          try {\n            await cameraRef.current.startCamera();\n            console.log('Camera started automatically after loading settings');\n          } catch (err) {\n            console.error('Failed to auto-start camera:', err);\n          }\n        }\n      }, 500); // Short delay to allow settings to be applied\n      \n      // Set save message for user feedback\n      setSaveMessage('Settings loaded successfully');\n      setTimeout(() => setSaveMessage(''), 3000);\n    } catch (error) {\n      console.error('Failed to load settings:', error);\n      setSaveMessage('Error loading settings');\n      setTimeout(() => setSaveMessage(''), 3000);\n    }\n  };\n  \n  // Import settings from a JSON file\n  const importSettings = () => {\n    try {\n      // Create a file input element\n      const fileInput = document.createElement('input');\n      fileInput.type = 'file';\n      fileInput.accept = '.json';\n      \n      // Handle file selection\n      fileInput.onchange = (event) => {\n        const file = event.target.files[0];\n        if (!file) return;\n        \n        const reader = new FileReader();\n        \n        reader.onload = (e) => {\n          try {\n            // Parse the file contents\n            const importedSettings = JSON.parse(e.target.result);\n            \n            // Apply camera settings if available\n            if (importedSettings.camera && cameraRef.current) {\n              try {\n                cameraRef.current.applySettings(importedSettings.camera);\n              } catch (err) {\n                console.error('Error applying imported camera settings:', err);\n              }\n            }\n            \n            // Apply crop frame settings if available\n            if (importedSettings.cropFrame && cameraRef.current?.applyCropSettings) {\n              try {\n                cameraRef.current.applyCropSettings(importedSettings.cropFrame);\n              } catch (err) {\n                console.error('Error applying imported crop frame settings:', err);\n              }\n            }\n            \n            // Apply calibration settings if available\n            if (importedSettings.calibration && graphRef.current) {\n              try {\n                graphRef.current.applyCalibrationSettings(importedSettings.calibration);\n              } catch (err) {\n                console.error('Error applying imported calibration settings:', err);\n              }\n            }\n            \n            // Apply waterfall settings if available\n            if (importedSettings.waterfall?.colorScheme) {\n              setWaterfallColorScheme(importedSettings.waterfall.colorScheme);\n            }\n            \n            // Apply frame accumulation settings if available\n            if (importedSettings.frameAccumulation) {\n              if (typeof importedSettings.frameAccumulation.count === 'number') {\n                setFrameAccumCount(importedSettings.frameAccumulation.count);\n              }\n              if (typeof importedSettings.frameAccumulation.isEnabled === 'boolean') {\n                setIsAccumulating(importedSettings.frameAccumulation.isEnabled);\n              }\n            }\n            \n            // Apply peak markers settings if available\n            if (importedSettings.peakMarkers && graphRef.current?.applyPeakSettings) {\n              try {\n                graphRef.current.applyPeakSettings(importedSettings.peakMarkers);\n              } catch (err) {\n                console.error('Error applying peak markers settings:', err);\n              }\n            }\n            \n            // Apply component visibility state if available\n            if (importedSettings.visibilityState) {\n              if (typeof importedSettings.visibilityState.camera === 'boolean') {\n                setShowCamera(importedSettings.visibilityState.camera);\n              }\n              if (typeof importedSettings.visibilityState.graph === 'boolean') {\n                setShowGraph(importedSettings.visibilityState.graph);\n              }\n              if (typeof importedSettings.visibilityState.waterfall === 'boolean') {\n                setShowWaterfall(importedSettings.visibilityState.waterfall);\n              }\n              if (typeof importedSettings.visibilityState.settings === 'boolean') {\n                setShowSettings(importedSettings.visibilityState.settings);\n              }\n            }\n            \n            // Apply crop data state if available\n            if (typeof importedSettings.usingCropData === 'boolean') {\n              setUsingCropData(importedSettings.usingCropData);\n            }\n            \n            // Make sure camera is started automatically\n            setTimeout(async () => {\n              if (cameraRef.current && typeof cameraRef.current.startCamera === 'function') {\n                try {\n                  await cameraRef.current.startCamera();\n                  console.log('Camera started automatically after loading settings');\n                } catch (err) {\n                  console.error('Failed to auto-start camera:', err);\n                }\n              }\n            }, 500); // Short delay to allow settings to be applied\n            \n            // Set save message for user feedback\n            setSaveMessage('Settings imported successfully');\n            setTimeout(() => setSaveMessage(''), 3000);\n          } catch (parseError) {\n            console.error('Failed to parse imported settings file:', parseError);\n            setSaveMessage('Error: Invalid settings file');\n            setTimeout(() => setSaveMessage(''), 3000);\n          }\n        };\n        \n        reader.onerror = () => {\n          setSaveMessage('Error reading file');\n          setTimeout(() => setSaveMessage(''), 3000);\n        };\n        \n        // Read the file as text\n        reader.readAsText(file);\n      };\n      \n      // Trigger file selection dialog\n      fileInput.click();\n    } catch (error) {\n      console.error('Failed to import settings:', error);\n      setSaveMessage('Error importing settings');\n      setTimeout(() => setSaveMessage(''), 3000);\n    }\n  };\n  \n  // Handler for panel resizing - completely rewritten for reliability\n  const handlePanelResizeStart = (e) => {\n    e.preventDefault();\n    e.stopPropagation();\n    \n    // Get initial coordinates and size\n    const startX = e.clientX;\n    const startY = e.clientY;\n    const startWidth = panelRef.current?.offsetWidth || panelSize.width;\n    const startHeight = panelRef.current?.offsetHeight || panelSize.height;\n    \n    // Show resize feedback\n    setIsResizingPanel(true);\n    setShowResizeInfo(true);\n    \n    // Define move handler\n    function handleMouseMove(moveEvent) {\n      const deltaX = moveEvent.clientX - startX;\n      const deltaY = moveEvent.clientY - startY;\n      \n      const newWidth = Math.max(400, startWidth + deltaX);\n      const newHeight = Math.max(300, startHeight + deltaY);\n      \n      // Update panel size\n      setPanelSize({\n        width: newWidth,\n        height: newHeight\n      });\n      \n      // Prevent default to avoid text selection during resize\n      moveEvent.preventDefault();\n    }\n    \n    // Define up handler\n    function handleMouseUp() {\n      // Clean up\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n      \n      setIsResizingPanel(false);\n      setTimeout(() => setShowResizeInfo(false), 800);\n    }\n    \n    // Attach handlers to document to capture events outside component\n    document.addEventListener('mousemove', handleMouseMove);\n    document.addEventListener('mouseup', handleMouseUp);\n  };\n  \n  // Toggle visibility of subcomponents\n  const toggleCamera = () => setShowCamera(!showCamera);\n  const toggleGraph = () => setShowGraph(!showGraph);\n  const toggleWaterfall = () => setShowWaterfall(!showWaterfall);\n  const toggleSettings = () => setShowSettings(!showSettings);\n  \n  // Styles for toggle buttons\n  const getToggleButtonStyle = (isActive) => ({\n    ...buttonVariants.smallSecondary,\n    opacity: isActive ? 1 : 0.5,\n    marginRight: '4px',\n    marginBottom: '4px'\n  });\n  \n  // Handle subcomponent resize events\n  const handleCameraResize = (newSize) => {\n    console.log('Camera resized:', newSize);\n    // Additional logic if needed\n  };\n  \n  const handleGraphResize = (newSize) => {\n    console.log('Graph resized:', newSize);\n    // Additional logic if needed\n  };\n  \n  const handleWaterfallResize = (newSize) => {\n    console.log('Waterfall resized:', newSize);\n    // Additional logic if needed\n  };\n  \n  // Handle settings changes\n  const handleSettingsChange = (settings) => {\n    console.log('Settings changed:', settings);\n    // Update relevant state/behavior based on settings\n  };\n  \n  // Render panel content\n  if (!detector) return null;\n  \n  return (\n    <DraggablePanel \n      title={`MQTT Spectrometer: ${detector.label || detector.id}`}\n      initialPosition={initialPosition}\n      width={panelSize.width}\n      height={panelSize.height}\n      onClose={onClose}\n    >\n      <div \n        ref={panelRef}\n        style={{\n          ...styles.container,\n          width: `${panelSize.width}px`,\n          height: `${panelSize.height}px`,\n          minHeight: '300px',\n          position: 'relative',\n          border: isResizingPanel ? '1px dashed #4CAF50' : 'none',\n          transition: isResizingPanel ? 'none' : 'border 0.3s ease',\n        }}\n      >\n        {/* Top control bar */}\n        <div style={styles.controlBar}>\n          <div>\n            <span style={styles.controlLabel}>Components:</span>\n            \n            <button \n              onClick={toggleCamera} \n              style={getToggleButtonStyle(showCamera)}\n            >\n              {showCamera ? '📹 Hide Camera' : '📹 Show Camera'}\n            </button>\n            \n            <button \n              onClick={toggleGraph} \n              style={getToggleButtonStyle(showGraph)}\n            >\n              {showGraph ? '📊 Hide Graph' : '📊 Show Graph'}\n            </button>\n            \n            <button \n              onClick={toggleWaterfall} \n              style={getToggleButtonStyle(showWaterfall)}\n            >\n              {showWaterfall ? '🌊 Hide Waterfall' : '🌊 Show Waterfall'}\n            </button>\n            \n            <button \n              onClick={toggleSettings} \n              style={getToggleButtonStyle(showSettings)}\n            >\n              {showSettings ? '⚙️ Hide Settings' : '⚙️ Show Settings'}\n            </button>\n            \n            <span style={{ marginLeft: '15px', borderLeft: '1px solid rgba(255, 255, 255, 0.2)', paddingLeft: '10px' }}>\n              <button \n                onClick={saveSettings} \n                style={{\n                  ...buttonVariants.smallPrimary,\n                  marginRight: '4px',\n                  marginBottom: '4px',\n                  backgroundColor: 'rgba(50, 150, 50, 0.7)'\n                }}\n                title=\"Save camera and calibration settings to browser storage\"\n              >\n                💾 Save Settings\n              </button>\n              \n              <button \n                onClick={exportSettings} \n                style={{\n                  ...buttonVariants.smallPrimary,\n                  marginRight: '4px',\n                  marginBottom: '4px',\n                  backgroundColor: 'rgba(120, 120, 30, 0.7)'\n                }}\n                title=\"Export camera and calibration settings to JSON file\"\n              >\n                📤 Export Settings\n              </button>\n              \n              <button \n                onClick={loadSettings} \n                style={{\n                  ...buttonVariants.smallPrimary,\n                  marginRight: '4px',\n                  marginBottom: '4px',\n                  backgroundColor: 'rgba(50, 100, 150, 0.7)'\n                }}\n                title=\"Load saved camera and calibration settings from browser storage\"\n              >\n                📥 Load Settings\n              </button>\n              \n              <button \n                onClick={importSettings} \n                style={{\n                  ...buttonVariants.smallPrimary,\n                  marginRight: '4px',\n                  marginBottom: '4px',\n                  backgroundColor: 'rgba(120, 70, 150, 0.7)'\n                }}\n                title=\"Import camera and calibration settings from JSON file\"\n              >\n                📁 Import File\n              </button>\n              \n              {saveMessage && (\n                <span style={{\n                  fontSize: '12px',\n                  backgroundColor: 'rgba(0, 0, 0, 0.6)',\n                  padding: '2px 6px',\n                  borderRadius: '3px',\n                  marginLeft: '8px'\n                }}>\n                  {saveMessage}\n                </span>\n              )}\n            </span>\n          </div>\n        </div>\n        \n        {/* Two-column layout container */}\n        <div style={styles.columnsContainer}>\n          {/* Left column - Camera component */}\n          <div style={{ \n            display: showCamera ? 'block' : 'none',\n            flex: '1 1 50%',\n            minWidth: '320px',\n            maxWidth: '650px',\n            marginRight: '10px'\n          }}>\n            <MQTTCameraComponent\n              ref={cameraRef}\n              onResize={handleCameraResize}\n              detectorId={detectorId}\n            />\n          </div>\n          \n          {/* Right column with multiple components */}\n          <div style={{\n            ...styles.rightColumn,\n            flex: '1 1 50%'\n          }}>\n            {/* Graph component */}\n            {showGraph && (\n              <MQTTGraphComponent \n                ref={graphRef}\n                onResize={handleGraphResize}\n                lineData={processedData}  // Use processedData instead of spectrumData\n                // Pass the frame accumulation props up to parent to manage\n                onFrameAccumCountChange={handleFrameAccumCountChange}\n                onAccumulationToggle={handleAccumulationToggle}\n              />\n            )}\n            \n            {/* Waterfall component */}\n            {showWaterfall && (\n              <MQTTWaterfallComponent \n                onResize={handleWaterfallResize}\n                lineData={processedData}  // Use processedData instead of spectrumData\n                frameAccumCount={frameAccumCount}\n                isAccumulating={isAccumulating}\n                colorScale={waterfallColorScheme}\n                onColorScaleChange={handleWaterfallColorSchemeChange}\n              />\n            )}\n            \n            {/* Settings component */}\n            {showSettings && (\n              <MQTTSettingsComponent \n                onSettingChange={(setting, value) => console.log('Setting changed:', setting, value)}\n              />\n            )}\n          </div>\n        </div>\n        \n        {/* Show resize info when active */}\n        {showResizeInfo && (\n          <div style={{\n            position: 'absolute',\n            right: '30px',\n            bottom: '30px',\n            padding: '4px 8px',\n            background: 'rgba(0, 0, 0, 0.6)',\n            color: 'white',\n            borderRadius: '3px',\n            fontSize: '12px',\n            zIndex: 1000\n          }}>\n            {Math.round(panelSize.width)} x {Math.round(panelSize.height)}\n          </div>\n        )}\n        \n        {/* Panel resize handle - make sure this comes last */}\n        <div \n          style={styles.resizeHandle}\n          onMouseDown={handlePanelResizeStart}\n          title=\"Drag to resize panel\"\n        >\n          <svg \n            width=\"20\" \n            height=\"20\" \n            viewBox=\"0 0 20 20\" \n            style={{ display: 'block' }}\n          >\n            <rect width=\"20\" height=\"20\" fill=\"transparent\" />\n            <path \n              d=\"M14,6 L6,14 M17,9 L9,17 M17,13 L13,17\" \n              stroke=\"white\" \n              strokeWidth=\"2\"\n              strokeLinecap=\"round\"\n            />\n          </svg>\n        </div>\n      </div>\n    </DraggablePanel>\n  );\n};\n\nexport default SpectrometerMQTT; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}