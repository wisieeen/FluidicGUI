{"ast":null,"code":"var _jsxFileName = \"E:\\\\flow chemistry\\\\fluidicGUI\\\\frontend\\\\fluidicgui\\\\src\\\\components\\\\Simulation\\\\Simulation.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useCallback, useRef, Suspense } from 'react';\nimport { ReactFlowProvider, useNodesState, useEdgesState } from 'react-flow-renderer';\nimport PumpActions from './NodeActions/PumpActions';\nimport DraggablePanel from './DraggablePanel';\nimport { convertToHardwareValuesPump } from '../../utils/pumpCalculations';\nimport { useButtonStyles } from '../../styles/ButtonStyleProvider';\nimport { backgroundVariants } from '../../styles/backgroundStyles';\nimport { findOutletNode, findFurthestNode, orderNodesByDistance, calculateEdgeVolume, getVolumeBetweenNodes, findConnectedPump, getPumpSpeed, getPumpsBetweenPositions, cleanAndSortEventList, getPumpSpeedAtTime, sendEventsToDevices, setOfMainLineNodes, setOfSecondaryLineNodes } from '../../utils/simulationUtils';\nimport './simulation.css'; // We'll create this CSS file\nimport SvgDefs from './SvgDefs';\nimport { calculateEdgePoints, createLabels } from '../../utils/flowchartUtils';\nimport USBSpectrometer from './USBSpectrometer';\nimport SpectrometerMQTT from './SpectrometerMQTT';\nimport PumpPanel from './PumpPanel';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst Simulation = ({\n  nodes = [],\n  edges = [],\n  droplets = [],\n  selectedCarrierPumps = [],\n  onBack,\n  onNext\n}) => {\n  _s();\n  var _dropletHistory$curre, _selectedNode$data, _selectedNode$data2, _selectedNode$data3;\n  const buttonVariants = useButtonStyles();\n  const [graphData, setGraphData] = useState({\n    nodes: [],\n    links: []\n  });\n  const [simulationDroplets, setSimulationDroplets] = useState([]);\n  const [isSimulationRunning, setIsSimulationRunning] = useState(false);\n  const [key, setKey] = useState(0);\n  const [currentTime, setCurrentTime] = useState(0);\n  const [timeScale, setTimeScale] = useState(1); // Default 1x speed\n  const animationFrameRef = useRef();\n  const lastFrameTimeRef = useRef();\n  const [currentBlockDroplets, setCurrentBlockDroplets] = useState([]);\n  const [dropletHistory, setDropletHistory] = useState([]);\n  const [currentTimepoint, setCurrentTimepoint] = useState(0);\n  const [pumpEvents, setPumpEvents] = useState([]);\n  const [detectorEvents, setDetectorEvents] = useState([]);\n  const [displayPumpSpeeds, setDisplayPumpSpeeds] = useState(false);\n  const [displayNodeIds, setDisplayNodeIds] = useState(false);\n  const [displayDropletInfo, setDisplayDropletInfo] = useState(false);\n  const [displayDropletGaps, setDisplayDropletGaps] = useState(true);\n  const [displayEdgeLabels, setDisplayEdgeLabels] = useState(false);\n  const [isDisplayMenuOpen, setDisplayMenuOpen] = useState(false);\n  const [displayTimelineDropletInfo, setDisplayTimelineDropletInfo] = useState(false);\n  const [displayDetectorEvents, setDisplayDetectorEvents] = useState(false);\n  const displayMenuRef = useRef(null);\n  const [selectedNode, setSelectedNode] = useState(null);\n  const [ws, setWs] = useState(null);\n  const [pumpPanelPosition, setPumpPanelPosition] = useState({\n    x: window.innerWidth - 300,\n    y: 100\n  });\n  const [visiblePumpPanel, setVisiblePumpPanel] = useState(null);\n  const [isSendingEvents, setIsSendingEvents] = useState(false);\n  const graphRefs = useRef({});\n  const [overlayComponent, setOverlayComponent] = useState(null);\n\n  // Add at the beginning of the component, after the state initialization\n  useEffect(() => {\n    // Log all nodes and their types for debugging\n    console.log('All nodes:', nodes);\n    if (nodes && nodes.length > 0) {\n      console.log('Node types in simulation:', nodes.map(node => {\n        var _node$data;\n        return {\n          id: node.id,\n          type: node.type,\n          dataType: (_node$data = node.data) === null || _node$data === void 0 ? void 0 : _node$data.type\n        };\n      }));\n    }\n  }, [nodes]);\n  useEffect(() => {\n    // Create WebSocket connection\n    const websocket = new WebSocket('ws://localhost:4000');\n    websocket.onopen = () => {\n      console.log('Connected to WebSocket server');\n    };\n    websocket.onerror = error => {\n      console.error('WebSocket error:', error);\n    };\n    setWs(websocket);\n\n    // Cleanup on unmount\n    return () => {\n      if (websocket) {\n        websocket.close();\n      }\n    };\n  }, []);\n  const sendingEventsToDevices = () => {\n    setIsSendingEvents(true);\n    sendEventsToDevices(pumpEvents, ws, nodes);\n    // Reset simulation state\n    setCurrentTime(0);\n    setCurrentTimepoint(0);\n    setIsSimulationRunning(true);\n    setDropletHistory([]);\n    // Generate new event list\n    generateEventList([{\n      droplets: droplets\n    }]);\n  };\n\n  // Add effect to handle automatic memory addition when events are being sent\n  useEffect(() => {\n    if (isSendingEvents) {\n      // Get all graph refs and add data to memory\n      Object.values(graphRefs.current).forEach(graphRef => {\n        if (graphRef && graphRef.current && graphRef.current.addToMemory) {\n          graphRef.current.addToMemory();\n        }\n      });\n    }\n  }, [isSendingEvents]);\n  const eventType = ['setPumpSpeed', 'setThermostatTemperature', 'setLedIntensity', 'wait', 'blockEnd'];\n  const calculateVolumesBetweenThermostats = graphData => {\n    // Find outlet node first\n    const outletNode = findOutletNode(graphData.nodes);\n    const visited = new Set();\n    const queue = [[outletNode.id, 0, []]]; // [nodeId, accumulated volume, path of thermostats]\n    const thermostatVolumes = [];\n    while (queue.length > 0) {\n      let [currentNodeId, accumulatedVolume, thermostatPath] = queue.shift();\n      const currentNode = graphData.nodes.find(n => n.id === currentNodeId);\n      if (!currentNode) continue;\n\n      // Track all visited nodes to prevent infinite loops\n      if (visited.has(currentNodeId)) continue;\n      visited.add(currentNodeId);\n\n      // If we found a thermostat, add it to the path\n      let updatedPath = [...thermostatPath];\n      if (currentNode.type === 'thermostat') {\n        if (thermostatPath.length > 0) {\n          thermostatVolumes.push({\n            startThermostatId: thermostatPath[thermostatPath.length - 1],\n            endThermostatId: currentNodeId,\n            volume: accumulatedVolume\n          });\n        }\n        updatedPath.push(currentNodeId);\n        // Reset accumulated volume after finding a thermostat\n        accumulatedVolume = 0;\n      }\n\n      // Find all connected edges and nodes\n      const connectedEdges = graphData.links.filter(link => link.source === currentNodeId || link.target === currentNodeId);\n      for (const edge of connectedEdges) {\n        const nextNodeId = edge.source === currentNodeId ? edge.target : edge.source;\n        const nextNode = graphData.nodes.find(n => n.id === nextNodeId);\n\n        // Skip paths to pumps\n        if (nextNode && nextNode.type !== 'pump') {\n          const edgeVolume = calculateEdgeVolume(edge);\n          queue.push([nextNodeId, accumulatedVolume + edgeVolume, updatedPath]);\n        }\n      }\n    }\n    return thermostatVolumes;\n  };\n  //add something to handle lack of thermostat\n  const divideDropletsIntoBlocks = (droplets, thermostatVolumes) => {\n    if (thermostatVolumes.length === 0) {\n      return [{\n        droplets: droplets,\n        thermostatId: null,\n        totalVolume: droplets.reduce((acc, droplet) => acc + droplet.actualVolume, 0),\n        temperature: null,\n        time: null\n      }];\n    }\n    const furthestNode = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links);\n    const volumeToFurthestNode = getVolumeBetweenNodes(thermostatVolumes[0].endThermostatId, furthestNode.id, graphData.nodes, graphData.links);\n    if (!droplets.length || !thermostatVolumes.length) return [];\n    const blocks = [];\n    let currentBlock = {\n      droplets: [],\n      thermostatId: thermostatVolumes[0].endThermostatId,\n      totalVolume: 0,\n      temperature: null,\n      time: null\n    };\n\n    // Helper to finalize a block and start a new one\n    const finalizeBlock = (thermostatId, temperature, time) => {\n      if (currentBlock.droplets.length > 0) {\n        // Add volumeToFurthestNode to the surfixVolume of the last droplet in the block\n        const lastDroplet = currentBlock.droplets[currentBlock.droplets.length - 1];\n        const surfixParam = lastDroplet.parameters.find(p => p.name === 'surfixVolume');\n        if (surfixParam) {\n          surfixParam.value = Math.max(volumeToFurthestNode, surfixParam.value);\n        } else {\n          lastDroplet.parameters.push({\n            name: 'surfixVolume',\n            value: volumeToFurthestNode\n          });\n        }\n        blocks.push({\n          ...currentBlock\n        });\n      }\n      currentBlock = {\n        droplets: [],\n        thermostatId: thermostatId,\n        totalVolume: 0,\n        temperature: temperature,\n        time: time\n      };\n    };\n\n    // Process droplets in order\n    for (let i = 0; i < droplets.length; i++) {\n      var _droplet$parameters$f, _droplet$parameters$f2, _droplet$parameters$f3, _droplet$parameters$f4, _droplet$parameters$f5;\n      const droplet = droplets[i];\n      const temperature = (_droplet$parameters$f = droplet.parameters.find(p => p.name === 'temperature')) === null || _droplet$parameters$f === void 0 ? void 0 : _droplet$parameters$f.value;\n      const time = (_droplet$parameters$f2 = droplet.parameters.find(p => p.name === 'time')) === null || _droplet$parameters$f2 === void 0 ? void 0 : _droplet$parameters$f2.value;\n\n      // Start new block if temperature or time changes, or if volume limit exceeded\n      const relevantVolume = thermostatVolumes.find(tv => tv.startThermostatId === currentBlock.thermostatId || tv.endThermostatId === currentBlock.thermostatId);\n      let dropletVolume = (_droplet$parameters$f3 = droplet.parameters.find(p => p.name === 'volume')) === null || _droplet$parameters$f3 === void 0 ? void 0 : _droplet$parameters$f3.value;\n      dropletVolume += (_droplet$parameters$f4 = droplet.parameters.find(p => p.name === 'prefixVolume')) === null || _droplet$parameters$f4 === void 0 ? void 0 : _droplet$parameters$f4.value;\n      if (currentBlock.temperature !== temperature || currentBlock.time !== time || relevantVolume && currentBlock.totalVolume + dropletVolume > relevantVolume.volume) {\n        finalizeBlock(thermostatVolumes[0].endThermostatId, temperature, time);\n      }\n      dropletVolume += (_droplet$parameters$f5 = droplet.parameters.find(p => p.name === 'surfixVolume')) === null || _droplet$parameters$f5 === void 0 ? void 0 : _droplet$parameters$f5.value;\n      // Add droplet to current block\n      currentBlock.droplets.push(droplet);\n      currentBlock.totalVolume += dropletVolume;\n      currentBlock.temperature = temperature;\n      currentBlock.time = time;\n    }\n\n    // Finalize last block\n    finalizeBlock(null, null, null);\n    return blocks;\n  };\n  function printDropletFrontPositionsAndSpeeds(droplets) {\n    droplets.forEach(droplet => {\n      console.log(`Droplet ID: ${droplet.id}, Front Volumetric Position: ${droplet.frontVolumetricPosition}, Front time to next node  : ${droplet.frontTimeToReachNextNode}, Front Volumetric Distance to next node: ${droplet.frontVolumetricDistanceToNextNode}, Rear Volumetric Position: ${droplet.rearVolumetricPosition}, Rear time to next node: ${droplet.rearTimeToReachNextNode}, Rear Volumetric Distance to next node: ${droplet.rearVolumetricDistanceToNextNode}, frontNextNodeID: ${droplet.frontNextNodeID}, rearNextNodeID: ${droplet.rearNextNodeID}`);\n    });\n  }\n  const extractPumpEvents = eventList => {\n    // eventList is now an array of arrays, where each inner array contains events for a specific pump\n    return eventList.flat() // Flatten the array of arrays\n    .filter(event => event.type === 'setPumpSpeed').sort((a, b) => a.time - b.time);\n  };\n  const extractDetectorEvents = eventList => {\n    // Extract detector/spectrometer measurement events\n    return eventList.flat() // Flatten the array of arrays\n    .filter(event => event.type === 'setDetectorMeasurement').sort((a, b) => a.time - b.time);\n  };\n  const getDetectorEventsAtTime = (detectorId, detectorEvents, currentTime) => {\n    return detectorEvents.filter(event => event.target === detectorId && Math.abs(event.time - currentTime) < 0.1 // Within 0.1 second tolerance\n    );\n  };\n  const recalculateEventListForDevices = eventList => {\n    const deviceEventMap = new Map();\n    const convertPumpEvent = (event, deviceProperties) => {\n      var _deviceProperties$fin, _deviceProperties$fin2, _deviceProperties$fin3, _deviceProperties$fin4;\n      // Find properties by name from the properties array\n      const syringeDiameter = ((_deviceProperties$fin = deviceProperties.find(p => p.name === 'diameter')) === null || _deviceProperties$fin === void 0 ? void 0 : _deviceProperties$fin.default) || 0;\n      const syringeLength = ((_deviceProperties$fin2 = deviceProperties.find(p => p.name === 'length')) === null || _deviceProperties$fin2 === void 0 ? void 0 : _deviceProperties$fin2.default) || 0;\n      const stepsPerRevolution = ((_deviceProperties$fin3 = deviceProperties.find(p => p.name === 'steps per revolution')) === null || _deviceProperties$fin3 === void 0 ? void 0 : _deviceProperties$fin3.default) || 0;\n      const lead = ((_deviceProperties$fin4 = deviceProperties.find(p => p.name === 'lead')) === null || _deviceProperties$fin4 === void 0 ? void 0 : _deviceProperties$fin4.default) || 0;\n      const syringeArea = Math.PI * Math.pow(syringeDiameter / 2, 2);\n      const linearSpeed = Math.abs(event.value) / syringeArea;\n      const stepsPerMm = stepsPerRevolution / lead;\n      const stepsPerSecond = linearSpeed * stepsPerMm;\n      const delayMicroseconds = stepsPerSecond > 0 ? Math.round(1000000 / stepsPerSecond) : 0;\n      return {\n        target: event.target,\n        time: Math.round(event.time * 1000000),\n        delay: delayMicroseconds\n      };\n    };\n    const convertThermostatEvent = (event, deviceProperties) => {\n      // Placeholder for thermostat conversion logic\n      return {\n        target: event.target,\n        time: Math.round(event.time * 1000000),\n        temperature: event.value\n        // Add other thermostat-specific parameters here\n      };\n    };\n    const convertLedEvent = (event, deviceProperties) => {\n      // Placeholder for LED conversion logic\n      return {\n        target: event.target,\n        time: Math.round(event.time * 1000000),\n        intensity: event.value\n        // Add other LED-specific parameters here\n      };\n    };\n    const convertDetectorEvent = (event, deviceProperties) => {\n      // Placeholder for detector conversion logic\n      return {\n        target: event.target,\n        time: Math.round(event.time * 1000000),\n        setting: event.value\n        // Add other detector-specific parameters here\n      };\n    };\n    eventList.forEach(deviceEventList => {\n      if (!deviceEventList.length) return;\n      const targetId = deviceEventList[0].target;\n      const deviceNode = nodes.find(node => node.id === targetId);\n      if (!deviceNode || !deviceNode.data) {\n        console.error(`Device node or data not found for ID: ${targetId}`);\n        return;\n      }\n      const deviceEvents = deviceEventList.map(event => {\n        switch (event.type) {\n          case 'setPumpSpeed':\n            return convertPumpEvent(event, deviceNode.data.properties);\n          case 'setThermostatTemperature':\n            return convertThermostatEvent(event, deviceNode.data.properties);\n          case 'setLedIntensity':\n            return convertLedEvent(event, deviceNode.data.properties);\n          case 'setDetectorSetting':\n            return convertDetectorEvent(event, deviceNode.data.properties);\n          default:\n            console.warn(`Unknown event type: ${event.type}`);\n            return null;\n        }\n      }).filter(Boolean); // Remove any null events\n\n      if (deviceEvents.length > 0) {\n        deviceEventMap.set(targetId, deviceEvents);\n      }\n    });\n    console.log('deviceEventMap: ', Array.from(deviceEventMap.values()));\n    return Array.from(deviceEventMap.values());\n  };\n  const generateEventList = blocks => {\n    // Early exit if blocks array is invalid\n    if (!blocks || !Array.isArray(blocks) || blocks.length === 0) {\n      console.warn('No valid blocks found for event generation');\n      return [];\n    }\n    const orderedNodes = orderNodesByDistance(findOutletNode(graphData.nodes), graphData.nodes, graphData.links);\n    console.log('orderedNodes: ', orderedNodes);\n\n    // Early exit if no ordered nodes\n    if (!orderedNodes || orderedNodes.length === 0) {\n      console.warn('No ordered nodes found for event generation');\n      return [];\n    }\n    let eventList = [];\n    let dropletSnapshot = [];\n\n    // Validate block droplets\n    if (!blocks[0] || !blocks[0].droplets || !Array.isArray(blocks[0].droplets) || blocks[0].droplets.length === 0) {\n      console.warn('No valid droplets found in blocks for event generation');\n      return [];\n    }\n    const i = 0;\n    const currentBlockDroplets = blocks[i].droplets;\n\n    // Add fallback for volumetricSpeed in case it's not found\n    const dropletWithParams = currentBlockDroplets.find(d => d && d.parameters && Array.isArray(d.parameters));\n    if (!dropletWithParams) {\n      console.warn('No droplet with valid parameters found');\n      return [];\n    }\n\n    // Make sure we can find the volumetricSpeed parameter or use a default\n    const volumetricSpeedParam = dropletWithParams.parameters.find(p => p && p.name === 'volumetricSpeed');\n    const commonVolumetricSpeed = (volumetricSpeedParam === null || volumetricSpeedParam === void 0 ? void 0 : volumetricSpeedParam.value) || 1;\n    console.log('Using volumetricSpeed:', commonVolumetricSpeed);\n\n    //adds some parameters to nodes\n    orderedNodes.forEach(node => {\n      node.inletVolumetricSpeed = commonVolumetricSpeed;\n      node.outletVolumetricSpeed = commonVolumetricSpeed;\n      const pump = findConnectedPump(node.node.id, graphData.nodes, graphData.links);\n      if (pump) {\n        node.connectedPump = pump;\n      } else {\n        node.connectedPump = 0;\n      }\n      node.connectedPumpRatio = 0;\n      node.connectedPumpSpeedAtPause = 0;\n      node.pumpSpeedMultiplier = 1;\n      //node.requestedRatio = 0;\n      node.pauseLevel = 0;\n    });\n    //ustawia carrier pump na odpowiednią predkość\n    const carrierPumpConnector = graphData.links.find(link => link.source === selectedCarrierPumps[0]).target;\n    if (carrierPumpConnector) {\n      const connectorNode = orderedNodes.find(node => node.node.id === carrierPumpConnector);\n      connectorNode.inletVolumetricSpeed = commonVolumetricSpeed;\n      connectorNode.outletVolumetricSpeed = commonVolumetricSpeed;\n      connectorNode.connectedPump = graphData.nodes.find(node => node.id === selectedCarrierPumps[0]);\n      connectorNode.connectedPumpRatio = 1;\n      connectorNode.connectedPumpSpeedAtPause = commonVolumetricSpeed;\n      //connectorNode.requestedRatio = 0;\n      connectorNode.pauseLevel = 0;\n    }\n    let event = {\n      //it is ok\n      type: 'setPumpSpeed',\n      target: selectedCarrierPumps[0],\n      time: 0,\n      value: commonVolumetricSpeed\n    };\n    eventList.push(event);\n    orderedNodes.filter(node => node.node.type === 'pump' && node.node.id !== selectedCarrierPumps[0]).forEach(pump => {\n      event = {\n        //it is ok\n        type: 'setPumpSpeed',\n        target: pump.node.id,\n        time: 0,\n        value: 0\n      };\n      eventList.push(event);\n    });\n    let position = -0.001;\n    //prepares all droplets in block and calculates some parameters\n    currentBlockDroplets.forEach(droplet => {\n      var _droplet$parameters$f6, _droplet$parameters$f7;\n      const prefixVolume = (_droplet$parameters$f6 = droplet.parameters.find(p => p.name === 'prefixVolume')) === null || _droplet$parameters$f6 === void 0 ? void 0 : _droplet$parameters$f6.value;\n      const surfixVolume = (_droplet$parameters$f7 = droplet.parameters.find(p => p.name === 'surfixVolume')) === null || _droplet$parameters$f7 === void 0 ? void 0 : _droplet$parameters$f7.value;\n      droplet.frontVolumetricSpeed = commonVolumetricSpeed;\n      droplet.rearVolumetricSpeed = commonVolumetricSpeed;\n      droplet.frontVolumetricPosition = position - prefixVolume;\n      droplet.rearVolumetricPosition = droplet.frontVolumetricPosition;\n      droplet.frontVolumetricDistanceToNextNode = Math.abs(droplet.frontVolumetricPosition);\n      droplet.rearVolumetricDistanceToNextNode = Math.abs(droplet.rearVolumetricPosition);\n      droplet.frontTimeToReachNextNode = 0;\n      droplet.rearTimeToReachNextNode = 0;\n      droplet.frontNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\n      droplet.rearNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\n      droplet.pumpSpeedMultiplier = 1;\n      droplet.pauseLevel = 0;\n      droplet.frontVolumetricSpeedAtPause = 0;\n      droplet.rearVolumetricSpeedAtPause = 0;\n      droplet.stoppingDroplet = false;\n      droplet.initialPumping = false;\n      position -= prefixVolume + surfixVolume;\n    });\n    console.log('findFurthestNode: ', findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id);\n    console.log('Droplet positions initialized, nodes ready');\n    let lastDropletRearPosition = currentBlockDroplets[currentBlockDroplets.length - 1].rearVolumetricPosition;\n    let outletNodePosition = orderedNodes[0].node.volumetricPosition;\n    let timePassed = 0; //in s\n    let newTimePassed = 0;\n\n    // Simulate the movement of droplets in the current block\n    currentBlockDroplets.forEach(droplet => {\n      droplet.frontTimeToReachNextNode = Math.abs(droplet.frontVolumetricDistanceToNextNode / droplet.frontVolumetricSpeed);\n      droplet.rearTimeToReachNextNode = Math.abs(droplet.rearVolumetricDistanceToNextNode / droplet.rearVolumetricSpeed);\n    });\n    while (lastDropletRearPosition < outletNodePosition) {\n      let smallestFrontTime = Infinity;\n      let smallestRearTime = Infinity;\n      let smallestFrontTimeDroplet = [];\n      let smallestRearTimeDroplet = [];\n      currentBlockDroplets.forEach(droplet => {\n        // Update the smallest front and rear times and associated droplet(s) based on the current droplet's front and rear times to reach the next node.\n\n        if (Math.abs(droplet.frontTimeToReachNextNode) < smallestFrontTime) {\n          smallestFrontTime = Math.abs(droplet.frontTimeToReachNextNode);\n          smallestFrontTimeDroplet = [droplet];\n        } else if (Math.abs(droplet.frontTimeToReachNextNode) === smallestFrontTime) {\n          smallestFrontTimeDroplet.push(droplet);\n        }\n        if (Math.abs(droplet.rearTimeToReachNextNode) < smallestRearTime) {\n          smallestRearTime = Math.abs(droplet.rearTimeToReachNextNode);\n          smallestRearTimeDroplet = [droplet];\n        } else if (Math.abs(droplet.rearTimeToReachNextNode) === smallestRearTime) {\n          smallestRearTimeDroplet.push(droplet);\n        }\n      });\n      newTimePassed += Math.min(Math.abs(smallestFrontTime), Math.abs(smallestRearTime));\n      if (smallestFrontTime === smallestRearTime) {\n        //przypadek w ktorym wiele kropel ma ten sam czas do przejścia do nastepnego noda, rzadki\n\n        if (smallestFrontTimeDroplet.length > 1 || smallestRearTimeDroplet.length > 1) {\n          //sprawdź czy wśród nich jest kropla z rear i front\n          console.log('Multiple droplets have reached the next node simultaneously');\n          console.log('smallestFrontTimeDroplet: ', smallestFrontTimeDroplet);\n          console.log('smallestRearTimeDroplet: ', smallestRearTimeDroplet);\n        } else if (smallestFrontTimeDroplet[0] === smallestRearTimeDroplet[0]) {\n          //przypadek gdy kropla ma 0 objętości\n          console.log('Both front and rear times are for the same droplet');\n          const reachedNode = orderedNodes.find(n => n.node.id === smallestFrontTimeDroplet[0].frontNextNodeID);\n          const reachedNodeDistance = orderedNodes.find(node => node.node.id === reachedNode.node.id).distance;\n          if (reachedNode.node.type === 'connector') {\n            const index = currentBlockDroplets.indexOf(smallestFrontTimeDroplet[0]);\n            const dropletsOlder = currentBlockDroplets.slice(0, index);\n            const dropletsNewer = currentBlockDroplets.slice(index + 1);\n            const ds = [];\n            ds.drops = JSON.parse(JSON.stringify(dropletsNewer)); // Create deep copy\n            ds.snappedNode = smallestFrontTimeDroplet[0].frontNextNodeID;\n            const existingSnapshotIndex = dropletSnapshot.findIndex(snapshot => snapshot.snappedNode === ds.snappedNode);\n            if (existingSnapshotIndex !== -1) {\n              dropletSnapshot[existingSnapshotIndex] = ds;\n            } else {\n              dropletSnapshot.push(ds);\n            }\n\n            //aktualizuje starsze krople\n            dropletsOlder.forEach(droplet => {\n              droplet.frontTimeToReachNextNode -= smallestFrontTime;\n              droplet.rearTimeToReachNextNode -= smallestFrontTime;\n              droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n              droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n              droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n              droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n            });\n\n            //aktualizuje kroplę\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n            const nextEdge = graphData.links.find(link => link.source === smallestFrontTimeDroplet[0].frontNextNodeID && link.target === nextNode.node.id);\n            if (reachedNode.connectedPump !== null) {\n              var _smallestFrontTimeDro, _smallestFrontTimeDro2;\n              const pumpRatio = ((_smallestFrontTimeDro = smallestFrontTimeDroplet[0].parameters.find(param => param.nodeId === reachedNode.connectedPump.id && param.name === 'ratio')) === null || _smallestFrontTimeDro === void 0 ? void 0 : _smallestFrontTimeDro.value) || 0;\n              const dropletDesiredVolume = ((_smallestFrontTimeDro2 = smallestFrontTimeDroplet[0].parameters.find(param => param.name === 'volume')) === null || _smallestFrontTimeDro2 === void 0 ? void 0 : _smallestFrontTimeDro2.value) || 0;\n              reachedNode.connectedPumpRatio = pumpRatio;\n              //reachedNode.inletVolumetricSpeed = 0;\n              //smallestFrontTimeDroplet[0].frontVolumetricSpeed = reachedNode.outletVolumetricSpeed;\n              smallestFrontTimeDroplet[0].frontVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              smallestFrontTimeDroplet[0].rearVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].rearVolumetricSpeed;\n              smallestFrontTimeDroplet[0].rearVolumetricSpeed = 0;\n              smallestFrontTimeDroplet[0].frontVolumetricPosition = reachedNode.node.volumetricPosition;\n              smallestFrontTimeDroplet[0].rearVolumetricPosition = reachedNode.node.volumetricPosition;\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n              smallestFrontTimeDroplet[0].rearVolumetricDistanceToNextNode = 0;\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              smallestFrontTimeDroplet[0].rearTimeToReachNextNode = dropletDesiredVolume * pumpRatio / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\n              //smallestFrontTimeDroplet[0].rearNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\n              smallestFrontTimeDroplet[0].pumpSpeedMultiplier = 1;\n              //smallestFrontTimeDroplet[0].pauseLevel = 0;\n              smallestFrontTimeDroplet[0].stoppingDroplet = true;\n              smallestFrontTimeDroplet[0].initialPumping = true;\n              if (reachedNode.connectedPump.id !== selectedCarrierPumps[0]) {\n                event = {\n                  type: 'setPumpSpeed',\n                  target: reachedNode.connectedPump.id,\n                  time: newTimePassed,\n                  value: smallestFrontTimeDroplet[0].frontVolumetricSpeed\n                };\n                eventList.push(event);\n              }\n\n              //update newer droplets\n              dropletsNewer.forEach(droplet => {\n                droplet.pauseLevel += 1;\n                if (droplet.pauseLevel === 1) {\n                  droplet.frontVolumetricSpeedAtPause = droplet.frontVolumetricSpeed;\n                  if (droplet.stoppingDroplet !== true) {\n                    droplet.rearVolumetricSpeedAtPause = droplet.rearVolumetricSpeed;\n                  }\n                }\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricSpeed = 0;\n                droplet.rearVolumetricSpeed = 0;\n                droplet.frontTimeToReachNextNode += smallestFrontTimeDroplet[0].rearTimeToReachNextNode - smallestFrontTime;\n                droplet.rearTimeToReachNextNode += smallestFrontTimeDroplet[0].rearTimeToReachNextNode - smallestFrontTime;\n              });\n              getPumpsBetweenPositions(smallestFrontTimeDroplet[0].frontVolumetricPosition, -1, graphData.nodes, graphData.links).filter(pump => pump.id !== reachedNode.connectedPump.id).forEach(pump => {\n                event = {\n                  type: 'setPumpSpeed',\n                  target: pump.id,\n                  time: newTimePassed,\n                  value: 0\n                };\n                eventList.push(event);\n              });\n            }\n          } else if (reachedNode.type === 'thermostat' || reachedNode.type === 'LED') {\n            console.log('reachedNode is thermostat');\n          } else if (reachedNode.type === 'outlet') {\n            console.log('reachedNode is outlet');\n          } else if (reachedNode.type === 'detector' || reachedNode.type === 'USBSpectrometer' || reachedNode.type === 'MQTTSpectrometer') {\n            console.log('reachedNode is detector');\n          }\n        } else {\n          console.log('Front and rear times are for different droplets');\n        }\n      } else if (smallestFrontTime < smallestRearTime) {\n        //przypadek gdzie przód jest przed tyłem\n        console.log('Front time is smaller than rear time');\n        if (smallestFrontTimeDroplet.length > 1) {\n          console.log(`Multiple droplets have reached the next node simultaneously`);\n          smallestFrontTimeDroplet.forEach(droplet => {\n            // Perform some action for each droplet in smallestFrontTimeDroplet\n          });\n        } else {\n          //przypadek gdy przód jednej kropelki dochodzi do noda\n          console.log(`Single droplet front has reached the next node`);\n          const reachedNode = orderedNodes.find(n => n.node.id === smallestFrontTimeDroplet[0].frontNextNodeID);\n          const reachedNodeDistance = orderedNodes.find(node => node.node.id === reachedNode.node.id).distance;\n          if (reachedNode.node.type === 'connector') {\n            //przypadek gdy dochodzi do connectora\n            console.log('reachedNode is connector');\n            const index = currentBlockDroplets.indexOf(smallestFrontTimeDroplet[0]);\n            const dropletsOlder = currentBlockDroplets.slice(0, index);\n            const dropletsNewer = currentBlockDroplets.slice(index + 1);\n\n            //aktualizuje kroplę\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n            const nextEdge = graphData.links.find(link => link.source === reachedNode.node.id && link.target === nextNode.node.id);\n            if (reachedNode.connectedPump.id !== null) {\n              var _smallestFrontTimeDro3, _smallestFrontTimeDro4;\n              const pumpRatio = ((_smallestFrontTimeDro3 = smallestFrontTimeDroplet[0].parameters.find(param => param.nodeId === reachedNode.connectedPump.id && param.name === 'ratio')) === null || _smallestFrontTimeDro3 === void 0 ? void 0 : _smallestFrontTimeDro3.value) || 0;\n              const dropletDesiredVolume = ((_smallestFrontTimeDro4 = smallestFrontTimeDroplet[0].parameters.find(param => param.name === 'volume')) === null || _smallestFrontTimeDro4 === void 0 ? void 0 : _smallestFrontTimeDro4.value) || 0;\n              smallestFrontTimeDroplet[0].frontVolumetricPosition = reachedNode.node.volumetricPosition;\n              smallestFrontTimeDroplet[0].rearVolumetricPosition += smallestFrontTime * smallestFrontTimeDroplet[0].rearVolumetricSpeed;\n              smallestFrontTimeDroplet[0].actualVolume = smallestFrontTimeDroplet[0].frontVolumetricPosition - smallestFrontTimeDroplet[0].rearVolumetricPosition;\n              reachedNode.inletVolumetricSpeed = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              reachedNode.connectedPumpRatio = pumpRatio;\n              smallestFrontTimeDroplet[0].rearTimeToReachNextNode -= smallestFrontTime;\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n              smallestFrontTimeDroplet[0].rearVolumetricDistanceToNextNode -= smallestFrontTime * smallestFrontTimeDroplet[0].rearVolumetricSpeed;\n              if (smallestFrontTimeDroplet[0].initialPumping === true) {\n                //przypadek gdy kropla jest w pierwszej fazie pompowania (od 0uL)\n                console.log('Kropla jest w pierwszej fazie pompowania');\n                //smallestFrontTimeDroplet[0].initialPumping = false;\n                const rearTimeLeft = smallestFrontTimeDroplet[0].rearTimeToReachNextNode;\n                const totalTimeLeft = rearTimeLeft + smallestFrontTimeDroplet[0].actualVolume / commonVolumetricSpeed;\n                console.log('commonVolumetricSpeed: ', commonVolumetricSpeed);\n                console.log('smallestFrontTimeDroplet[0].actualVolume: ', smallestFrontTimeDroplet[0].actualVolume);\n                console.log('rearTimeLeft: ', rearTimeLeft);\n                console.log('totalTimeLeft: ', totalTimeLeft);\n                const thispumpspeed = pumpRatio * dropletDesiredVolume / totalTimeLeft;\n                console.log('thispumpspeed: ', thispumpspeed);\n                reachedNode.connectedPumpSpeedAtPause = thispumpspeed;\n              } else {\n                console.log('Normalne pompowanie');\n                reachedNode.connectedPumpSpeedAtPause = dropletDesiredVolume * pumpRatio / (smallestFrontTimeDroplet[0].actualVolume / reachedNode.inletVolumetricSpeed);\n              }\n              reachedNode.outletVolumetricSpeed = reachedNode.inletVolumetricSpeed + reachedNode.connectedPumpSpeedAtPause;\n              smallestFrontTimeDroplet[0].frontVolumetricSpeed += reachedNode.connectedPumpSpeedAtPause;\n              //smallestFrontTimeDroplet[0].rearVolumetricSpeed = 0;\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\n              //smallestFrontTimeDroplet[0].rearNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\n              //smallestFrontTimeDroplet[0].pumpSpeedMultiplier = 1;\n              //smallestFrontTimeDroplet[0].pauseLevel = 0;\n              //smallestFrontTimeDroplet[0].frontVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              //smallestFrontTimeDroplet[0].rearVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              //smallestFrontTimeDroplet[0].stoppingDroplet = true;\n              event = {\n                type: 'setPumpSpeed',\n                target: reachedNode.connectedPump.id,\n                time: newTimePassed,\n                value: reachedNode.connectedPumpSpeedAtPause\n              };\n              eventList.push(event);\n              //update newer droplets\n              dropletsNewer.forEach(droplet => {\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontTimeToReachNextNode -= smallestFrontTime;\n                droplet.rearTimeToReachNextNode -= smallestFrontTime;\n              });\n              //aktualizuje starsze krople\n              let accumulatedSpeed = reachedNode.connectedPumpSpeedAtPause;\n              dropletsOlder.reverse().forEach(droplet => {\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.rearVolumetricSpeed += accumulatedSpeed;\n                getPumpsBetweenPositions(droplet.frontVolumetricPosition, droplet.rearVolumetricPosition, graphData.nodes, graphData.links).forEach(pump => {\n                  const editedNode = orderedNodes.find(node => node.connectedPump.id === pump.id);\n                  //editedNode.pumpSpeedMultiplier = 1;\n                  const pumpBoost = editedNode.connectedPumpSpeedAtPause * accumulatedSpeed / editedNode.inletVolumetricSpeed;\n                  editedNode.connectedPumpSpeedAtPause += pumpBoost;\n                  editedNode.inletVolumetricSpeed += accumulatedSpeed;\n                  accumulatedSpeed += pumpBoost;\n                  editedNode.outletVolumetricSpeed += accumulatedSpeed;\n                  event = {\n                    type: 'setPumpSpeed',\n                    target: pump.id,\n                    time: newTimePassed,\n                    value: editedNode.connectedPumpSpeedAtPause\n                  };\n                  eventList.push(event);\n                });\n                droplet.frontVolumetricSpeed += accumulatedSpeed;\n                droplet.frontTimeToReachNextNode = droplet.frontVolumetricDistanceToNextNode / droplet.frontVolumetricSpeed;\n                droplet.rearTimeToReachNextNode = droplet.rearVolumetricDistanceToNextNode / droplet.rearVolumetricSpeed;\n              });\n            }\n          } else if (reachedNode.node.type === 'thermostat' || reachedNode.type === 'LED') {\n            //przypadek gdy dochodzi do termostatu\n            console.log('reachedNode (thermostat, LED): ', reachedNode);\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n            if (nextNode) {\n              const nextEdge = graphData.links.find(link => link.source === smallestFrontTimeDroplet[0].frontNextNodeID && link.target === nextNode.node.id);\n              //aktualizuje krople\n              currentBlockDroplets.forEach(droplet => {\n                droplet.frontTimeToReachNextNode -= smallestFrontTime;\n                droplet.rearTimeToReachNextNode -= smallestFrontTime;\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n              });\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\n            }\n          } else if (reachedNode.node.type === 'outlet') {\n            //jeśli ostatni node osiągnięty\n            console.log('reachedNode (outlet): ', reachedNode);\n            //typowe zaktualizowanie czasu do następnego noda dla reszty kropel i zestallowanie frontu\n            currentBlockDroplets.forEach(droplet => {\n              droplet.frontTimeToReachNextNode -= smallestFrontTime;\n              droplet.rearTimeToReachNextNode -= smallestFrontTime;\n              droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n              droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n              droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n              droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n            });\n            smallestFrontTimeDroplet[0].frontTimeToReachNextNode = Infinity;\n            smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = Infinity;\n            smallestFrontTimeDroplet[0].frontNextNodeID = null;\n          } else if (reachedNode.node.type === 'detector' || reachedNode.node.type === 'USBSpectrometer' || reachedNode.node.type === 'MQTTSpectrometer') {\n            var _smallestRearTimeDrop;\n            //przypadek gdy dochodzi do detektora\n            console.log('reachedNode (detector): ', reachedNode);\n\n            // Create detector measurement end event when droplet rear reaches detector\n            const detectorEndEvent = {\n              type: 'setDetectorMeasurement',\n              target: reachedNode.node.id,\n              time: newTimePassed,\n              dropletId: smallestRearTimeDroplet[0].id,\n              eventSubtype: 'dropletRearPassed',\n              dropletData: {\n                volume: ((_smallestRearTimeDrop = smallestRearTimeDroplet[0].parameters.find(p => p.name === 'volume')) === null || _smallestRearTimeDrop === void 0 ? void 0 : _smallestRearTimeDrop.value) || 0,\n                frontVolumetricPosition: smallestRearTimeDroplet[0].frontVolumetricPosition,\n                rearVolumetricPosition: smallestRearTimeDroplet[0].rearVolumetricPosition,\n                rearVolumetricSpeed: smallestRearTimeDroplet[0].rearVolumetricSpeed,\n                parameters: smallestRearTimeDroplet[0].parameters\n              }\n            };\n            eventList.push(detectorEndEvent);\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n            if (nextNode) {\n              const nextEdge = graphData.links.find(link => link.source === smallestFrontTimeDroplet[0].frontNextNodeID && link.target === nextNode.node.id);\n              //aktualizuje krople\n              currentBlockDroplets.forEach(droplet => {\n                droplet.frontTimeToReachNextNode -= smallestFrontTime;\n                droplet.rearTimeToReachNextNode -= smallestFrontTime;\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n              });\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\n            }\n          }\n        }\n      } else {\n        //przypadek gdzie tył jest przed przodem\n        console.log('Rear time is smaller than front time');\n        if (smallestRearTimeDroplet.length > 1) {\n          //przypadek gdy dochodzi do noda wiele kropel\n          console.log(`Multiple droplets ends have reached the next node simultaneously`);\n          smallestRearTimeDroplet.forEach(droplet => {\n            // Perform some action for each droplet in smallestRearTimeDroplet\n          });\n        } else {\n          //przypadek gdy tył jednej kropelki dochodzi do noda\n          const reachedNode = orderedNodes.find(n => n.node.id === smallestRearTimeDroplet[0].rearNextNodeID);\n          const reachedNodeDistance = orderedNodes.find(node => node.node.id === reachedNode.node.id).distance;\n          if (reachedNode.node.type === 'connector') {\n            //przypadek gdy dochodzi do connectora\n            console.log('reachedNode is connector');\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n            const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\n            const index = currentBlockDroplets.indexOf(smallestRearTimeDroplet[0]);\n            const dropletsOlder = currentBlockDroplets.slice(0, index);\n            const dropletsNewer = currentBlockDroplets.slice(index + 1);\n            if (smallestRearTimeDroplet[0].stoppingDroplet === true) {\n              //wznawia jeśli była zatrzymana\n              //aktualizuje starsze krople\n              dropletsOlder.forEach(droplet => {\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\n                droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n              });\n\n              //aktualizuje nowsze krople\n              dropletsNewer.forEach(droplet => {\n                if (droplet.pauseLevel === 1) {\n                  //\n                  droplet.pauseLevel = 0;\n                  droplet.frontVolumetricSpeed = droplet.frontVolumetricSpeedAtPause;\n                  droplet.rearVolumetricSpeed = droplet.rearVolumetricSpeedAtPause;\n                  getPumpsBetweenPositions(droplet.frontVolumetricPosition, droplet.rearVolumetricPosition, graphData.nodes, graphData.links).forEach(pump => {\n                    event = {\n                      type: 'setPumpSpeed',\n                      target: pump.id,\n                      time: newTimePassed,\n                      value: orderedNodes.find(node => node.node.id === pump.id).connectedPumpSpeedAtPause\n                    };\n                    eventList.push(event);\n                  });\n                } else {\n                  droplet.pauseLevel -= 1;\n                }\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\n              });\n              reachedNode.connectedPumpRatio = 0;\n              //reachedNode.inletVolumetricSpeed = 0;\n              //smallestRearTimeDroplet[0].frontVolumetricSpeed = reachedNode.outletVolumetricSpeed;\n              smallestRearTimeDroplet[0].rearVolumetricSpeed = smallestRearTimeDroplet[0].rearVolumetricSpeedAtPause;\n              smallestRearTimeDroplet[0].frontVolumetricPosition += smallestRearTimeDroplet[0].frontVolumetricSpeed * smallestRearTime;\n              smallestRearTimeDroplet[0].rearVolumetricPosition = reachedNode.node.volumetricPosition;\n              smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode -= smallestRearTimeDroplet[0].frontVolumetricSpeed * smallestRearTime;\n              smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n              smallestRearTimeDroplet[0].frontTimeToReachNextNode = smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].frontVolumetricSpeed;\n              smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\n              //smallestRearTimeDroplet[0].frontNextNodeID = nextNode.id;\n              smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\n              //smallestRearTimeDroplet[0].pumpSpeedMultiplier = 1;\n              //smallestRearTimeDroplet[0].pauseLevel = 0;\n              smallestRearTimeDroplet[0].frontVolumetricSpeedAtPause = smallestRearTimeDroplet[0].frontVolumetricSpeed;\n              smallestRearTimeDroplet[0].rearVolumetricSpeedAtPause = smallestRearTimeDroplet[0].rearVolumetricSpeed;\n              smallestRearTimeDroplet[0].stoppingDroplet = false;\n              smallestRearTimeDroplet[0].initialPumping = false;\n              reachedNode.connectedPumpRatio = 0;\n              event = {\n                type: 'setPumpSpeed',\n                target: reachedNode.connectedPump.id,\n                time: newTimePassed,\n                value: 0\n              };\n              eventList.push(event);\n              event = {\n                type: 'setPumpSpeed',\n                target: selectedCarrierPumps[0],\n                time: newTimePassed,\n                value: commonVolumetricSpeed\n              };\n              eventList.push(event);\n            } else {\n              console.log('it is not stopper');\n              if (reachedNode.connectedPump.id !== null) {\n                const speedDifference = reachedNode.outletVolumetricSpeed - reachedNode.inletVolumetricSpeed;\n                //reachedNode.inletVolumetricSpeed = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n                reachedNode.outletVolumetricSpeed = reachedNode.inletVolumetricSpeed;\n                reachedNode.connectedPumpRatio = 0;\n                reachedNode.connectedPumpSpeedAtPause = 0;\n                smallestRearTimeDroplet[0].frontVolumetricPosition += smallestRearTime * smallestRearTimeDroplet[0].frontVolumetricSpeed;\n                smallestRearTimeDroplet[0].rearVolumetricPosition = reachedNode.node.volumetricPosition;\n                smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode -= smallestRearTime * smallestRearTimeDroplet[0].frontVolumetricSpeed;\n                smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n                //smallestRearTimeDroplet[0].frontNextNodeID = nextNode.id;\n                smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\n                //smallestRearTimeDroplet[0].pumpSpeedMultiplier = 1;\n                //smallestRearTimeDroplet[0].pauseLevel = 0; \n                //smallestRearTimeDroplet[0].stoppingDroplet = true;\n                smallestRearTimeDroplet[0].frontVolumetricSpeed = smallestRearTimeDroplet[0].frontVolumetricSpeed - speedDifference;\n                //smallestRearTimeDroplet[0].rearVolumetricSpeed = 0;\n                smallestRearTimeDroplet[0].frontVolumetricSpeedAtPause = smallestRearTimeDroplet[0].frontVolumetricSpeed;\n                //smallestRearTimeDroplet[0].rearVolumetricSpeedAtPause = smallestRearTimeDroplet[0].rearVolumetricSpeed;\n                smallestRearTimeDroplet[0].frontTimeToReachNextNode = smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].frontVolumetricSpeed;\n                smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\n                event = {\n                  type: 'setPumpSpeed',\n                  target: reachedNode.connectedPump.id,\n                  time: newTimePassed,\n                  value: reachedNode.connectedPumpSpeedAtPause\n                };\n                eventList.push(event);\n                //updte newer droplets\n                dropletsNewer.forEach(droplet => {\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                  droplet.frontTimeToReachNextNode -= smallestRearTime;\n                  droplet.rearTimeToReachNextNode -= smallestRearTime;\n                });\n                //aktualizuje starsze krople\n                let accumulatedSpeedDecrease = speedDifference;\n                dropletsOlder.reverse().forEach(droplet => {\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                  droplet.rearVolumetricSpeed -= accumulatedSpeedDecrease;\n                  getPumpsBetweenPositions(droplet.frontVolumetricPosition, droplet.rearVolumetricPosition, graphData.nodes, graphData.links).forEach(pump => {\n                    const editedNode = orderedNodes.find(node => node.connectedPump.id === pump.id);\n                    const pumpBreak = editedNode.connectedPumpSpeedAtPause * accumulatedSpeedDecrease / editedNode.inletVolumetricSpeed;\n                    editedNode.connectedPumpSpeedAtPause -= pumpBreak;\n                    editedNode.inletVolumetricSpeed -= accumulatedSpeedDecrease;\n                    accumulatedSpeedDecrease += pumpBreak;\n                    editedNode.outletVolumetricSpeed -= accumulatedSpeedDecrease;\n                    event = {\n                      type: 'setPumpSpeed',\n                      target: pump.id,\n                      time: newTimePassed,\n                      value: editedNode.connectedPumpSpeedAtPause\n                    };\n                    eventList.push(event);\n                  });\n                  droplet.frontVolumetricSpeed -= accumulatedSpeedDecrease;\n                  droplet.frontTimeToReachNextNode = droplet.frontVolumetricDistanceToNextNode / droplet.frontVolumetricSpeed;\n                  droplet.rearTimeToReachNextNode = droplet.rearVolumetricDistanceToNextNode / droplet.rearVolumetricSpeed;\n                });\n              }\n            }\n          } else if (reachedNode.node.type === 'thermostat' || reachedNode.node.type === 'LED') {\n            //przypadek gdy dochodzi do termostatu\n            console.log('reachedNode thermostat: ', reachedNode);\n            const isFarthestThermostatOrLED = orderedNodes.filter(node => node.node.type === 'thermostat' || node.node.type === 'LED').every(node => node.distance <= reachedNodeDistance);\n\n            // This line checks if the smallestRearTimeDroplet is the last droplet in the currentBlockDroplets array.\n            if (isFarthestThermostatOrLED && currentBlockDroplets.length === currentBlockDroplets.indexOf(smallestRearTimeDroplet[0]) + 1) {\n              var _smallestRearTimeDrop2;\n              console.log('This is the farthest thermostat or LED node. Also, last droplet just passed through it.');\n              const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n              const waitTime = ((_smallestRearTimeDrop2 = smallestRearTimeDroplet[0].parameters.find(param => param.nodeId === reachedNode.node.id && param.name === 'time')) === null || _smallestRearTimeDrop2 === void 0 ? void 0 : _smallestRearTimeDrop2.value) || 0;\n              if (nextNode) {\n                const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\n                smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n                smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed + smallestRearTime;\n                smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\n                //aktualizuje resztę kropli\n                currentBlockDroplets.forEach(droplet => {\n                  droplet.frontTimeToReachNextNode += waitTime - smallestRearTime;\n                  droplet.rearTimeToReachNextNode += waitTime - smallestRearTime;\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed - waitTime * droplet.frontVolumetricSpeed; //to jest zrobione na razie aby czas się zgadzał\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed - waitTime * droplet.rearVolumetricSpeed;\n                });\n                let carrierPumpEvent = {\n                  type: 'setPumpSpeed',\n                  target: selectedCarrierPumps[0],\n                  // Assuming 'carrierPumpId' is the ID of the carrier pump\n                  time: newTimePassed,\n                  value: 0\n                };\n                eventList.push(carrierPumpEvent);\n                carrierPumpEvent = {\n                  type: 'setPumpSpeed',\n                  target: selectedCarrierPumps[0],\n                  // Assuming 'carrierPumpId' is the ID of the carrier pump\n                  time: newTimePassed + waitTime,\n                  value: commonVolumetricSpeed\n                };\n                eventList.push(carrierPumpEvent);\n              }\n            } else {\n              //droplet wasnt the last one\n              console.log('smallestRearTimeDroplet is not the last droplet in the currentBlockDroplets array');\n              const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n              if (nextNode) {\n                const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\n                //aktualizuje krople\n                currentBlockDroplets.forEach(droplet => {\n                  droplet.frontTimeToReachNextNode -= smallestRearTime;\n                  droplet.rearTimeToReachNextNode -= smallestRearTime;\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n                });\n                smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n                smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\n                smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\n              }\n            }\n          } else if (reachedNode.node.type === 'outlet') {\n            //jeśli ostatni node osiągnięty\n            //typowe zaktualizowanie czasu do następnego noda dla reszty kropel i zestallowanie reara\n            //aktualizuje resztę kropli\n            currentBlockDroplets.forEach(droplet => {\n              droplet.frontTimeToReachNextNode -= smallestRearTime;\n              droplet.rearTimeToReachNextNode -= smallestRearTime;\n              droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n              droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n              droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n              droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n            });\n            smallestRearTimeDroplet[0].frontTimeToReachNextNode = Infinity;\n            smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode = Infinity;\n            smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = Infinity;\n            smallestRearTimeDroplet[0].rearNextNodeID = null;\n            smallestRearTimeDroplet[0].rearTimeToReachNextNode = Infinity;\n          } else if (reachedNode.node.type === 'detector' || reachedNode.node.type === 'USBSpectrometer' || reachedNode.node.type === 'MQTTSpectrometer') {\n            var _smallestRearTimeDrop3;\n            //przypadek gdy dochodzi do detektora\n            console.log('reachedNode (detector): ', reachedNode);\n\n            // Create detector measurement end event when droplet rear reaches detector\n            const detectorEndEvent = {\n              type: 'setDetectorMeasurement',\n              target: reachedNode.node.id,\n              time: newTimePassed,\n              dropletId: smallestRearTimeDroplet[0].id,\n              eventSubtype: 'dropletRearPassed',\n              dropletData: {\n                volume: ((_smallestRearTimeDrop3 = smallestRearTimeDroplet[0].parameters.find(p => p.name === 'volume')) === null || _smallestRearTimeDrop3 === void 0 ? void 0 : _smallestRearTimeDrop3.value) || 0,\n                frontVolumetricPosition: smallestRearTimeDroplet[0].frontVolumetricPosition,\n                rearVolumetricPosition: smallestRearTimeDroplet[0].rearVolumetricPosition,\n                rearVolumetricSpeed: smallestRearTimeDroplet[0].rearVolumetricSpeed,\n                parameters: smallestRearTimeDroplet[0].parameters\n              }\n            };\n            eventList.push(detectorEndEvent);\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n            if (nextNode) {\n              const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\n              //aktualizuje krople\n              currentBlockDroplets.forEach(droplet => {\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\n                droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n              });\n              smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n              smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\n              smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\n            }\n          }\n        }\n      }\n      timePassed = newTimePassed;\n      // Update last droplet rear position\n      lastDropletRearPosition = currentBlockDroplets[currentBlockDroplets.length - 1].rearVolumetricPosition;\n\n      //add code that preserves droplets positions and speeds for visualization\n      const dropletState = {\n        time: timePassed,\n        droplets: currentBlockDroplets.map(droplet => {\n          var _droplet$parameters$f8;\n          return {\n            id: droplet.id,\n            frontVolumetricPosition: droplet.frontVolumetricPosition,\n            rearVolumetricPosition: droplet.rearVolumetricPosition,\n            frontVolumetricSpeed: droplet.frontVolumetricSpeed,\n            rearVolumetricSpeed: droplet.rearVolumetricSpeed,\n            pumpSpeedMultiplier: droplet.pumpSpeedMultiplier,\n            frontTimeToReachNextNode: droplet.frontTimeToReachNextNode,\n            rearTimeToReachNextNode: droplet.rearTimeToReachNextNode,\n            frontVolumetricDistanceToNextNode: droplet.frontVolumetricDistanceToNextNode,\n            rearVolumetricDistanceToNextNode: droplet.rearVolumetricDistanceToNextNode,\n            volume: ((_droplet$parameters$f8 = droplet.parameters.find(p => p.name === 'volume')) === null || _droplet$parameters$f8 === void 0 ? void 0 : _droplet$parameters$f8.value) || 0,\n            frontNextNodeID: droplet.frontNextNodeID,\n            rearNextNodeID: droplet.rearNextNodeID\n          };\n        })\n      };\n      setDropletHistory(prev => [...prev, dropletState]);\n\n      //if (timePassed > 9999) {//here for testing, preventing infinite loop\n      //  lastDropletRearPosition = 88100;\n      //}\n    }\n    event = {\n      //it is ok\n      type: 'setPumpSpeed',\n      target: selectedCarrierPumps[0],\n      time: timePassed,\n      value: 0\n    };\n    eventList.push(event);\n    eventList = cleanAndSortEventList(eventList);\n    console.log('dropletHistory in event generator: ', dropletHistory);\n    console.log('eventList: ', eventList.sort((a, b) => a.time - b.time));\n    setPumpEvents(extractPumpEvents(eventList));\n    setDetectorEvents(extractDetectorEvents(eventList));\n    console.log('Detector events:', extractDetectorEvents(eventList));\n    return eventList;\n  };\n  // First useEffect to set initial graphData\n  useEffect(() => {\n    setDropletHistory([]);\n    if (nodes.length > 0 && edges.length > 0) {\n      const graphNodes = nodes.map(node => ({\n        id: node.id,\n        label: node.data.label,\n        type: node.data.type,\n        x: 0,\n        y: 0,\n        volumetricPosition: 0\n      }));\n      const graphLinks = edges.map(edge => {\n        var _edge$data, _edge$data$properties, _edge$data2, _edge$data2$propertie;\n        return {\n          source: edge.source,\n          target: edge.target,\n          length: ((_edge$data = edge.data) === null || _edge$data === void 0 ? void 0 : (_edge$data$properties = _edge$data.properties) === null || _edge$data$properties === void 0 ? void 0 : _edge$data$properties.length) || 100,\n          diameter: ((_edge$data2 = edge.data) === null || _edge$data2 === void 0 ? void 0 : (_edge$data2$propertie = _edge$data2.properties) === null || _edge$data2$propertie === void 0 ? void 0 : _edge$data2$propertie.diameter) || 1\n        };\n      });\n      setGraphData({\n        nodes: graphNodes,\n        links: graphLinks\n      });\n    }\n  }, [nodes, edges]);\n\n  // Second useEffect to calculate nodes positions and set up simulation data\n  useEffect(() => {\n    if (!graphData.nodes.length || !graphData.links.length || !droplets.length) {\n      console.log('Missing required data for simulation setup:', {\n        nodesLength: graphData.nodes.length,\n        linksLength: graphData.links.length,\n        dropletsLength: droplets.length\n      });\n      return;\n    }\n    const graphNodes = [...graphData.nodes];\n\n    // Find outlet node first\n    const outletNode = findOutletNode(graphData.nodes);\n    if (!outletNode) {\n      console.error('No outlet node found. Cannot set up simulation.');\n      return;\n    }\n\n    // Get ordered nodes from outlet\n    const orderedNodes = orderNodesByDistance(outletNode, graphData.nodes, graphData.links);\n\n    // Separate nodes into main line and secondary line\n    const mainLineNodes = orderedNodes.filter(({\n      node\n    }) => setOfMainLineNodes.includes(node.type)).reverse();\n    const secondaryLineNodes = orderedNodes.filter(({\n      node\n    }) => setOfSecondaryLineNodes.includes(node.type)).sort((a, b) => b.distance - a.distance);\n\n    // Position settings\n    const mainLineY = 300;\n    const secondaryLineY = 150;\n    const pumpSpacing = 100; // Increased horizontal spacing between pumps\n    let currentX = 100;\n\n    // Position main line nodes\n    let currentVolumetricPosition = 0;\n    mainLineNodes.forEach(({\n      node\n    }, index) => {\n      const graphNode = graphNodes.find(n => n.id === node.id);\n      if (!graphNode) return;\n      graphNode.x = currentX;\n      graphNode.y = mainLineY;\n      graphNode.volumetricPosition = currentVolumetricPosition;\n      if (index < mainLineNodes.length - 1) {\n        const nextNode = mainLineNodes[index + 1];\n        const edge = graphData.links.find(e => e.source === graphNode.id && e.target === nextNode.node.id || e.target === graphNode.id && e.source === nextNode.node.id);\n        if (edge && edge.length) {\n          currentX += edge.length * 2;\n          // Use existing calculateEdgeVolume function\n          const edgeVolume = calculateEdgeVolume(edge);\n          currentVolumetricPosition += edgeVolume;\n        } else {\n          currentX += 200;\n          currentVolumetricPosition += 150;\n        }\n      }\n    });\n\n    // Group secondary nodes by distance\n    const nodesByDistance = {};\n    secondaryLineNodes.forEach(({\n      node,\n      distance\n    }) => {\n      if (!nodesByDistance[distance]) {\n        nodesByDistance[distance] = [];\n      }\n      nodesByDistance[distance].push(node);\n    });\n\n    // Position secondary nodes based on their connected main line nodes\n    const pumpOffset = 50; // Add this constant for pump spacing\n    Object.entries(nodesByDistance).forEach(([distance, nodes]) => {\n      nodes.forEach((node, index) => {\n        const graphNode = graphNodes.find(n => n.id === node.id);\n        if (!graphNode) return;\n\n        // Find connected main line node through edges\n        const connectedEdge = edges.find(e => e.source === node.id || e.target === node.id);\n        if (connectedEdge) {\n          const connectedNodeId = connectedEdge.source === node.id ? connectedEdge.target : connectedEdge.source;\n          const connectedMainNode = graphNodes.find(n => n.id === connectedNodeId);\n          if (connectedMainNode) {\n            // Position pump above its connected main line node with offset if needed\n            graphNode.x = connectedMainNode.x + index * pumpOffset - (nodes.length - 1) * pumpOffset / 2;\n            graphNode.y = secondaryLineY;\n          }\n        }\n      });\n    });\n    setGraphData(prev => ({\n      ...prev,\n      nodes: graphNodes\n    }));\n\n    // Only calculate volumes and blocks if not already done\n    if (currentBlockDroplets.length === 0) {\n      console.log('Calculating thermostat volumes and blocks for droplets:', droplets.length);\n      const thermoVol = calculateVolumesBetweenThermostats(graphData);\n\n      // Create deep copy of droplets to avoid mutation issues\n      const dropletsCopy = JSON.parse(JSON.stringify(droplets));\n      const blocks = divideDropletsIntoBlocks(dropletsCopy, thermoVol);\n      if (blocks.length > 0) {\n        setCurrentBlockDroplets(blocks[0].droplets);\n        // Generate event list only once when initializing\n        const eventList = generateEventList(blocks);\n        const eventListForDevices = recalculateEventListForDevices(eventList);\n      }\n    }\n\n    // Important: the dependency array includes currentBlockDroplets.length to prevent infinite recalculations\n  }, [graphData.nodes.length, graphData.links.length, droplets, edges, currentBlockDroplets.length]);\n  const startSimulation = useCallback(() => {\n    setIsSimulationRunning(true);\n    lastFrameTimeRef.current = null; // Reset the last frame time\n  }, []);\n  const stopSimulation = useCallback(() => {\n    setIsSimulationRunning(false);\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n      animationFrameRef.current = null;\n    }\n  }, []);\n  const restartSimulation = useCallback(() => {\n    stopSimulation();\n    setKey(prevKey => prevKey + 1);\n    setCurrentTime(0);\n    startSimulation();\n  }, [stopSimulation, startSimulation]);\n  const getNodeColor = node => {\n    switch (node.type) {\n      case 'pump':\n        return '#4CAF50';\n      case 'connector':\n        return '#2196F3';\n      case 'outlet':\n        return '#F44336';\n      default:\n        return '#FFA000';\n      // Default color for unknown types\n    }\n  };\n\n  // Update volumetricToXPosition function\n  const volumetricToXPosition = useCallback(volumetricPosition => {\n    var _graphData$nodes$find, _graphData$nodes$find2;\n    const outletNode = findOutletNode(graphData.nodes);\n    const furthestNode = findFurthestNode(outletNode, graphData.nodes, graphData.links);\n    if (!outletNode || !furthestNode) return 0;\n    const totalVolume = getVolumeBetweenNodes(furthestNode.id, outletNode.id, graphData.nodes, graphData.links);\n    const outletX = ((_graphData$nodes$find = graphData.nodes.find(n => n.id === outletNode.id)) === null || _graphData$nodes$find === void 0 ? void 0 : _graphData$nodes$find.x) || 0;\n    const furthestX = ((_graphData$nodes$find2 = graphData.nodes.find(n => n.id === furthestNode.id)) === null || _graphData$nodes$find2 === void 0 ? void 0 : _graphData$nodes$find2.x) || 0;\n\n    // Handle edge cases\n    if (!totalVolume || totalVolume === 0 || isNaN(totalVolume)) {\n      console.warn('Total volume is invalid:', totalVolume);\n      return furthestX;\n    }\n    if (volumetricPosition === undefined || volumetricPosition === null || isNaN(volumetricPosition)) {\n      console.warn('Volumetric position is invalid:', volumetricPosition);\n      return furthestX;\n    }\n\n    // Clamp the position to valid range\n    const clampedPosition = Math.max(-totalVolume, Math.min(totalVolume, volumetricPosition));\n\n    // Apply scaling factor to the position calculation\n    const scaledX = furthestX + clampedPosition / totalVolume * (outletX - furthestX);\n\n    // Ensure the returned value is a valid number\n    if (!isFinite(scaledX) || isNaN(scaledX)) {\n      console.warn('Invalid scaled position calculated:', {\n        scaledX,\n        clampedPosition,\n        totalVolume,\n        outletX,\n        furthestX\n      });\n      return furthestX;\n    }\n    return scaledX;\n  }, [graphData.nodes]);\n\n  // Update the updateDropletPositions function\n  const updateDropletPositions = useCallback(timestamp => {\n    if (!isSimulationRunning || dropletHistory.length === 0) return;\n    if (!lastFrameTimeRef.current) {\n      lastFrameTimeRef.current = timestamp;\n      animationFrameRef.current = requestAnimationFrame(updateDropletPositions);\n      return;\n    }\n    const deltaTime = (timestamp - lastFrameTimeRef.current) / 1000; // Convert to seconds\n    const simulationDeltaTime = deltaTime * timeScale;\n    setCurrentTime(prevTime => {\n      const newTime = prevTime + simulationDeltaTime;\n\n      // Get the time range of our history\n      const lastHistoryTime = dropletHistory[dropletHistory.length - 1].time;\n\n      // If we've reached the end, loop back to start\n      if (newTime >= lastHistoryTime) {\n        setCurrentTime(0);\n        return 0;\n      }\n\n      // Find the appropriate states to interpolate between\n      const currentState = interpolateDropletState(newTime);\n      // Update droplet visualization\n      const updatedDroplets = currentState.map(droplet => {\n        const frontX = volumetricToXPosition(droplet.frontVolumetricPosition);\n        const rearX = volumetricToXPosition(droplet.rearVolumetricPosition);\n        if (isNaN(frontX) || isNaN(rearX)) {\n          console.warn('Invalid droplet position calculated:', {\n            dropletId: droplet.id,\n            frontPosition: droplet.frontVolumetricPosition,\n            rearPosition: droplet.rearVolumetricPosition,\n            frontX,\n            rearX\n          });\n          return null;\n        }\n        return {\n          id: droplet.id,\n          frontX,\n          rearX,\n          y: 300,\n          volume: droplet.frontVolumetricPosition - droplet.rearVolumetricPosition,\n          speed: droplet.frontVolumetricSpeed\n        };\n      }).filter(Boolean);\n      setSimulationDroplets(updatedDroplets);\n      return newTime;\n    });\n    lastFrameTimeRef.current = timestamp;\n    animationFrameRef.current = requestAnimationFrame(updateDropletPositions);\n  }, [isSimulationRunning, timeScale, volumetricToXPosition, dropletHistory]);\n\n  // Add animation effect\n  useEffect(() => {\n    if (isSimulationRunning) {\n      lastFrameTimeRef.current = null;\n      animationFrameRef.current = requestAnimationFrame(updateDropletPositions);\n    }\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [isSimulationRunning, updateDropletPositions]);\n\n  // Add this helper function for interpolation\n  const interpolateDropletState = time => {\n    if (!dropletHistory.length) return [];\n\n    // Find the two closest states\n    const index = dropletHistory.findIndex(state => state.time > time);\n    if (index === -1) return dropletHistory[dropletHistory.length - 1].droplets;\n    if (index === 0) return dropletHistory[0].droplets;\n    const beforeState = dropletHistory[index - 1];\n    const afterState = dropletHistory[index];\n    const fraction = (time - beforeState.time) / (afterState.time - beforeState.time);\n    return beforeState.droplets.map(beforeDroplet => {\n      const afterDroplet = afterState.droplets.find(d => d.id === beforeDroplet.id);\n      if (!afterDroplet) return beforeDroplet;\n      return {\n        ...beforeDroplet,\n        frontVolumetricPosition: beforeDroplet.frontVolumetricPosition + (afterDroplet.frontVolumetricPosition - beforeDroplet.frontVolumetricPosition) * fraction,\n        rearVolumetricPosition: beforeDroplet.rearVolumetricPosition + (afterDroplet.rearVolumetricPosition - beforeDroplet.rearVolumetricPosition) * fraction\n      };\n    });\n  };\n\n  // Add navigation functions\n  const jumpToTimepoint = useCallback(index => {\n    if (index >= 0 && index < dropletHistory.length) {\n      setCurrentTimepoint(index);\n      setCurrentTime(dropletHistory[index].time);\n    }\n  }, [dropletHistory]);\n  const nextTimepoint = useCallback(() => {\n    jumpToTimepoint(currentTimepoint + 1);\n  }, [currentTimepoint, jumpToTimepoint]);\n  const previousTimepoint = useCallback(() => {\n    jumpToTimepoint(currentTimepoint - 1);\n  }, [currentTimepoint, jumpToTimepoint]);\n  const handleNodeClick = node => {\n    var _node$data2, _node$data3;\n    console.log('Node clicked:', node);\n    console.log('Node type:', node.type);\n    console.log('Node data type:', (_node$data2 = node.data) === null || _node$data2 === void 0 ? void 0 : _node$data2.type);\n\n    // Check both node.type and node.data.type\n    const nodeType = node.type || ((_node$data3 = node.data) === null || _node$data3 === void 0 ? void 0 : _node$data3.type);\n    console.log('Determined node type:', nodeType);\n    if (nodeType === 'pump' || nodeType === 'USBSpectrometer' || nodeType === 'MQTTSpectrometer') {\n      setSelectedNode(node);\n      console.log('Selected node set:', node.id, nodeType);\n    }\n    if (node.type === 'detector' || node.type === 'USBSpectrometer' || node.type === 'MQTTSpectrometer') {\n      // Store the graph ref when opening a spectrometer\n      const graphRef = /*#__PURE__*/React.createRef();\n      graphRefs.current[node.id] = graphRef;\n\n      // ... rest of the existing handleNodeClick code ...\n    }\n  };\n  const handleNodeAction = action => {\n    console.log('Node action:', action);\n    // Here you would implement the actual device communication\n    // based on the action type and parameters\n  };\n  const togglePumpSpeeds = () => {\n    setDisplayPumpSpeeds(!displayPumpSpeeds);\n  };\n\n  // Toggle functions for each display option\n  const toggleNodeIds = () => {\n    setDisplayNodeIds(!displayNodeIds);\n  };\n  const toggleDropletInfo = () => {\n    setDisplayDropletInfo(!displayDropletInfo);\n  };\n  const toggleDropletGaps = () => {\n    setDisplayDropletGaps(!displayDropletGaps);\n  };\n  const toggleEdgeLabels = () => {\n    setDisplayEdgeLabels(!displayEdgeLabels);\n  };\n  const toggleDisplayMenu = () => {\n    setDisplayMenuOpen(!isDisplayMenuOpen);\n  };\n  const toggleTimelineDropletInfo = () => {\n    setDisplayTimelineDropletInfo(!displayTimelineDropletInfo);\n  };\n  const toggleDetectorEvents = () => {\n    setDisplayDetectorEvents(!displayDetectorEvents);\n  };\n\n  // Close menu when clicking outside\n  useEffect(() => {\n    const handleClickOutside = event => {\n      if (displayMenuRef.current && !displayMenuRef.current.contains(event.target)) {\n        setDisplayMenuOpen(false);\n      }\n    };\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => {\n      document.removeEventListener('mousedown', handleClickOutside);\n    };\n  }, []);\n\n  // Function to toggle pump panel visibility\n  const togglePumpPanel = pumpId => {\n    setVisiblePumpPanel(prev => prev === pumpId ? null : pumpId);\n  };\n\n  // Add styles for the display menu\n  const styles = {\n    container: {\n      ...backgroundVariants.mainBackground,\n      padding: '20px',\n      minHeight: '100vh'\n    },\n    dropletInfo: {\n      padding: '8px',\n      borderRadius: '4px',\n      fontSize: '12px',\n      ...backgroundVariants.panelBackground,\n      color: '#fff',\n      minWidth: '150px'\n    },\n    timelineContainer: {\n      display: 'flex',\n      flexDirection: 'column',\n      gap: '10px',\n      marginBottom: '20px'\n    },\n    timeInput: {\n      width: '100px',\n      ...backgroundVariants.inputBackground,\n      padding: '5px',\n      borderRadius: '4px',\n      marginLeft: '8px'\n    },\n    buttonGroup: {\n      display: 'flex',\n      gap: '10px',\n      marginTop: '20px',\n      marginBottom: '20px'\n    },\n    timelineControls: {\n      display: 'flex',\n      flexDirection: 'column',\n      gap: '15px',\n      marginBottom: '20px',\n      ...backgroundVariants.panelBackground,\n      padding: '15px',\n      borderRadius: '4px'\n    },\n    timeControls: {\n      display: 'flex',\n      flexDirection: 'column',\n      gap: '15px'\n    },\n    sliderContainer: {\n      display: 'flex',\n      gap: '10px',\n      alignItems: 'center',\n      borderBottom: '1px solid rgba(255,255,255,0.1)',\n      paddingBottom: '15px'\n    },\n    timeStepButtons: {\n      display: 'flex',\n      gap: '5px',\n      alignItems: 'center',\n      justifyContent: 'flex-start'\n    },\n    timeScaleContainer: {\n      display: 'flex',\n      alignItems: 'center',\n      gap: '15px',\n      justifyContent: 'flex-start',\n      borderTop: '1px solid rgba(255,255,255,0.1)',\n      paddingTop: '15px'\n    },\n    svgContainer: {\n      background: backgroundVariants.panelBackground.background,\n      borderRadius: '4px',\n      padding: '10px'\n    },\n    navigationButtons: {\n      display: 'flex',\n      justifyContent: 'space-between',\n      marginBottom: '20px'\n    },\n    timeSlider: {\n      width: '33%',\n      ...backgroundVariants.inputBackground,\n      height: '20px',\n      borderRadius: '10px',\n      WebkitAppearance: 'none',\n      appearance: 'none',\n      background: backgroundVariants.inputBackground.background,\n      outline: 'none',\n      opacity: '0.7',\n      transition: 'opacity .2s',\n      '&:hover': {\n        opacity: '1'\n      },\n      '&::-webkit-slider-thumb': {\n        WebkitAppearance: 'none',\n        appearance: 'none',\n        width: '20px',\n        height: '20px',\n        background: '#4CAF50',\n        cursor: 'pointer',\n        borderRadius: '50%'\n      },\n      '&::-moz-range-thumb': {\n        width: '20px',\n        height: '20px',\n        background: '#4CAF50',\n        cursor: 'pointer',\n        borderRadius: '50%'\n      }\n    },\n    // Add styles for display menu\n    displayMenuButton: {\n      ...buttonVariants.infoButton,\n      position: 'relative'\n    },\n    displayMenu: {\n      position: 'absolute',\n      top: '100%',\n      right: 0,\n      backgroundColor: '#333',\n      border: '1px solid #555',\n      borderRadius: '4px',\n      padding: '8px 0',\n      zIndex: 1000,\n      width: '220px',\n      boxShadow: '0 2px 10px rgba(0, 0, 0, 0.3)'\n    },\n    menuItem: {\n      padding: '8px 16px',\n      cursor: 'pointer',\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'space-between',\n      color: 'white',\n      transition: 'background-color 0.2s',\n      '&:hover': {\n        backgroundColor: '#444'\n      }\n    },\n    checkmark: {\n      color: '#4CAF50',\n      fontWeight: 'bold'\n    }\n  };\n  const sliderStyle = {\n    width: '100%',\n    height: '10px',\n    borderRadius: '5px',\n    background: '#333',\n    outline: 'none',\n    opacity: '0.7',\n    transition: 'opacity .2s'\n    // Remove all pseudo-element styles that were here\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: styles.container,\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      style: styles.timelineControls,\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        style: styles.timeControls,\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          style: styles.sliderContainer,\n          children: [/*#__PURE__*/_jsxDEV(\"input\", {\n            type: \"range\",\n            min: 0,\n            max: Math.max(0, dropletHistory.length - 1),\n            value: currentTimepoint,\n            onChange: e => jumpToTimepoint(Number(e.target.value)),\n            disabled: isSimulationRunning,\n            style: styles.timeSlider,\n            className: \"time-slider\" // Add this className\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1766,\n            columnNumber: 13\n          }, this), displayTimelineDropletInfo && /*#__PURE__*/_jsxDEV(\"div\", {\n            style: {\n              display: 'flex',\n              gap: '10px',\n              flexWrap: 'wrap'\n            },\n            children: dropletHistory.length > 0 && ((_dropletHistory$curre = dropletHistory[currentTimepoint]) === null || _dropletHistory$curre === void 0 ? void 0 : _dropletHistory$curre.droplets.map((droplet, index) => {\n              var _graphData$nodes$find3, _graphData$nodes$find4;\n              return /*#__PURE__*/_jsxDEV(\"div\", {\n                style: styles.dropletInfo,\n                children: [/*#__PURE__*/_jsxDEV(\"div\", {\n                  children: [\"Droplet \", index + 1, \":\"]\n                }, void 0, true, {\n                  fileName: _jsxFileName,\n                  lineNumber: 1780,\n                  columnNumber: 21\n                }, this), droplet.frontNextNodeID && /*#__PURE__*/_jsxDEV(\"div\", {\n                  children: [\"Front \\u2192 \", ((_graphData$nodes$find3 = graphData.nodes.find(n => n.id === droplet.frontNextNodeID)) === null || _graphData$nodes$find3 === void 0 ? void 0 : _graphData$nodes$find3.label) || droplet.frontNextNodeID]\n                }, void 0, true, {\n                  fileName: _jsxFileName,\n                  lineNumber: 1782,\n                  columnNumber: 23\n                }, this), droplet.rearNextNodeID && /*#__PURE__*/_jsxDEV(\"div\", {\n                  children: [\"Rear \\u2192 \", ((_graphData$nodes$find4 = graphData.nodes.find(n => n.id === droplet.rearNextNodeID)) === null || _graphData$nodes$find4 === void 0 ? void 0 : _graphData$nodes$find4.label) || droplet.rearNextNodeID]\n                }, void 0, true, {\n                  fileName: _jsxFileName,\n                  lineNumber: 1785,\n                  columnNumber: 23\n                }, this)]\n              }, droplet.id, true, {\n                fileName: _jsxFileName,\n                lineNumber: 1779,\n                columnNumber: 19\n              }, this);\n            }))\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1777,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1765,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: styles.timeStepButtons,\n          children: [/*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => jumpToTimepoint(0),\n            disabled: currentTimepoint === 0 || isSimulationRunning,\n            style: {\n              ...buttonVariants.secondaryButton,\n              padding: '4px 8px'\n            },\n            children: \"\\u23EE\\uFE0F Start\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1794,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => jumpToTimepoint(currentTimepoint - 1),\n            disabled: currentTimepoint === 0 || isSimulationRunning,\n            style: {\n              ...buttonVariants.secondaryButton,\n              padding: '4px 8px'\n            },\n            children: \"\\u23EA Previous\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1801,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => jumpToTimepoint(currentTimepoint + 1),\n            disabled: currentTimepoint >= dropletHistory.length - 1 || isSimulationRunning,\n            style: {\n              ...buttonVariants.secondaryButton,\n              padding: '4px 8px'\n            },\n            children: \"Next \\u23E9\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1808,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => jumpToTimepoint(dropletHistory.length - 1),\n            disabled: currentTimepoint >= dropletHistory.length - 1 || isSimulationRunning,\n            style: {\n              ...buttonVariants.secondaryButton,\n              padding: '4px 8px'\n            },\n            children: \"End \\u23ED\\uFE0F\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1815,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1793,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: styles.timeScaleContainer,\n          children: [/*#__PURE__*/_jsxDEV(\"label\", {\n            style: {\n              color: '#fff',\n              marginRight: '10px'\n            },\n            children: [\"Time Scale:\", /*#__PURE__*/_jsxDEV(\"select\", {\n              value: timeScale,\n              onChange: e => setTimeScale(Number(e.target.value)),\n              style: styles.timeInput,\n              children: [/*#__PURE__*/_jsxDEV(\"option\", {\n                value: 0.0625,\n                children: \"1/16x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1832,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 0.25,\n                children: \"1/4x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1833,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 1,\n                children: \"1x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1834,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 4,\n                children: \"4x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1835,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 16,\n                children: \"16x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1836,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 64,\n                children: \"64x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1837,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 256,\n                children: \"256x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1838,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 1024,\n                children: \"1024x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1839,\n                columnNumber: 17\n              }, this)]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 1827,\n              columnNumber: 15\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1825,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"label\", {\n            style: {\n              color: '#fff',\n              marginRight: '10px'\n            },\n            children: [\"Current Time: \", currentTime.toFixed(2), \"s\"]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1842,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"label\", {\n            style: {\n              color: '#fff'\n            },\n            children: [\"Step: \", currentTimepoint + 1, \"/\", dropletHistory.length]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1845,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1824,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1764,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1763,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: styles.buttonGroup,\n      children: [/*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: isSimulationRunning ? stopSimulation : startSimulation,\n        style: {\n          ...buttonVariants.primaryButton\n        },\n        children: isSimulationRunning ? 'Stop Simulation' : 'Start Simulation'\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1853,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: restartSimulation,\n        style: {\n          ...buttonVariants.secondaryButton\n        },\n        children: \"Restart simulation\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1859,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: sendingEventsToDevices,\n        style: {\n          ...buttonVariants.primaryButton\n        },\n        children: \"Send Events to Devices\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1865,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        ref: displayMenuRef,\n        style: {\n          position: 'relative',\n          display: 'inline-block'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: toggleDisplayMenu,\n          style: styles.displayMenuButton,\n          children: \"Display Settings\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1872,\n          columnNumber: 11\n        }, this), isDisplayMenuOpen && /*#__PURE__*/_jsxDEV(\"div\", {\n          style: styles.displayMenu,\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: toggleNodeIds,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Node IDs\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1884,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayNodeIds ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1885,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1880,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: toggleDropletInfo,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Droplet Info\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1891,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayDropletInfo ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1892,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1887,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: toggleDropletGaps,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Droplet Gaps\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1898,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayDropletGaps ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1899,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1894,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: toggleEdgeLabels,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Tube Dimensions\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1905,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayEdgeLabels ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1906,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1901,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: togglePumpSpeeds,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Pump Speeds\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1912,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayPumpSpeeds ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1913,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1908,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: toggleTimelineDropletInfo,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Timeline Droplet Info\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1919,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayTimelineDropletInfo ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1920,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1915,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: toggleDetectorEvents,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Detector Events\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1926,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayDetectorEvents ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1927,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1922,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1879,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1871,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1852,\n      columnNumber: 7\n    }, this), graphData.nodes.length > 0 && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: styles.svgContainer,\n      children: /*#__PURE__*/_jsxDEV(\"svg\", {\n        width: \"2000\",\n        height: \"400\",\n        children: [graphData.links.map((link, index) => {\n          const sourceNode = graphData.nodes.find(node => node.id === link.source);\n          const targetNode = graphData.nodes.find(node => node.id === link.target);\n          if (!sourceNode || !targetNode) return null;\n          const midX = (sourceNode.x + targetNode.x) / 2;\n          const midY = (sourceNode.y + targetNode.y) / 2;\n          return /*#__PURE__*/_jsxDEV(\"g\", {\n            children: [/*#__PURE__*/_jsxDEV(\"line\", {\n              x1: sourceNode.x,\n              y1: sourceNode.y,\n              x2: targetNode.x,\n              y2: targetNode.y,\n              stroke: \"#999\",\n              strokeWidth: 2\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1949,\n              columnNumber: 19\n            }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n              x: midX,\n              y: midY - 20,\n              textAnchor: \"middle\",\n              fill: \"#fff\",\n              fontSize: \"12px\",\n              style: {\n                display: displayEdgeLabels ? 'block' : 'none'\n              },\n              children: `${link.length} mm (Ø ${link.diameter} mm)`\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1957,\n              columnNumber: 19\n            }, this)]\n          }, `edge-${index}`, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1948,\n            columnNumber: 17\n          }, this);\n        }), graphData.nodes.map((node, index) => /*#__PURE__*/_jsxDEV(\"g\", {\n          children: [/*#__PURE__*/_jsxDEV(\"circle\", {\n            cx: node.x,\n            cy: node.y,\n            r: 15,\n            fill: getNodeColor(node),\n            stroke: selectedNode && selectedNode.id === node.id ? '#FFA500' : 'none',\n            strokeWidth: selectedNode && selectedNode.id === node.id ? '3' : '0',\n            onClick: () => handleNodeClick(node),\n            style: {\n              cursor: 'pointer'\n            }\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1974,\n            columnNumber: 17\n          }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n            x: node.x,\n            y: node.y - 25,\n            textAnchor: \"middle\",\n            fill: \"#fff\",\n            fontSize: \"12px\",\n            children: node.label\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1984,\n            columnNumber: 17\n          }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n            x: node.x,\n            y: node.y - 10,\n            textAnchor: \"middle\",\n            fill: \"#fff\",\n            fontSize: \"10px\",\n            style: {\n              display: displayNodeIds ? 'block' : 'none'\n            },\n            children: `ID: ${node.id}`\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1993,\n            columnNumber: 17\n          }, this)]\n        }, `node-${index}`, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1973,\n          columnNumber: 15\n        }, this)), interpolateDropletState(currentTime).map((droplet, index, droplets) => {\n          const frontX = volumetricToXPosition(droplet.frontVolumetricPosition);\n          const rearX = volumetricToXPosition(droplet.rearVolumetricPosition);\n          const centerX = (frontX + rearX) / 2;\n\n          // Calculate distance to next droplet if this isn't the last droplet\n          const distanceInfo = index < droplets.length - 1 ? {\n            nextDropletFront: droplets[index + 1].frontVolumetricPosition,\n            distance: Math.abs(droplets[index + 1].frontVolumetricPosition - droplet.rearVolumetricPosition)\n          } : null;\n\n          // Calculate midpoint for distance label\n          const distanceLabelX = distanceInfo ? (volumetricToXPosition(droplet.rearVolumetricPosition) + volumetricToXPosition(distanceInfo.nextDropletFront)) / 2 : null;\n          return /*#__PURE__*/_jsxDEV(\"g\", {\n            children: [/*#__PURE__*/_jsxDEV(\"line\", {\n              x1: rearX,\n              y1: 300,\n              x2: frontX,\n              y2: 300,\n              stroke: \"rgba(255, 100, 100, 0.9)\",\n              strokeWidth: 8,\n              strokeLinecap: \"butt\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 2026,\n              columnNumber: 19\n            }, this), distanceInfo && displayDropletGaps && /*#__PURE__*/_jsxDEV(\"g\", {\n              children: [/*#__PURE__*/_jsxDEV(\"line\", {\n                x1: rearX,\n                y1: 320,\n                x2: volumetricToXPosition(distanceInfo.nextDropletFront),\n                y2: 320,\n                stroke: \"#fff\",\n                strokeWidth: 1,\n                strokeDasharray: \"5,5\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2040,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"line\", {\n                x1: rearX,\n                y1: 315,\n                x2: rearX,\n                y2: 325,\n                stroke: \"#fff\",\n                strokeWidth: 1\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2050,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"line\", {\n                x1: volumetricToXPosition(distanceInfo.nextDropletFront),\n                y1: 315,\n                x2: volumetricToXPosition(distanceInfo.nextDropletFront),\n                y2: 325,\n                stroke: \"#666\",\n                strokeWidth: 1\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2058,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                x: distanceLabelX,\n                y: 335,\n                textAnchor: \"middle\",\n                fill: \"#666\",\n                fontSize: \"12px\",\n                children: `${distanceInfo.distance.toFixed(2)} μL`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2067,\n                columnNumber: 23\n              }, this)]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 2038,\n              columnNumber: 21\n            }, this), displayDropletInfo && /*#__PURE__*/_jsxDEV(_Fragment, {\n              children: [/*#__PURE__*/_jsxDEV(\"text\", {\n                x: centerX,\n                y: 270,\n                textAnchor: \"middle\",\n                fill: \"#6f6\",\n                fontSize: \"12px\",\n                children: `Vol: ${(droplet.frontVolumetricPosition - droplet.rearVolumetricPosition).toFixed(2)} μL`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2082,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                x: centerX,\n                y: 255,\n                textAnchor: \"middle\",\n                fill: \"#6f6\",\n                fontSize: \"12px\",\n                children: `Spd f: ${droplet.frontVolumetricSpeed.toFixed(2)} μL/s`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2091,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                x: centerX,\n                y: 240,\n                textAnchor: \"middle\",\n                fill: \"#6f6\",\n                fontSize: \"12px\",\n                children: `Spd r: ${droplet.rearVolumetricSpeed.toFixed(2)} μL/s`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2100,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                x: centerX,\n                y: 225,\n                textAnchor: \"middle\",\n                fill: \"#6f6\",\n                fontSize: \"12px\",\n                children: `mlt: ${droplet.pumpSpeedMultiplier.toFixed(2)}`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2109,\n                columnNumber: 23\n              }, this)]\n            }, void 0, true)]\n          }, `droplet-${droplet.id}`, true, {\n            fileName: _jsxFileName,\n            lineNumber: 2024,\n            columnNumber: 17\n          }, this);\n        }), displayPumpSpeeds && graphData.nodes.map((node, index) => {\n          if (node.type === 'pump') {\n            var _dropletHistory;\n            const currentSpeed = getPumpSpeedAtTime(node.id, pumpEvents, currentTime);\n            const maxTime = ((_dropletHistory = dropletHistory[dropletHistory.length - 1]) === null || _dropletHistory === void 0 ? void 0 : _dropletHistory.time) || 1;\n            const pumpSpecificEvents = pumpEvents.filter(event => event.target === node.id);\n            return /*#__PURE__*/_jsxDEV(\"g\", {\n              children: [/*#__PURE__*/_jsxDEV(\"text\", {\n                x: node.x,\n                y: node.y - 35,\n                textAnchor: \"middle\",\n                fill: \"#4CAF50\",\n                fontSize: \"12px\",\n                children: `${currentSpeed.toFixed(2)} μL/s`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2133,\n                columnNumber: 21\n              }, this), /*#__PURE__*/_jsxDEV(\"g\", {\n                transform: `translate(${node.x - 40}, ${node.y - 65})`,\n                children: [pumpSpecificEvents.map((event, i, arr) => {\n                  const nextEvent = arr[i + 1];\n                  const width = 80;\n                  const x = 0;\n                  const y = 0;\n\n                  // Calculate position based on time\n                  const timePosition = event.time / maxTime * width;\n                  const nextTimePosition = nextEvent ? nextEvent.time / maxTime * width : width;\n\n                  // Calculate height based on speed value (normalized)\n                  const maxSpeed = Math.max(...pumpSpecificEvents.map(e => e.value));\n                  const normalizedHeight = event.value / (maxSpeed || 1) * 20;\n                  return /*#__PURE__*/_jsxDEV(\"g\", {\n                    children: [/*#__PURE__*/_jsxDEV(\"line\", {\n                      x1: x + timePosition,\n                      y1: y - normalizedHeight,\n                      x2: x + nextTimePosition,\n                      y2: y - normalizedHeight,\n                      stroke: \"#4CAF50\",\n                      strokeWidth: 2\n                    }, void 0, false, {\n                      fileName: _jsxFileName,\n                      lineNumber: 2164,\n                      columnNumber: 29\n                    }, this), /*#__PURE__*/_jsxDEV(\"circle\", {\n                      cx: x + timePosition,\n                      cy: y - normalizedHeight,\n                      r: 2,\n                      fill: \"#4CAF50\"\n                    }, void 0, false, {\n                      fileName: _jsxFileName,\n                      lineNumber: 2173,\n                      columnNumber: 29\n                    }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                      x: x + timePosition,\n                      y: y + 12,\n                      textAnchor: \"middle\",\n                      fill: \"#666\",\n                      fontSize: \"10px\",\n                      children: [event.time.toFixed(1), \"s\"]\n                    }, void 0, true, {\n                      fileName: _jsxFileName,\n                      lineNumber: 2180,\n                      columnNumber: 29\n                    }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                      x: x + timePosition,\n                      y: y - normalizedHeight - 5,\n                      textAnchor: \"middle\",\n                      fill: \"#4CAF50\",\n                      fontSize: \"8px\",\n                      children: event.value.toFixed(1)\n                    }, void 0, false, {\n                      fileName: _jsxFileName,\n                      lineNumber: 2190,\n                      columnNumber: 29\n                    }, this)]\n                  }, `pump-event-${i}`, true, {\n                    fileName: _jsxFileName,\n                    lineNumber: 2162,\n                    columnNumber: 27\n                  }, this);\n                }), /*#__PURE__*/_jsxDEV(\"line\", {\n                  x1: currentTime / maxTime * 80,\n                  y1: -25,\n                  x2: currentTime / maxTime * 80,\n                  y2: 15,\n                  stroke: \"red\",\n                  strokeWidth: 1,\n                  strokeDasharray: \"2,2\"\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 2203,\n                  columnNumber: 23\n                }, this)]\n              }, void 0, true, {\n                fileName: _jsxFileName,\n                lineNumber: 2144,\n                columnNumber: 21\n              }, this)]\n            }, `pump-speed-${node.id}`, true, {\n              fileName: _jsxFileName,\n              lineNumber: 2131,\n              columnNumber: 19\n            }, this);\n          }\n          return null;\n        }), displayDetectorEvents && graphData.nodes.map((node, index) => {\n          if (node.type === 'detector' || node.type === 'USBSpectrometer' || node.type === 'MQTTSpectrometer') {\n            var _dropletHistory2;\n            const currentEvents = getDetectorEventsAtTime(node.id, detectorEvents, currentTime);\n            const detectorSpecificEvents = detectorEvents.filter(event => event.target === node.id);\n            const maxTime = ((_dropletHistory2 = dropletHistory[dropletHistory.length - 1]) === null || _dropletHistory2 === void 0 ? void 0 : _dropletHistory2.time) || 1;\n            return /*#__PURE__*/_jsxDEV(\"g\", {\n              children: [currentEvents.length > 0 && /*#__PURE__*/_jsxDEV(\"circle\", {\n                cx: node.x,\n                cy: node.y,\n                r: 20,\n                fill: \"none\",\n                stroke: \"#FF6B35\",\n                strokeWidth: 3,\n                opacity: 0.8\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2230,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                x: node.x,\n                y: node.y - 35,\n                textAnchor: \"middle\",\n                fill: \"#FF6B35\",\n                fontSize: \"12px\",\n                children: `Events: ${detectorSpecificEvents.length}`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2242,\n                columnNumber: 21\n              }, this), /*#__PURE__*/_jsxDEV(\"g\", {\n                transform: `translate(${node.x - 40}, ${node.y - 65})`,\n                children: [detectorSpecificEvents.map((event, i) => {\n                  const width = 80;\n                  const x = 0;\n                  const y = 0;\n\n                  // Calculate position based on time\n                  const timePosition = event.time / maxTime * width;\n                  return /*#__PURE__*/_jsxDEV(\"g\", {\n                    children: [/*#__PURE__*/_jsxDEV(\"circle\", {\n                      cx: x + timePosition,\n                      cy: y,\n                      r: 3,\n                      fill: event.eventSubtype === 'dropletFrontReached' ? '#FF6B35' : '#FFA500'\n                    }, void 0, false, {\n                      fileName: _jsxFileName,\n                      lineNumber: 2265,\n                      columnNumber: 29\n                    }, this), /*#__PURE__*/_jsxDEV(\"line\", {\n                      x1: x + timePosition,\n                      y1: y - 5,\n                      x2: x + timePosition,\n                      y2: y + 5,\n                      stroke: \"#FF6B35\",\n                      strokeWidth: 1\n                    }, void 0, false, {\n                      fileName: _jsxFileName,\n                      lineNumber: 2272,\n                      columnNumber: 29\n                    }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                      x: x + timePosition,\n                      y: y + 15,\n                      textAnchor: \"middle\",\n                      fill: \"#FF6B35\",\n                      fontSize: \"8px\",\n                      children: [event.time.toFixed(1), \"s\"]\n                    }, void 0, true, {\n                      fileName: _jsxFileName,\n                      lineNumber: 2281,\n                      columnNumber: 29\n                    }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                      x: x + timePosition,\n                      y: y - 10,\n                      textAnchor: \"middle\",\n                      fill: \"#FF6B35\",\n                      fontSize: \"8px\",\n                      children: [\"D\", event.dropletId]\n                    }, void 0, true, {\n                      fileName: _jsxFileName,\n                      lineNumber: 2291,\n                      columnNumber: 29\n                    }, this)]\n                  }, `detector-event-${i}`, true, {\n                    fileName: _jsxFileName,\n                    lineNumber: 2263,\n                    columnNumber: 27\n                  }, this);\n                }), /*#__PURE__*/_jsxDEV(\"line\", {\n                  x1: currentTime / maxTime * 80,\n                  y1: -25,\n                  x2: currentTime / maxTime * 80,\n                  y2: 25,\n                  stroke: \"red\",\n                  strokeWidth: 1,\n                  strokeDasharray: \"2,2\"\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 2304,\n                  columnNumber: 23\n                }, this)]\n              }, void 0, true, {\n                fileName: _jsxFileName,\n                lineNumber: 2253,\n                columnNumber: 21\n              }, this)]\n            }, `detector-events-${node.id}`, true, {\n              fileName: _jsxFileName,\n              lineNumber: 2227,\n              columnNumber: 19\n            }, this);\n          }\n          return null;\n        })]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1937,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1936,\n      columnNumber: 9\n    }, this), selectedNode && (selectedNode.type === 'pump' || ((_selectedNode$data = selectedNode.data) === null || _selectedNode$data === void 0 ? void 0 : _selectedNode$data.type) === 'pump') && /*#__PURE__*/_jsxDEV(DraggablePanel, {\n      initialPosition: pumpPanelPosition,\n      title: `Pump Controls - ${selectedNode.label || selectedNode.id}`,\n      children: /*#__PURE__*/_jsxDEV(PumpActions, {\n        node: selectedNode,\n        nodes: nodes,\n        edges: edges,\n        onAction: handleNodeAction\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 2328,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 2324,\n      columnNumber: 9\n    }, this), selectedNode && (selectedNode.type === 'USBSpectrometer' || ((_selectedNode$data2 = selectedNode.data) === null || _selectedNode$data2 === void 0 ? void 0 : _selectedNode$data2.type) === 'USBSpectrometer') && /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [console.log('Rendering USBSpectrometer component for node:', selectedNode), /*#__PURE__*/_jsxDEV(USBSpectrometer, {\n        detector: selectedNode,\n        detectorId: selectedNode.id,\n        detectorName: selectedNode.label || selectedNode.id,\n        onClose: () => setSelectedNode(null),\n        initialPosition: {\n          x: 150,\n          y: 100\n        },\n        isVisible: true\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 2339,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true), selectedNode && (selectedNode.type === 'MQTTSpectrometer' || ((_selectedNode$data3 = selectedNode.data) === null || _selectedNode$data3 === void 0 ? void 0 : _selectedNode$data3.type) === 'MQTTSpectrometer') && /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [console.log('Rendering SpectrometerMQTT component for node:', selectedNode), /*#__PURE__*/_jsxDEV(SpectrometerMQTT, {\n        detector: selectedNode,\n        detectorId: selectedNode.id,\n        detectorName: selectedNode.label || selectedNode.id,\n        onClose: () => setSelectedNode(null),\n        initialPosition: {\n          x: 150,\n          y: 100\n        },\n        isVisible: true\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 2352,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true), /*#__PURE__*/_jsxDEV(\"style\", {\n      children: `\n          .node-actions {\n            position: fixed;\n            top: 20px;\n            right: 20px;\n            background: black;\n            padding: 20px;\n            border: 1px solid #ccc;\n            border-radius: 5px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n          }\n          .node-actions h3 {\n            margin: 0 0 15px 0;\n            color: #333;\n          }\n          .node-actions button {\n            margin: 5px;\n            padding: 8px 16px;\n            background: #4CAF50;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n          }\n          .node-actions button:disabled {\n            background: #ccc;\n            cursor: not-allowed;\n          }\n          .node-actions input {\n            margin: 5px;\n            padding: 8px;\n            border: 1px solid #ccc;\n            border-radius: 4px;\n            width: 80px;\n          }\n          .move-controls {\n            display: flex;\n            flex-direction: column;\n            gap: 10px;\n            margin-top: 10px;\n          }\n          .input-group {\n            display: flex;\n            align-items: center;\n            gap: 10px;\n          }\n          .input-group label {\n            min-width: 100px;\n            text-align: right;\n            color: #666;\n          }\n        `\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 2363,\n      columnNumber: 7\n    }, this), overlayComponent && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: 'fixed',\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0,\n        zIndex: 9999,\n        pointerEvents: 'none'\n      },\n      children: /*#__PURE__*/_jsxDEV(Suspense, {\n        fallback: /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            position: 'fixed',\n            top: '50%',\n            left: '50%',\n            transform: 'translate(-50%, -50%)',\n            background: 'rgba(0,0,0,0.8)',\n            padding: '20px',\n            borderRadius: '8px',\n            color: 'white',\n            pointerEvents: 'auto'\n          },\n          children: /*#__PURE__*/_jsxDEV(\"h2\", {\n            children: \"Loading Component...\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 2439,\n            columnNumber: 15\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2428,\n          columnNumber: 13\n        }, this),\n        children: [overlayComponent.type === 'USBSpectrometer' && /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            pointerEvents: 'auto'\n          },\n          children: /*#__PURE__*/_jsxDEV(USBSpectrometer, {\n            ...overlayComponent.props\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 2444,\n            columnNumber: 17\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2443,\n          columnNumber: 15\n        }, this), overlayComponent.type === 'MQTTSpectrometer' && /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            pointerEvents: 'auto'\n          },\n          children: /*#__PURE__*/_jsxDEV(SpectrometerMQTT, {\n            ...overlayComponent.props,\n            graphRef: graphRefs.current[overlayComponent.props.detector.id]\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 2449,\n            columnNumber: 17\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2448,\n          columnNumber: 15\n        }, this), overlayComponent.type === 'PumpPanel' && /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            pointerEvents: 'auto'\n          },\n          children: /*#__PURE__*/_jsxDEV(PumpPanel, {\n            ...overlayComponent.props\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 2457,\n            columnNumber: 17\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2456,\n          columnNumber: 15\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 2427,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 2418,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 1762,\n    columnNumber: 5\n  }, this);\n};\n_s(Simulation, \"CpoCBrE9dcWkinZ5MUDGpJrTK/s=\", false, function () {\n  return [useButtonStyles];\n});\n_c = Simulation;\nexport default Simulation;\nvar _c;\n$RefreshReg$(_c, \"Simulation\");","map":{"version":3,"names":["React","useState","useEffect","useCallback","useRef","Suspense","ReactFlowProvider","useNodesState","useEdgesState","PumpActions","DraggablePanel","convertToHardwareValuesPump","useButtonStyles","backgroundVariants","findOutletNode","findFurthestNode","orderNodesByDistance","calculateEdgeVolume","getVolumeBetweenNodes","findConnectedPump","getPumpSpeed","getPumpsBetweenPositions","cleanAndSortEventList","getPumpSpeedAtTime","sendEventsToDevices","setOfMainLineNodes","setOfSecondaryLineNodes","SvgDefs","calculateEdgePoints","createLabels","USBSpectrometer","SpectrometerMQTT","PumpPanel","jsxDEV","_jsxDEV","Fragment","_Fragment","Simulation","nodes","edges","droplets","selectedCarrierPumps","onBack","onNext","_s","_dropletHistory$curre","_selectedNode$data","_selectedNode$data2","_selectedNode$data3","buttonVariants","graphData","setGraphData","links","simulationDroplets","setSimulationDroplets","isSimulationRunning","setIsSimulationRunning","key","setKey","currentTime","setCurrentTime","timeScale","setTimeScale","animationFrameRef","lastFrameTimeRef","currentBlockDroplets","setCurrentBlockDroplets","dropletHistory","setDropletHistory","currentTimepoint","setCurrentTimepoint","pumpEvents","setPumpEvents","detectorEvents","setDetectorEvents","displayPumpSpeeds","setDisplayPumpSpeeds","displayNodeIds","setDisplayNodeIds","displayDropletInfo","setDisplayDropletInfo","displayDropletGaps","setDisplayDropletGaps","displayEdgeLabels","setDisplayEdgeLabels","isDisplayMenuOpen","setDisplayMenuOpen","displayTimelineDropletInfo","setDisplayTimelineDropletInfo","displayDetectorEvents","setDisplayDetectorEvents","displayMenuRef","selectedNode","setSelectedNode","ws","setWs","pumpPanelPosition","setPumpPanelPosition","x","window","innerWidth","y","visiblePumpPanel","setVisiblePumpPanel","isSendingEvents","setIsSendingEvents","graphRefs","overlayComponent","setOverlayComponent","console","log","length","map","node","_node$data","id","type","dataType","data","websocket","WebSocket","onopen","onerror","error","close","sendingEventsToDevices","generateEventList","Object","values","current","forEach","graphRef","addToMemory","eventType","calculateVolumesBetweenThermostats","outletNode","visited","Set","queue","thermostatVolumes","currentNodeId","accumulatedVolume","thermostatPath","shift","currentNode","find","n","has","add","updatedPath","push","startThermostatId","endThermostatId","volume","connectedEdges","filter","link","source","target","edge","nextNodeId","nextNode","edgeVolume","divideDropletsIntoBlocks","thermostatId","totalVolume","reduce","acc","droplet","actualVolume","temperature","time","furthestNode","volumeToFurthestNode","blocks","currentBlock","finalizeBlock","lastDroplet","surfixParam","parameters","p","name","value","Math","max","i","_droplet$parameters$f","_droplet$parameters$f2","_droplet$parameters$f3","_droplet$parameters$f4","_droplet$parameters$f5","relevantVolume","tv","dropletVolume","printDropletFrontPositionsAndSpeeds","frontVolumetricPosition","frontTimeToReachNextNode","frontVolumetricDistanceToNextNode","rearVolumetricPosition","rearTimeToReachNextNode","rearVolumetricDistanceToNextNode","frontNextNodeID","rearNextNodeID","extractPumpEvents","eventList","flat","event","sort","a","b","extractDetectorEvents","getDetectorEventsAtTime","detectorId","abs","recalculateEventListForDevices","deviceEventMap","Map","convertPumpEvent","deviceProperties","_deviceProperties$fin","_deviceProperties$fin2","_deviceProperties$fin3","_deviceProperties$fin4","syringeDiameter","default","syringeLength","stepsPerRevolution","lead","syringeArea","PI","pow","linearSpeed","stepsPerMm","stepsPerSecond","delayMicroseconds","round","delay","convertThermostatEvent","convertLedEvent","intensity","convertDetectorEvent","setting","deviceEventList","targetId","deviceNode","deviceEvents","properties","warn","Boolean","set","Array","from","isArray","orderedNodes","dropletSnapshot","dropletWithParams","d","volumetricSpeedParam","commonVolumetricSpeed","inletVolumetricSpeed","outletVolumetricSpeed","pump","connectedPump","connectedPumpRatio","connectedPumpSpeedAtPause","pumpSpeedMultiplier","pauseLevel","carrierPumpConnector","connectorNode","position","_droplet$parameters$f6","_droplet$parameters$f7","prefixVolume","surfixVolume","frontVolumetricSpeed","rearVolumetricSpeed","frontVolumetricSpeedAtPause","rearVolumetricSpeedAtPause","stoppingDroplet","initialPumping","lastDropletRearPosition","outletNodePosition","volumetricPosition","timePassed","newTimePassed","smallestFrontTime","Infinity","smallestRearTime","smallestFrontTimeDroplet","smallestRearTimeDroplet","min","reachedNode","reachedNodeDistance","distance","index","indexOf","dropletsOlder","slice","dropletsNewer","ds","drops","JSON","parse","stringify","snappedNode","existingSnapshotIndex","findIndex","snapshot","nextEdge","_smallestFrontTimeDro","_smallestFrontTimeDro2","pumpRatio","param","nodeId","dropletDesiredVolume","_smallestFrontTimeDro3","_smallestFrontTimeDro4","rearTimeLeft","totalTimeLeft","thispumpspeed","accumulatedSpeed","reverse","editedNode","pumpBoost","_smallestRearTimeDrop","detectorEndEvent","dropletId","eventSubtype","dropletData","speedDifference","accumulatedSpeedDecrease","pumpBreak","isFarthestThermostatOrLED","every","_smallestRearTimeDrop2","waitTime","carrierPumpEvent","_smallestRearTimeDrop3","dropletState","_droplet$parameters$f8","prev","graphNodes","label","graphLinks","_edge$data","_edge$data$properties","_edge$data2","_edge$data2$propertie","diameter","nodesLength","linksLength","dropletsLength","mainLineNodes","includes","secondaryLineNodes","mainLineY","secondaryLineY","pumpSpacing","currentX","currentVolumetricPosition","graphNode","e","nodesByDistance","pumpOffset","entries","connectedEdge","connectedNodeId","connectedMainNode","thermoVol","dropletsCopy","eventListForDevices","startSimulation","stopSimulation","cancelAnimationFrame","restartSimulation","prevKey","getNodeColor","volumetricToXPosition","_graphData$nodes$find","_graphData$nodes$find2","outletX","furthestX","isNaN","undefined","clampedPosition","scaledX","isFinite","updateDropletPositions","timestamp","requestAnimationFrame","deltaTime","simulationDeltaTime","prevTime","newTime","lastHistoryTime","currentState","interpolateDropletState","updatedDroplets","frontX","rearX","frontPosition","rearPosition","speed","state","beforeState","afterState","fraction","beforeDroplet","afterDroplet","jumpToTimepoint","nextTimepoint","previousTimepoint","handleNodeClick","_node$data2","_node$data3","nodeType","createRef","handleNodeAction","action","togglePumpSpeeds","toggleNodeIds","toggleDropletInfo","toggleDropletGaps","toggleEdgeLabels","toggleDisplayMenu","toggleTimelineDropletInfo","toggleDetectorEvents","handleClickOutside","contains","document","addEventListener","removeEventListener","togglePumpPanel","pumpId","styles","container","mainBackground","padding","minHeight","dropletInfo","borderRadius","fontSize","panelBackground","color","minWidth","timelineContainer","display","flexDirection","gap","marginBottom","timeInput","width","inputBackground","marginLeft","buttonGroup","marginTop","timelineControls","timeControls","sliderContainer","alignItems","borderBottom","paddingBottom","timeStepButtons","justifyContent","timeScaleContainer","borderTop","paddingTop","svgContainer","background","navigationButtons","timeSlider","height","WebkitAppearance","appearance","outline","opacity","transition","cursor","displayMenuButton","infoButton","displayMenu","top","right","backgroundColor","border","zIndex","boxShadow","menuItem","checkmark","fontWeight","sliderStyle","style","children","onChange","Number","disabled","className","fileName","_jsxFileName","lineNumber","columnNumber","flexWrap","_graphData$nodes$find3","_graphData$nodes$find4","onClick","secondaryButton","marginRight","toFixed","primaryButton","ref","sourceNode","targetNode","midX","midY","x1","y1","x2","y2","stroke","strokeWidth","textAnchor","fill","cx","cy","r","centerX","distanceInfo","nextDropletFront","distanceLabelX","strokeLinecap","strokeDasharray","_dropletHistory","currentSpeed","maxTime","pumpSpecificEvents","transform","arr","nextEvent","timePosition","nextTimePosition","maxSpeed","normalizedHeight","_dropletHistory2","currentEvents","detectorSpecificEvents","initialPosition","title","onAction","detector","detectorName","onClose","isVisible","left","bottom","pointerEvents","fallback","props","_c","$RefreshReg$"],"sources":["E:/flow chemistry/fluidicGUI/frontend/fluidicgui/src/components/Simulation/Simulation.js"],"sourcesContent":["import React, { useState, useEffect, useCallback, useRef, Suspense } from 'react';\r\nimport { ReactFlowProvider, useNodesState, useEdgesState } from 'react-flow-renderer';\r\nimport PumpActions from './NodeActions/PumpActions';\r\nimport DraggablePanel from './DraggablePanel';\r\nimport { convertToHardwareValuesPump } from '../../utils/pumpCalculations';\r\nimport { useButtonStyles } from '../../styles/ButtonStyleProvider';\r\nimport { backgroundVariants } from '../../styles/backgroundStyles';\r\nimport {\r\n  findOutletNode,\r\n  findFurthestNode,\r\n  orderNodesByDistance,\r\n  calculateEdgeVolume,\r\n  getVolumeBetweenNodes,\r\n  findConnectedPump,\r\n  getPumpSpeed,\r\n  getPumpsBetweenPositions,\r\n  cleanAndSortEventList,\r\n  getPumpSpeedAtTime,\r\n  sendEventsToDevices,\r\n  setOfMainLineNodes,\r\n  setOfSecondaryLineNodes\r\n} from '../../utils/simulationUtils';\r\nimport './simulation.css'; // We'll create this CSS file\r\nimport SvgDefs from './SvgDefs';\r\nimport { calculateEdgePoints, createLabels } from '../../utils/flowchartUtils';\r\nimport USBSpectrometer from './USBSpectrometer';\r\nimport SpectrometerMQTT from './SpectrometerMQTT';\r\nimport PumpPanel from './PumpPanel';\r\n\r\nconst Simulation = ({ nodes = [], edges = [], droplets = [], selectedCarrierPumps = [], onBack, onNext }) => {\r\n  const buttonVariants = useButtonStyles();\r\n  const [graphData, setGraphData] = useState({ nodes: [], links: [] });\r\n  const [simulationDroplets, setSimulationDroplets] = useState([]);\r\n  const [isSimulationRunning, setIsSimulationRunning] = useState(false);\r\n  const [key, setKey] = useState(0);\r\n  const [currentTime, setCurrentTime] = useState(0);\r\n  const [timeScale, setTimeScale] = useState(1); // Default 1x speed\r\n  const animationFrameRef = useRef();\r\n  const lastFrameTimeRef = useRef();\r\n  const [currentBlockDroplets, setCurrentBlockDroplets] = useState([]);\r\n  const [dropletHistory, setDropletHistory] = useState([]);\r\n  const [currentTimepoint, setCurrentTimepoint] = useState(0);\r\n  const [pumpEvents, setPumpEvents] = useState([]);\r\n  const [detectorEvents, setDetectorEvents] = useState([]);\r\n  const [displayPumpSpeeds, setDisplayPumpSpeeds] = useState(false);\r\n  const [displayNodeIds, setDisplayNodeIds] = useState(false);\r\n  const [displayDropletInfo, setDisplayDropletInfo] = useState(false);\r\n  const [displayDropletGaps, setDisplayDropletGaps] = useState(true);\r\n  const [displayEdgeLabels, setDisplayEdgeLabels] = useState(false);\r\n  const [isDisplayMenuOpen, setDisplayMenuOpen] = useState(false);\r\n  const [displayTimelineDropletInfo, setDisplayTimelineDropletInfo] = useState(false);\r\n  const [displayDetectorEvents, setDisplayDetectorEvents] = useState(false);\r\n  const displayMenuRef = useRef(null);\r\n  const [selectedNode, setSelectedNode] = useState(null);\r\n  const [ws, setWs] = useState(null);\r\n  const [pumpPanelPosition, setPumpPanelPosition] = useState({ x: window.innerWidth - 300, y: 100 });\r\n  const [visiblePumpPanel, setVisiblePumpPanel] = useState(null);\r\n  const [isSendingEvents, setIsSendingEvents] = useState(false);\r\n  const graphRefs = useRef({});\r\n  const [overlayComponent, setOverlayComponent] = useState(null);\r\n\r\n  // Add at the beginning of the component, after the state initialization\r\n  useEffect(() => {\r\n    // Log all nodes and their types for debugging\r\n    console.log('All nodes:', nodes);\r\n    if (nodes && nodes.length > 0) {\r\n      console.log('Node types in simulation:', nodes.map(node => ({\r\n        id: node.id,\r\n        type: node.type,\r\n        dataType: node.data?.type\r\n      })));\r\n    }\r\n  }, [nodes]);\r\n\r\n  useEffect(() => {\r\n    // Create WebSocket connection\r\n    const websocket = new WebSocket('ws://localhost:4000');\r\n    \r\n    websocket.onopen = () => {\r\n      console.log('Connected to WebSocket server');\r\n    };\r\n\r\n    websocket.onerror = (error) => {\r\n      console.error('WebSocket error:', error);\r\n    };\r\n\r\n    setWs(websocket);\r\n\r\n    // Cleanup on unmount\r\n    return () => {\r\n      if (websocket) {\r\n        websocket.close();\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  const sendingEventsToDevices = () => {\r\n    setIsSendingEvents(true);\r\n    sendEventsToDevices(pumpEvents, ws, nodes);\r\n    // Reset simulation state\r\n    setCurrentTime(0);\r\n    setCurrentTimepoint(0);\r\n    setIsSimulationRunning(true);\r\n    setDropletHistory([]);\r\n    // Generate new event list\r\n    generateEventList([{ droplets: droplets }]);\r\n  };\r\n\r\n  // Add effect to handle automatic memory addition when events are being sent\r\n  useEffect(() => {\r\n    if (isSendingEvents) {\r\n      // Get all graph refs and add data to memory\r\n      Object.values(graphRefs.current).forEach(graphRef => {\r\n        if (graphRef && graphRef.current && graphRef.current.addToMemory) {\r\n          graphRef.current.addToMemory();\r\n        }\r\n      });\r\n    }\r\n  }, [isSendingEvents]);\r\n\r\n  const eventType = ['setPumpSpeed', 'setThermostatTemperature', 'setLedIntensity', 'wait', 'blockEnd'];\r\n\r\n  const calculateVolumesBetweenThermostats = (graphData) => {\r\n  \r\n    // Find outlet node first\r\n    const outletNode = findOutletNode(graphData.nodes);\r\n  \r\n    const visited = new Set();\r\n    const queue = [[outletNode.id, 0, []]]; // [nodeId, accumulated volume, path of thermostats]\r\n    const thermostatVolumes = [];\r\n  \r\n    while (queue.length > 0) {\r\n      let [currentNodeId, accumulatedVolume, thermostatPath] = queue.shift();\r\n      const currentNode = graphData.nodes.find(n => n.id === currentNodeId);\r\n  \r\n      if (!currentNode) continue;\r\n      \r\n      // Track all visited nodes to prevent infinite loops\r\n      if (visited.has(currentNodeId)) continue;\r\n      visited.add(currentNodeId);\r\n  \r\n      // If we found a thermostat, add it to the path\r\n      let updatedPath = [...thermostatPath];\r\n      if (currentNode.type === 'thermostat') {\r\n        if (thermostatPath.length > 0) {\r\n          thermostatVolumes.push({\r\n            startThermostatId: thermostatPath[thermostatPath.length - 1],\r\n            endThermostatId: currentNodeId,\r\n            volume: accumulatedVolume\r\n          });\r\n        }\r\n        updatedPath.push(currentNodeId);\r\n        // Reset accumulated volume after finding a thermostat\r\n        accumulatedVolume = 0;\r\n      }\r\n  \r\n      // Find all connected edges and nodes\r\n      const connectedEdges = graphData.links.filter(link => \r\n        link.source === currentNodeId || link.target === currentNodeId\r\n      );\r\n  \r\n      for (const edge of connectedEdges) {\r\n        const nextNodeId = edge.source === currentNodeId ? edge.target : edge.source;\r\n        const nextNode = graphData.nodes.find(n => n.id === nextNodeId);\r\n        \r\n        // Skip paths to pumps\r\n        if (nextNode && nextNode.type !== 'pump') {\r\n          const edgeVolume = calculateEdgeVolume(edge);\r\n          queue.push([nextNodeId, accumulatedVolume + edgeVolume, updatedPath]);\r\n        }\r\n      }\r\n    }\r\n  \r\n    return thermostatVolumes;\r\n  };\r\n//add something to handle lack of thermostat\r\n  const divideDropletsIntoBlocks = (droplets, thermostatVolumes) => {\r\n\r\n    if (thermostatVolumes.length === 0) {\r\n      return [{\r\n        droplets: droplets,\r\n        thermostatId: null,\r\n        totalVolume: droplets.reduce((acc, droplet) => acc + droplet.actualVolume, 0),\r\n        temperature: null,\r\n        time: null\r\n      }];\r\n    }\r\n\r\n    const furthestNode = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links);\r\n\r\n    const volumeToFurthestNode = getVolumeBetweenNodes(thermostatVolumes[0].endThermostatId, furthestNode.id, graphData.nodes, graphData.links);\r\n    \r\n    if (!droplets.length || !thermostatVolumes.length) return [];\r\n\r\n    const blocks = [];\r\n    let currentBlock = {\r\n      droplets: [],\r\n      thermostatId: thermostatVolumes[0].endThermostatId,\r\n      totalVolume: 0,\r\n      temperature: null,\r\n      time: null\r\n    };\r\n\r\n    // Helper to finalize a block and start a new one\r\n    const finalizeBlock = (thermostatId, temperature, time) => {\r\n      if (currentBlock.droplets.length > 0) {\r\n        // Add volumeToFurthestNode to the surfixVolume of the last droplet in the block\r\n        const lastDroplet = currentBlock.droplets[currentBlock.droplets.length - 1];\r\n        const surfixParam = lastDroplet.parameters.find(p => p.name === 'surfixVolume');\r\n        if (surfixParam) {\r\n          surfixParam.value = Math.max(volumeToFurthestNode, surfixParam.value);\r\n        } else {\r\n          lastDroplet.parameters.push({\r\n            name: 'surfixVolume',\r\n            value: volumeToFurthestNode\r\n          });\r\n        }\r\n        \r\n        blocks.push({ ...currentBlock });\r\n      }\r\n      currentBlock = {\r\n        droplets: [],\r\n        thermostatId: thermostatId,\r\n        totalVolume: 0,\r\n        temperature: temperature,\r\n        time: time\r\n      };\r\n    };\r\n\r\n    // Process droplets in order\r\n    for (let i = 0; i < droplets.length; i++) {\r\n      const droplet = droplets[i];\r\n      const temperature = droplet.parameters.find(p => p.name === 'temperature')?.value;\r\n      const time = droplet.parameters.find(p => p.name === 'time')?.value;\r\n\r\n      // Start new block if temperature or time changes, or if volume limit exceeded\r\n      const relevantVolume = thermostatVolumes.find(tv => \r\n        tv.startThermostatId === currentBlock.thermostatId || \r\n        tv.endThermostatId === currentBlock.thermostatId\r\n      );\r\n\r\n      let dropletVolume = droplet.parameters.find(p => p.name === 'volume')?.value;\r\n      dropletVolume += droplet.parameters.find(p => p.name === 'prefixVolume')?.value;\r\n      \r\n\r\n      if (\r\n        currentBlock.temperature !== temperature ||\r\n        currentBlock.time !== time ||\r\n        (relevantVolume && currentBlock.totalVolume + dropletVolume > relevantVolume.volume)\r\n      ) {\r\n        finalizeBlock(thermostatVolumes[0].endThermostatId, temperature, time);\r\n      }\r\n      dropletVolume += droplet.parameters.find(p => p.name === 'surfixVolume')?.value;\r\n      // Add droplet to current block\r\n      currentBlock.droplets.push(droplet);\r\n      currentBlock.totalVolume += dropletVolume;\r\n      currentBlock.temperature = temperature;\r\n      currentBlock.time = time;\r\n    }\r\n\r\n    // Finalize last block\r\n    finalizeBlock(null, null, null);\r\n\r\n    return blocks;\r\n  };\r\n\r\n  function printDropletFrontPositionsAndSpeeds(droplets) {\r\n    droplets.forEach(droplet => {\r\n      console.log(`Droplet ID: ${droplet.id}, Front Volumetric Position: ${droplet.frontVolumetricPosition}, Front time to next node  : ${droplet.frontTimeToReachNextNode}, Front Volumetric Distance to next node: ${droplet.frontVolumetricDistanceToNextNode}, Rear Volumetric Position: ${droplet.rearVolumetricPosition}, Rear time to next node: ${droplet.rearTimeToReachNextNode}, Rear Volumetric Distance to next node: ${droplet.rearVolumetricDistanceToNextNode}, frontNextNodeID: ${droplet.frontNextNodeID}, rearNextNodeID: ${droplet.rearNextNodeID}`);\r\n    });\r\n  }\r\n\r\n  const extractPumpEvents = (eventList) => {\r\n    // eventList is now an array of arrays, where each inner array contains events for a specific pump\r\n    return eventList\r\n      .flat() // Flatten the array of arrays\r\n      .filter(event => event.type === 'setPumpSpeed')\r\n      .sort((a, b) => a.time - b.time);\r\n  };\r\n\r\n  const extractDetectorEvents = (eventList) => {\r\n    // Extract detector/spectrometer measurement events\r\n    return eventList\r\n      .flat() // Flatten the array of arrays\r\n      .filter(event => event.type === 'setDetectorMeasurement')\r\n      .sort((a, b) => a.time - b.time);\r\n  };\r\n\r\n  const getDetectorEventsAtTime = (detectorId, detectorEvents, currentTime) => {\r\n    return detectorEvents.filter(event => \r\n      event.target === detectorId && \r\n      Math.abs(event.time - currentTime) < 0.1 // Within 0.1 second tolerance\r\n    );\r\n  };\r\n\r\n  const recalculateEventListForDevices = (eventList) => {\r\n    const deviceEventMap = new Map();\r\n\r\n    const convertPumpEvent = (event, deviceProperties) => {\r\n      // Find properties by name from the properties array\r\n      const syringeDiameter = deviceProperties.find(p => p.name === 'diameter')?.default || 0;\r\n      const syringeLength = deviceProperties.find(p => p.name === 'length')?.default || 0;\r\n      const stepsPerRevolution = deviceProperties.find(p => p.name === 'steps per revolution')?.default || 0;\r\n      const lead = deviceProperties.find(p => p.name === 'lead')?.default || 0;\r\n\r\n      const syringeArea = Math.PI * Math.pow(syringeDiameter / 2, 2);\r\n      const linearSpeed = Math.abs(event.value) / syringeArea;\r\n      const stepsPerMm = stepsPerRevolution / lead;\r\n      const stepsPerSecond = linearSpeed * stepsPerMm;\r\n      const delayMicroseconds = stepsPerSecond > 0 ? \r\n        Math.round(1000000 / stepsPerSecond) : \r\n        0;\r\n\r\n      return {\r\n        target: event.target,\r\n        time: Math.round(event.time * 1000000),\r\n        delay: delayMicroseconds\r\n      };\r\n    };\r\n\r\n    const convertThermostatEvent = (event, deviceProperties) => {\r\n      // Placeholder for thermostat conversion logic\r\n      return {\r\n        target: event.target,\r\n        time: Math.round(event.time * 1000000),\r\n        temperature: event.value,\r\n        // Add other thermostat-specific parameters here\r\n      };\r\n    };\r\n\r\n    const convertLedEvent = (event, deviceProperties) => {\r\n      // Placeholder for LED conversion logic\r\n      return {\r\n        target: event.target,\r\n        time: Math.round(event.time * 1000000),\r\n        intensity: event.value,\r\n        // Add other LED-specific parameters here\r\n      };\r\n    };\r\n\r\n    const convertDetectorEvent = (event, deviceProperties) => {\r\n      // Placeholder for detector conversion logic\r\n      return {\r\n        target: event.target,\r\n        time: Math.round(event.time * 1000000),\r\n        setting: event.value,\r\n        // Add other detector-specific parameters here\r\n      };\r\n    };\r\n\r\n    eventList.forEach(deviceEventList => {\r\n      if (!deviceEventList.length) return;\r\n\r\n      const targetId = deviceEventList[0].target;\r\n      const deviceNode = nodes.find(node => node.id === targetId);\r\n      \r\n      if (!deviceNode || !deviceNode.data) {\r\n        console.error(`Device node or data not found for ID: ${targetId}`);\r\n        return;\r\n      }\r\n\r\n      const deviceEvents = deviceEventList.map(event => {\r\n        switch (event.type) {\r\n          case 'setPumpSpeed':\r\n            return convertPumpEvent(event, deviceNode.data.properties);\r\n          \r\n          case 'setThermostatTemperature':\r\n            return convertThermostatEvent(event, deviceNode.data.properties);\r\n          \r\n          case 'setLedIntensity':\r\n            return convertLedEvent(event, deviceNode.data.properties);\r\n          \r\n          case 'setDetectorSetting':\r\n            return convertDetectorEvent(event, deviceNode.data.properties);\r\n          \r\n          default:\r\n            console.warn(`Unknown event type: ${event.type}`);\r\n            return null;\r\n        }\r\n      }).filter(Boolean); // Remove any null events\r\n\r\n      if (deviceEvents.length > 0) {\r\n        deviceEventMap.set(targetId, deviceEvents);\r\n      }\r\n    });\r\n    console.log('deviceEventMap: ', Array.from(deviceEventMap.values()));\r\n    return Array.from(deviceEventMap.values());\r\n  };\r\n\r\n  const generateEventList = (blocks) => {\r\n    // Early exit if blocks array is invalid\r\n    if (!blocks || !Array.isArray(blocks) || blocks.length === 0) {\r\n      console.warn('No valid blocks found for event generation');\r\n      return [];\r\n    }\r\n\r\n    const orderedNodes = orderNodesByDistance(findOutletNode(graphData.nodes), graphData.nodes, graphData.links);\r\n    console.log('orderedNodes: ', orderedNodes);\r\n    \r\n    // Early exit if no ordered nodes\r\n    if (!orderedNodes || orderedNodes.length === 0) {\r\n      console.warn('No ordered nodes found for event generation');\r\n      return [];\r\n    }\r\n    \r\n    let eventList = [];\r\n    let dropletSnapshot = [];\r\n    \r\n    // Validate block droplets\r\n    if (!blocks[0] || !blocks[0].droplets || !Array.isArray(blocks[0].droplets) || blocks[0].droplets.length === 0) {\r\n      console.warn('No valid droplets found in blocks for event generation');\r\n      return [];\r\n    }\r\n    \r\n    const i = 0;\r\n    const currentBlockDroplets = blocks[i].droplets;\r\n    \r\n    // Add fallback for volumetricSpeed in case it's not found\r\n    const dropletWithParams = currentBlockDroplets.find(d => d && d.parameters && Array.isArray(d.parameters));\r\n    if (!dropletWithParams) {\r\n      console.warn('No droplet with valid parameters found');\r\n      return [];\r\n    }\r\n    \r\n    // Make sure we can find the volumetricSpeed parameter or use a default\r\n    const volumetricSpeedParam = dropletWithParams.parameters.find(p => p && p.name === 'volumetricSpeed');\r\n    const commonVolumetricSpeed = volumetricSpeedParam?.value || 1;\r\n    console.log('Using volumetricSpeed:', commonVolumetricSpeed);\r\n    \r\n    //adds some parameters to nodes\r\n    orderedNodes.forEach(node => {\r\n      node.inletVolumetricSpeed = commonVolumetricSpeed;\r\n      node.outletVolumetricSpeed = commonVolumetricSpeed;\r\n      const pump = findConnectedPump(node.node.id, graphData.nodes, graphData.links);\r\n      if (pump) {\r\n        node.connectedPump = pump;\r\n      }\r\n      else {\r\n        node.connectedPump = 0;\r\n      }\r\n      node.connectedPumpRatio = 0;\r\n      node.connectedPumpSpeedAtPause = 0;\r\n      node.pumpSpeedMultiplier = 1;\r\n      //node.requestedRatio = 0;\r\n      node.pauseLevel = 0;\r\n\r\n    });\r\n    //ustawia carrier pump na odpowiednią predkość\r\n    const carrierPumpConnector = graphData.links.find(link => link.source === selectedCarrierPumps[0]).target;\r\n    if (carrierPumpConnector) {\r\n      const connectorNode = orderedNodes.find(node => node.node.id === carrierPumpConnector);\r\n      connectorNode.inletVolumetricSpeed = commonVolumetricSpeed;\r\n      connectorNode.outletVolumetricSpeed = commonVolumetricSpeed;\r\n      connectorNode.connectedPump = graphData.nodes.find(node => node.id === selectedCarrierPumps[0]);\r\n      connectorNode.connectedPumpRatio = 1;\r\n      connectorNode.connectedPumpSpeedAtPause = commonVolumetricSpeed;\r\n      //connectorNode.requestedRatio = 0;\r\n      connectorNode.pauseLevel = 0;\r\n    }\r\n    let event = { //it is ok\r\n      type: 'setPumpSpeed',\r\n      target: selectedCarrierPumps[0],\r\n      time: 0,\r\n      value: commonVolumetricSpeed\r\n    };\r\n    eventList.push(event);\r\n\r\n    orderedNodes.filter(node => node.node.type === 'pump' && node.node.id !== selectedCarrierPumps[0]).forEach(pump => {\r\n      event = {//it is ok\r\n        type: 'setPumpSpeed',\r\n        target: pump.node.id,\r\n        time: 0,\r\n        value: 0\r\n      };\r\n      eventList.push(event);\r\n      \r\n    });\r\n\r\n    \r\n    let position = -0.001;\r\n    //prepares all droplets in block and calculates some parameters\r\n    currentBlockDroplets.forEach(droplet => {\r\n      const prefixVolume = droplet.parameters.find(p => p.name === 'prefixVolume')?.value;\r\n      const surfixVolume = droplet.parameters.find(p => p.name === 'surfixVolume')?.value;\r\n\r\n      droplet.frontVolumetricSpeed = commonVolumetricSpeed;\r\n      droplet.rearVolumetricSpeed = commonVolumetricSpeed;\r\n      droplet.frontVolumetricPosition = position - prefixVolume;\r\n      droplet.rearVolumetricPosition = droplet.frontVolumetricPosition;\r\n      droplet.frontVolumetricDistanceToNextNode = Math.abs(droplet.frontVolumetricPosition);\r\n      droplet.rearVolumetricDistanceToNextNode = Math.abs(droplet.rearVolumetricPosition); \r\n      droplet.frontTimeToReachNextNode = 0;\r\n      droplet.rearTimeToReachNextNode = 0;\r\n      droplet.frontNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\r\n      droplet.rearNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\r\n      droplet.pumpSpeedMultiplier = 1;\r\n      droplet.pauseLevel = 0;\r\n      droplet.frontVolumetricSpeedAtPause = 0;\r\n      droplet.rearVolumetricSpeedAtPause = 0;\r\n      droplet.stoppingDroplet = false;\r\n      droplet.initialPumping = false;\r\n\r\n      position -= ( prefixVolume + surfixVolume);\r\n    });\r\n    console.log('findFurthestNode: ', findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id);\r\n    console.log('Droplet positions initialized, nodes ready');\r\n\r\n    let lastDropletRearPosition = currentBlockDroplets[currentBlockDroplets.length - 1].rearVolumetricPosition;\r\n    let outletNodePosition = orderedNodes[0].node.volumetricPosition; \r\n    let timePassed = 0; //in s\r\n    let newTimePassed = 0;\r\n\r\n    // Simulate the movement of droplets in the current block\r\n    currentBlockDroplets.forEach(droplet => {\r\n      droplet.frontTimeToReachNextNode = Math.abs(droplet.frontVolumetricDistanceToNextNode / droplet.frontVolumetricSpeed);\r\n      droplet.rearTimeToReachNextNode = Math.abs(droplet.rearVolumetricDistanceToNextNode / droplet.rearVolumetricSpeed);\r\n    });\r\n\r\n    while (lastDropletRearPosition < outletNodePosition) {\r\n      \r\n      let smallestFrontTime = Infinity;\r\n      let smallestRearTime = Infinity;\r\n      let smallestFrontTimeDroplet = [];\r\n      let smallestRearTimeDroplet = [];\r\n\r\n      currentBlockDroplets.forEach(droplet => {// Update the smallest front and rear times and associated droplet(s) based on the current droplet's front and rear times to reach the next node.\r\n        \r\n        if (Math.abs(droplet.frontTimeToReachNextNode) < smallestFrontTime) {\r\n          smallestFrontTime = Math.abs(droplet.frontTimeToReachNextNode);\r\n          smallestFrontTimeDroplet = [droplet];\r\n        }\r\n        else if (Math.abs(droplet.frontTimeToReachNextNode) === smallestFrontTime) {\r\n          smallestFrontTimeDroplet.push(droplet);\r\n        }\r\n        if (Math.abs(droplet.rearTimeToReachNextNode) < smallestRearTime) {\r\n          smallestRearTime = Math.abs(droplet.rearTimeToReachNextNode);\r\n          smallestRearTimeDroplet = [droplet];\r\n        }\r\n        else if (Math.abs(droplet.rearTimeToReachNextNode) === smallestRearTime) {\r\n          smallestRearTimeDroplet.push(droplet);\r\n        }\r\n      });\r\n\r\n      newTimePassed += Math.min(Math.abs(smallestFrontTime), Math.abs(smallestRearTime));\r\n\r\n      if (smallestFrontTime === smallestRearTime) {//przypadek w ktorym wiele kropel ma ten sam czas do przejścia do nastepnego noda, rzadki\r\n        \r\n        if (smallestFrontTimeDroplet.length > 1 || smallestRearTimeDroplet.length > 1) {//sprawdź czy wśród nich jest kropla z rear i front\r\n          console.log('Multiple droplets have reached the next node simultaneously');\r\n          console.log('smallestFrontTimeDroplet: ', smallestFrontTimeDroplet);\r\n          console.log('smallestRearTimeDroplet: ', smallestRearTimeDroplet);\r\n          \r\n        }\r\n        else if (smallestFrontTimeDroplet[0] === smallestRearTimeDroplet[0]) {//przypadek gdy kropla ma 0 objętości\r\n          console.log('Both front and rear times are for the same droplet');\r\n          const reachedNode = orderedNodes.find(n => n.node.id === smallestFrontTimeDroplet[0].frontNextNodeID);\r\n          const reachedNodeDistance = orderedNodes.find(node => node.node.id === reachedNode.node.id).distance;\r\n          if (reachedNode.node.type === 'connector') {\r\n\r\n\r\n            const index = currentBlockDroplets.indexOf(smallestFrontTimeDroplet[0]);\r\n            const dropletsOlder = currentBlockDroplets.slice(0, index);\r\n            const dropletsNewer = currentBlockDroplets.slice(index + 1);\r\n\r\n            const ds = [];\r\n            ds.drops = JSON.parse(JSON.stringify(dropletsNewer)); // Create deep copy\r\n            ds.snappedNode = smallestFrontTimeDroplet[0].frontNextNodeID;\r\n            const existingSnapshotIndex = dropletSnapshot.findIndex(snapshot => snapshot.snappedNode === ds.snappedNode);\r\n            if (existingSnapshotIndex !== -1) {\r\n              dropletSnapshot[existingSnapshotIndex] = ds;\r\n            } else {\r\n              dropletSnapshot.push(ds);\r\n            }\r\n\r\n            //aktualizuje starsze krople\r\n            dropletsOlder.forEach(droplet => {\r\n              droplet.frontTimeToReachNextNode -= smallestFrontTime;\r\n              droplet.rearTimeToReachNextNode -= smallestFrontTime;\r\n              droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n              droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n              droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n              droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n            });\r\n\r\n            //aktualizuje kroplę\r\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n            const nextEdge = graphData.links.find(link => link.source === smallestFrontTimeDroplet[0].frontNextNodeID && link.target === nextNode.node.id);\r\n\r\n            if (reachedNode.connectedPump !== null){\r\n              const pumpRatio = smallestFrontTimeDroplet[0].parameters.find(param => param.nodeId === reachedNode.connectedPump.id && param.name === 'ratio')?.value || 0;\r\n              const dropletDesiredVolume = smallestFrontTimeDroplet[0].parameters.find(param => param.name === 'volume')?.value || 0;\r\n              \r\n              reachedNode.connectedPumpRatio = pumpRatio;\r\n              //reachedNode.inletVolumetricSpeed = 0;\r\n              //smallestFrontTimeDroplet[0].frontVolumetricSpeed = reachedNode.outletVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].frontVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].rearVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].rearVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].rearVolumetricSpeed = 0;\r\n              smallestFrontTimeDroplet[0].frontVolumetricPosition = reachedNode.node.volumetricPosition;\r\n              smallestFrontTimeDroplet[0].rearVolumetricPosition = reachedNode.node.volumetricPosition;\r\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n              smallestFrontTimeDroplet[0].rearVolumetricDistanceToNextNode = 0; \r\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode/smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].rearTimeToReachNextNode = dropletDesiredVolume*pumpRatio/smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\r\n              //smallestFrontTimeDroplet[0].rearNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\r\n              smallestFrontTimeDroplet[0].pumpSpeedMultiplier = 1;\r\n              //smallestFrontTimeDroplet[0].pauseLevel = 0;\r\n              smallestFrontTimeDroplet[0].stoppingDroplet = true;\r\n              smallestFrontTimeDroplet[0].initialPumping = true;\r\n              if (reachedNode.connectedPump.id !==selectedCarrierPumps[0]) {\r\n                event={\r\n                  type: 'setPumpSpeed',\r\n                  target: reachedNode.connectedPump.id,\r\n                  time: newTimePassed,\r\n                  value: smallestFrontTimeDroplet[0].frontVolumetricSpeed\r\n                };\r\n                eventList.push(event);\r\n              }\r\n\r\n              //update newer droplets\r\n              dropletsNewer.forEach(droplet => {\r\n                droplet.pauseLevel += 1;\r\n                if (droplet.pauseLevel===1){\r\n                  droplet.frontVolumetricSpeedAtPause = droplet.frontVolumetricSpeed;\r\n                  if (droplet.stoppingDroplet !== true){\r\n                    droplet.rearVolumetricSpeedAtPause = droplet.rearVolumetricSpeed;\r\n                  }\r\n                }\r\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricSpeed = 0;\r\n                droplet.rearVolumetricSpeed = 0;\r\n                droplet.frontTimeToReachNextNode += smallestFrontTimeDroplet[0].rearTimeToReachNextNode-smallestFrontTime;\r\n                droplet.rearTimeToReachNextNode += smallestFrontTimeDroplet[0].rearTimeToReachNextNode-smallestFrontTime;\r\n              });\r\n              getPumpsBetweenPositions(smallestFrontTimeDroplet[0].frontVolumetricPosition,-1, graphData.nodes, graphData.links).filter(pump => pump.id !== reachedNode.connectedPump.id, ).forEach(pump => {\r\n                \r\n                event={\r\n                  type: 'setPumpSpeed',\r\n                  target: pump.id,\r\n                  time: newTimePassed,\r\n                  value: 0\r\n                };\r\n                eventList.push(event);\r\n              });\r\n            }\r\n            \r\n          }\r\n          else if (reachedNode.type === 'thermostat' || reachedNode.type === 'LED') {\r\n            console.log('reachedNode is thermostat');\r\n          }\r\n          else if (reachedNode.type === 'outlet') {\r\n            console.log('reachedNode is outlet');\r\n          }\r\n          else if (reachedNode.type === 'detector' || reachedNode.type === 'USBSpectrometer' || reachedNode.type === 'MQTTSpectrometer') {\r\n            console.log('reachedNode is detector');\r\n          }\r\n        } \r\n        else {\r\n          console.log('Front and rear times are for different droplets');\r\n        }\r\n      } \r\n\r\n      else if (smallestFrontTime < smallestRearTime) { //przypadek gdzie przód jest przed tyłem\r\n        console.log('Front time is smaller than rear time');\r\n        if (smallestFrontTimeDroplet.length > 1) {\r\n          console.log(`Multiple droplets have reached the next node simultaneously`);\r\n          smallestFrontTimeDroplet.forEach(droplet => {\r\n            // Perform some action for each droplet in smallestFrontTimeDroplet\r\n          });\r\n        }\r\n        else { //przypadek gdy przód jednej kropelki dochodzi do noda\r\n          console.log(`Single droplet front has reached the next node`);\r\n          const reachedNode = orderedNodes.find(n => n.node.id === smallestFrontTimeDroplet[0].frontNextNodeID);\r\n          const reachedNodeDistance = orderedNodes.find(node => node.node.id === reachedNode.node.id).distance;\r\n\r\n          if (reachedNode.node.type === 'connector') { //przypadek gdy dochodzi do connectora\r\n            console.log('reachedNode is connector');\r\n\r\n            const index = currentBlockDroplets.indexOf(smallestFrontTimeDroplet[0]);\r\n            const dropletsOlder = currentBlockDroplets.slice(0, index);\r\n            const dropletsNewer = currentBlockDroplets.slice(index + 1);\r\n\r\n            //aktualizuje kroplę\r\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n            const nextEdge = graphData.links.find(link => link.source === reachedNode.node.id && link.target === nextNode.node.id);\r\n\r\n            if (reachedNode.connectedPump.id !== null){\r\n\r\n              const pumpRatio = smallestFrontTimeDroplet[0].parameters.find(param => param.nodeId === reachedNode.connectedPump.id && param.name === 'ratio')?.value || 0;\r\n              const dropletDesiredVolume = smallestFrontTimeDroplet[0].parameters.find(param => param.name === 'volume')?.value || 0;\r\n              smallestFrontTimeDroplet[0].frontVolumetricPosition = reachedNode.node.volumetricPosition;\r\n              smallestFrontTimeDroplet[0].rearVolumetricPosition += smallestFrontTime * smallestFrontTimeDroplet[0].rearVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].actualVolume =smallestFrontTimeDroplet[0].frontVolumetricPosition-smallestFrontTimeDroplet[0].rearVolumetricPosition;\r\n              reachedNode.inletVolumetricSpeed = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              reachedNode.connectedPumpRatio = pumpRatio;\r\n              smallestFrontTimeDroplet[0].rearTimeToReachNextNode -= smallestFrontTime;\r\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n              smallestFrontTimeDroplet[0].rearVolumetricDistanceToNextNode -= smallestFrontTime * smallestFrontTimeDroplet[0].rearVolumetricSpeed; \r\n\r\n              if (smallestFrontTimeDroplet[0].initialPumping === true){ //przypadek gdy kropla jest w pierwszej fazie pompowania (od 0uL)\r\n                console.log('Kropla jest w pierwszej fazie pompowania');\r\n                //smallestFrontTimeDroplet[0].initialPumping = false;\r\n                const rearTimeLeft = smallestFrontTimeDroplet[0].rearTimeToReachNextNode;\r\n                const totalTimeLeft = rearTimeLeft + smallestFrontTimeDroplet[0].actualVolume/commonVolumetricSpeed;\r\n                console.log('commonVolumetricSpeed: ', commonVolumetricSpeed);\r\n                console.log('smallestFrontTimeDroplet[0].actualVolume: ', smallestFrontTimeDroplet[0].actualVolume);\r\n                console.log('rearTimeLeft: ', rearTimeLeft);\r\n                console.log('totalTimeLeft: ', totalTimeLeft);\r\n                const thispumpspeed = pumpRatio*dropletDesiredVolume/totalTimeLeft;\r\n                console.log('thispumpspeed: ', thispumpspeed);\r\n                reachedNode.connectedPumpSpeedAtPause = thispumpspeed;\r\n              }\r\n\r\n              else {\r\n                console.log('Normalne pompowanie');\r\n                reachedNode.connectedPumpSpeedAtPause = (dropletDesiredVolume*pumpRatio) / (smallestFrontTimeDroplet[0].actualVolume / reachedNode.inletVolumetricSpeed);\r\n              }\r\n\r\n              reachedNode.outletVolumetricSpeed = reachedNode.inletVolumetricSpeed+reachedNode.connectedPumpSpeedAtPause;\r\n              smallestFrontTimeDroplet[0].frontVolumetricSpeed += reachedNode.connectedPumpSpeedAtPause;\r\n              //smallestFrontTimeDroplet[0].rearVolumetricSpeed = 0;\r\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode/smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\r\n              //smallestFrontTimeDroplet[0].rearNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\r\n              //smallestFrontTimeDroplet[0].pumpSpeedMultiplier = 1;\r\n              //smallestFrontTimeDroplet[0].pauseLevel = 0;\r\n              //smallestFrontTimeDroplet[0].frontVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              //smallestFrontTimeDroplet[0].rearVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              //smallestFrontTimeDroplet[0].stoppingDroplet = true;\r\n              event={\r\n                type: 'setPumpSpeed',\r\n                target: reachedNode.connectedPump.id,\r\n                time: newTimePassed,\r\n                value: reachedNode.connectedPumpSpeedAtPause \r\n              };\r\n              eventList.push(event);\r\n              //update newer droplets\r\n              dropletsNewer.forEach(droplet => {\r\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontTimeToReachNextNode -= smallestFrontTime;\r\n                droplet.rearTimeToReachNextNode -= smallestFrontTime;\r\n              });\r\n              //aktualizuje starsze krople\r\n              let accumulatedSpeed = reachedNode.connectedPumpSpeedAtPause;\r\n              dropletsOlder.reverse().forEach(droplet => {\r\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.rearVolumetricSpeed += accumulatedSpeed; \r\n                getPumpsBetweenPositions(droplet.frontVolumetricPosition,droplet.rearVolumetricPosition, graphData.nodes, graphData.links).forEach(pump => {\r\n                  const editedNode = orderedNodes.find(node => node.connectedPump.id === pump.id);\r\n                  //editedNode.pumpSpeedMultiplier = 1;\r\n                  const pumpBoost = editedNode.connectedPumpSpeedAtPause * accumulatedSpeed/editedNode.inletVolumetricSpeed;\r\n                  editedNode.connectedPumpSpeedAtPause += pumpBoost;\r\n                  editedNode.inletVolumetricSpeed += accumulatedSpeed;\r\n                  accumulatedSpeed += pumpBoost;\r\n                  editedNode.outletVolumetricSpeed += accumulatedSpeed;\r\n                  event={\r\n                    type: 'setPumpSpeed',\r\n                    target: pump.id,\r\n                    time: newTimePassed,\r\n                    value: editedNode.connectedPumpSpeedAtPause\r\n                  };\r\n                  eventList.push(event);\r\n                });\r\n                droplet.frontVolumetricSpeed += accumulatedSpeed;\r\n                droplet.frontTimeToReachNextNode = droplet.frontVolumetricDistanceToNextNode/droplet.frontVolumetricSpeed;\r\n                droplet.rearTimeToReachNextNode = droplet.rearVolumetricDistanceToNextNode/droplet.rearVolumetricSpeed;\r\n\r\n              });\r\n            }\r\n          }\r\n          else if (reachedNode.node.type === 'thermostat' || reachedNode.type === 'LED') {//przypadek gdy dochodzi do termostatu\r\n            console.log('reachedNode (thermostat, LED): ', reachedNode);\r\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n            if (nextNode) {\r\n              const nextEdge = graphData.links.find(link => link.source === smallestFrontTimeDroplet[0].frontNextNodeID && link.target === nextNode.node.id);\r\n              //aktualizuje krople\r\n              currentBlockDroplets.forEach(droplet => {\r\n                droplet.frontTimeToReachNextNode -= smallestFrontTime;\r\n                droplet.rearTimeToReachNextNode -= smallestFrontTime;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n              });\r\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\r\n            }\r\n          }\r\n          else if (reachedNode.node.type === 'outlet') { //jeśli ostatni node osiągnięty\r\n            console.log('reachedNode (outlet): ', reachedNode);\r\n            //typowe zaktualizowanie czasu do następnego noda dla reszty kropel i zestallowanie frontu\r\n            currentBlockDroplets.forEach(droplet => {\r\n              droplet.frontTimeToReachNextNode -= smallestFrontTime;\r\n              droplet.rearTimeToReachNextNode -= smallestFrontTime;\r\n              droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n              droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n              droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n              droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n            });\r\n            smallestFrontTimeDroplet[0].frontTimeToReachNextNode = Infinity;\r\n            smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = Infinity;\r\n            smallestFrontTimeDroplet[0].frontNextNodeID = null;\r\n          }\r\n          else if (reachedNode.node.type === 'detector' || reachedNode.node.type === 'USBSpectrometer' || reachedNode.node.type === 'MQTTSpectrometer') { //przypadek gdy dochodzi do detektora\r\n            console.log('reachedNode (detector): ', reachedNode);\r\n            \r\n            // Create detector measurement end event when droplet rear reaches detector\r\n            const detectorEndEvent = {\r\n              type: 'setDetectorMeasurement',\r\n              target: reachedNode.node.id,\r\n              time: newTimePassed,\r\n              dropletId: smallestRearTimeDroplet[0].id,\r\n              eventSubtype: 'dropletRearPassed',\r\n              dropletData: {\r\n                volume: smallestRearTimeDroplet[0].parameters.find(p => p.name === 'volume')?.value || 0,\r\n                frontVolumetricPosition: smallestRearTimeDroplet[0].frontVolumetricPosition,\r\n                rearVolumetricPosition: smallestRearTimeDroplet[0].rearVolumetricPosition,\r\n                rearVolumetricSpeed: smallestRearTimeDroplet[0].rearVolumetricSpeed,\r\n                parameters: smallestRearTimeDroplet[0].parameters\r\n              }\r\n            };\r\n            eventList.push(detectorEndEvent);\r\n            \r\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n            if (nextNode) {\r\n              const nextEdge = graphData.links.find(link => link.source === smallestFrontTimeDroplet[0].frontNextNodeID && link.target === nextNode.node.id);\r\n              //aktualizuje krople\r\n              currentBlockDroplets.forEach(droplet => {\r\n                droplet.frontTimeToReachNextNode -= smallestFrontTime;\r\n                droplet.rearTimeToReachNextNode -= smallestFrontTime;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n              });\r\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\r\n            }\r\n          }\r\n        }\r\n      } \r\n      \r\n      else {//przypadek gdzie tył jest przed przodem\r\n        console.log('Rear time is smaller than front time');\r\n        if (smallestRearTimeDroplet.length > 1) { //przypadek gdy dochodzi do noda wiele kropel\r\n          console.log(`Multiple droplets ends have reached the next node simultaneously`);\r\n          smallestRearTimeDroplet.forEach(droplet => {\r\n            // Perform some action for each droplet in smallestRearTimeDroplet\r\n          });\r\n        } \r\n        else { //przypadek gdy tył jednej kropelki dochodzi do noda\r\n          const reachedNode = orderedNodes.find(n => n.node.id === smallestRearTimeDroplet[0].rearNextNodeID);\r\n          const reachedNodeDistance = orderedNodes.find(node => node.node.id === reachedNode.node.id).distance;\r\n          \r\n          if (reachedNode.node.type === 'connector') { //przypadek gdy dochodzi do connectora\r\n            console.log('reachedNode is connector');\r\n\r\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n            const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\r\n            const index = currentBlockDroplets.indexOf(smallestRearTimeDroplet[0]);\r\n            const dropletsOlder = currentBlockDroplets.slice(0, index);\r\n            const dropletsNewer = currentBlockDroplets.slice(index + 1);\r\n            if (smallestRearTimeDroplet[0].stoppingDroplet === true){ //wznawia jeśli była zatrzymana\r\n              //aktualizuje starsze krople\r\n              dropletsOlder.forEach(droplet => {\r\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n              });\r\n\r\n              //aktualizuje nowsze krople\r\n              dropletsNewer.forEach(droplet => {\r\n                if (droplet.pauseLevel === 1){//\r\n                  droplet.pauseLevel = 0;\r\n                  droplet.frontVolumetricSpeed = droplet.frontVolumetricSpeedAtPause;\r\n                  droplet.rearVolumetricSpeed = droplet.rearVolumetricSpeedAtPause;\r\n                  getPumpsBetweenPositions(droplet.frontVolumetricPosition,droplet.rearVolumetricPosition, graphData.nodes, graphData.links).forEach(pump => {\r\n                    \r\n                    event={\r\n                      type: 'setPumpSpeed',\r\n                      target: pump.id,\r\n                      time: newTimePassed,\r\n                      value: orderedNodes.find(node => node.node.id === pump.id).connectedPumpSpeedAtPause\r\n                    };\r\n                    eventList.push(event);\r\n                  });\r\n                }\r\n                else {\r\n                  droplet.pauseLevel -= 1;\r\n                }\r\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n              });\r\n\r\n              reachedNode.connectedPumpRatio = 0; \r\n              //reachedNode.inletVolumetricSpeed = 0;\r\n              //smallestRearTimeDroplet[0].frontVolumetricSpeed = reachedNode.outletVolumetricSpeed;\r\n              smallestRearTimeDroplet[0].rearVolumetricSpeed = smallestRearTimeDroplet[0].rearVolumetricSpeedAtPause;\r\n              smallestRearTimeDroplet[0].frontVolumetricPosition += smallestRearTimeDroplet[0].frontVolumetricSpeed*smallestRearTime;\r\n              smallestRearTimeDroplet[0].rearVolumetricPosition = reachedNode.node.volumetricPosition;\r\n              smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode -= smallestRearTimeDroplet[0].frontVolumetricSpeed*smallestRearTime;\r\n              smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge); \r\n              smallestRearTimeDroplet[0].frontTimeToReachNextNode = smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode/smallestRearTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode/smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n              //smallestRearTimeDroplet[0].frontNextNodeID = nextNode.id;\r\n              smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\r\n              //smallestRearTimeDroplet[0].pumpSpeedMultiplier = 1;\r\n              //smallestRearTimeDroplet[0].pauseLevel = 0;\r\n              smallestRearTimeDroplet[0].frontVolumetricSpeedAtPause = smallestRearTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestRearTimeDroplet[0].rearVolumetricSpeedAtPause = smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n              smallestRearTimeDroplet[0].stoppingDroplet = false;\r\n              smallestRearTimeDroplet[0].initialPumping = false;\r\n\r\n              reachedNode.connectedPumpRatio = 0;\r\n              event = {\r\n                type: 'setPumpSpeed',\r\n                target: reachedNode.connectedPump.id,\r\n                time: newTimePassed,\r\n                value: 0\r\n              };\r\n              eventList.push(event);\r\n              event = {\r\n                type: 'setPumpSpeed',\r\n                target: selectedCarrierPumps[0],\r\n                time: newTimePassed,\r\n                value: commonVolumetricSpeed\r\n              };\r\n              eventList.push(event);\r\n\r\n            }\r\n            else {\r\n              console.log('it is not stopper');\r\n              if (reachedNode.connectedPump.id !== null){\r\n                \r\n                const speedDifference = reachedNode.outletVolumetricSpeed - reachedNode.inletVolumetricSpeed;\r\n                //reachedNode.inletVolumetricSpeed = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n                reachedNode.outletVolumetricSpeed = reachedNode.inletVolumetricSpeed;\r\n                reachedNode.connectedPumpRatio = 0;\r\n                reachedNode.connectedPumpSpeedAtPause = 0;\r\n                smallestRearTimeDroplet[0].frontVolumetricPosition += smallestRearTime * smallestRearTimeDroplet[0].frontVolumetricSpeed;\r\n                smallestRearTimeDroplet[0].rearVolumetricPosition = reachedNode.node.volumetricPosition;\r\n                smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode -= smallestRearTime * smallestRearTimeDroplet[0].frontVolumetricSpeed;\r\n                smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge); \r\n                //smallestRearTimeDroplet[0].frontNextNodeID = nextNode.id;\r\n                smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\r\n                //smallestRearTimeDroplet[0].pumpSpeedMultiplier = 1;\r\n                //smallestRearTimeDroplet[0].pauseLevel = 0; \r\n                //smallestRearTimeDroplet[0].stoppingDroplet = true;\r\n                smallestRearTimeDroplet[0].frontVolumetricSpeed = smallestRearTimeDroplet[0].frontVolumetricSpeed-speedDifference;\r\n                //smallestRearTimeDroplet[0].rearVolumetricSpeed = 0;\r\n                smallestRearTimeDroplet[0].frontVolumetricSpeedAtPause = smallestRearTimeDroplet[0].frontVolumetricSpeed;\r\n                //smallestRearTimeDroplet[0].rearVolumetricSpeedAtPause = smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n                smallestRearTimeDroplet[0].frontTimeToReachNextNode = smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].frontVolumetricSpeed;\r\n                smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n                event={\r\n                  type: 'setPumpSpeed',\r\n                  target: reachedNode.connectedPump.id,\r\n                  time: newTimePassed,\r\n                  value: reachedNode.connectedPumpSpeedAtPause \r\n                };\r\n                eventList.push(event);\r\n                //updte newer droplets\r\n                dropletsNewer.forEach(droplet => {\r\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                  droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n                  droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n                });\r\n                //aktualizuje starsze krople\r\n                let accumulatedSpeedDecrease = speedDifference;\r\n                dropletsOlder.reverse().forEach(droplet => {\r\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                  droplet.rearVolumetricSpeed -= accumulatedSpeedDecrease;\r\n                  getPumpsBetweenPositions(droplet.frontVolumetricPosition,droplet.rearVolumetricPosition, graphData.nodes, graphData.links).forEach(pump => {\r\n                    const editedNode = orderedNodes.find(node => node.connectedPump.id === pump.id);\r\n                    const pumpBreak = editedNode.connectedPumpSpeedAtPause * accumulatedSpeedDecrease/editedNode.inletVolumetricSpeed;\r\n                    editedNode.connectedPumpSpeedAtPause -= pumpBreak;\r\n                    editedNode.inletVolumetricSpeed -= accumulatedSpeedDecrease;\r\n                    accumulatedSpeedDecrease += pumpBreak;\r\n                    editedNode.outletVolumetricSpeed -= accumulatedSpeedDecrease;\r\n                    event={\r\n                      type: 'setPumpSpeed',\r\n                      target: pump.id,\r\n                      time: newTimePassed,\r\n                      value: editedNode.connectedPumpSpeedAtPause\r\n                    };\r\n                    eventList.push(event);\r\n                  });\r\n                  droplet.frontVolumetricSpeed -= accumulatedSpeedDecrease;\r\n                  droplet.frontTimeToReachNextNode = droplet.frontVolumetricDistanceToNextNode/droplet.frontVolumetricSpeed;\r\n                  droplet.rearTimeToReachNextNode = droplet.rearVolumetricDistanceToNextNode/droplet.rearVolumetricSpeed;\r\n  \r\n                });\r\n              }\r\n            }\r\n\r\n          }\r\n          else if (reachedNode.node.type === 'thermostat' || reachedNode.node.type === 'LED') {//przypadek gdy dochodzi do termostatu\r\n            console.log('reachedNode thermostat: ', reachedNode);\r\n            \r\n            const isFarthestThermostatOrLED = orderedNodes.filter(node => node.node.type === 'thermostat' || node.node.type === 'LED').every(node => node.distance <= reachedNodeDistance);\r\n            \r\n            // This line checks if the smallestRearTimeDroplet is the last droplet in the currentBlockDroplets array.\r\n            if (isFarthestThermostatOrLED && currentBlockDroplets.length === currentBlockDroplets.indexOf(smallestRearTimeDroplet[0])+1) {\r\n              console.log('This is the farthest thermostat or LED node. Also, last droplet just passed through it.');\r\n              const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n              const waitTime = smallestRearTimeDroplet[0].parameters.find(param => param.nodeId === reachedNode.node.id && param.name === 'time')?.value || 0;\r\n              if (nextNode) {\r\n                const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\r\n                smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n                smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode/smallestRearTimeDroplet[0].rearVolumetricSpeed + smallestRearTime;\r\n                smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\r\n                //aktualizuje resztę kropli\r\n                currentBlockDroplets.forEach(droplet => {\r\n                  droplet.frontTimeToReachNextNode += waitTime - smallestRearTime;\r\n                  droplet.rearTimeToReachNextNode += waitTime - smallestRearTime;\r\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed-waitTime * droplet.frontVolumetricSpeed;//to jest zrobione na razie aby czas się zgadzał\r\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed-waitTime * droplet.rearVolumetricSpeed;\r\n                });\r\n\r\n                let carrierPumpEvent = {\r\n                  type: 'setPumpSpeed',\r\n                  target: selectedCarrierPumps[0], // Assuming 'carrierPumpId' is the ID of the carrier pump\r\n                  time: newTimePassed,\r\n                  value: 0\r\n                };\r\n                eventList.push(carrierPumpEvent);\r\n                carrierPumpEvent = {\r\n                  type: 'setPumpSpeed',\r\n                  target: selectedCarrierPumps[0], // Assuming 'carrierPumpId' is the ID of the carrier pump\r\n                  time: newTimePassed+waitTime,\r\n                  value: commonVolumetricSpeed\r\n                };\r\n                eventList.push(carrierPumpEvent);\r\n              }\r\n            }\r\n            else { //droplet wasnt the last one\r\n              console.log('smallestRearTimeDroplet is not the last droplet in the currentBlockDroplets array');\r\n              const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n              if (nextNode) {\r\n                const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\r\n                //aktualizuje krople\r\n                currentBlockDroplets.forEach(droplet => {\r\n                  droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n                  droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n                });\r\n                smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n                smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n                smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\r\n              }\r\n            }\r\n          }\r\n          else if (reachedNode.node.type === 'outlet') { //jeśli ostatni node osiągnięty\r\n            //typowe zaktualizowanie czasu do następnego noda dla reszty kropel i zestallowanie reara\r\n            //aktualizuje resztę kropli\r\n            currentBlockDroplets.forEach(droplet => {\r\n              droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n              droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n              droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n              droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n              droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n              droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n            });\r\n            smallestRearTimeDroplet[0].frontTimeToReachNextNode = Infinity;\r\n            smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode = Infinity;\r\n            smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = Infinity;\r\n            smallestRearTimeDroplet[0].rearNextNodeID = null;\r\n            smallestRearTimeDroplet[0].rearTimeToReachNextNode = Infinity;\r\n          }\r\n          else if (reachedNode.node.type === 'detector' || reachedNode.node.type === 'USBSpectrometer' || reachedNode.node.type === 'MQTTSpectrometer') { //przypadek gdy dochodzi do detektora\r\n            console.log('reachedNode (detector): ', reachedNode);\r\n            \r\n            // Create detector measurement end event when droplet rear reaches detector\r\n            const detectorEndEvent = {\r\n              type: 'setDetectorMeasurement',\r\n              target: reachedNode.node.id,\r\n              time: newTimePassed,\r\n              dropletId: smallestRearTimeDroplet[0].id,\r\n              eventSubtype: 'dropletRearPassed',\r\n              dropletData: {\r\n                volume: smallestRearTimeDroplet[0].parameters.find(p => p.name === 'volume')?.value || 0,\r\n                frontVolumetricPosition: smallestRearTimeDroplet[0].frontVolumetricPosition,\r\n                rearVolumetricPosition: smallestRearTimeDroplet[0].rearVolumetricPosition,\r\n                rearVolumetricSpeed: smallestRearTimeDroplet[0].rearVolumetricSpeed,\r\n                parameters: smallestRearTimeDroplet[0].parameters\r\n              }\r\n            };\r\n            eventList.push(detectorEndEvent);\r\n            \r\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n            if (nextNode) {\r\n              const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\r\n              //aktualizuje krople\r\n              currentBlockDroplets.forEach(droplet => {\r\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n              });\r\n              smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n              smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n              smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      timePassed = newTimePassed;\r\n      // Update last droplet rear position\r\n      lastDropletRearPosition = currentBlockDroplets[currentBlockDroplets.length - 1].rearVolumetricPosition;\r\n\r\n      //add code that preserves droplets positions and speeds for visualization\r\n      const dropletState = {\r\n        time: timePassed,\r\n        droplets: currentBlockDroplets.map(droplet => ({\r\n          id: droplet.id,\r\n          frontVolumetricPosition: droplet.frontVolumetricPosition,\r\n          rearVolumetricPosition: droplet.rearVolumetricPosition,\r\n          frontVolumetricSpeed: droplet.frontVolumetricSpeed,\r\n          rearVolumetricSpeed: droplet.rearVolumetricSpeed,\r\n          pumpSpeedMultiplier: droplet.pumpSpeedMultiplier,\r\n          frontTimeToReachNextNode: droplet.frontTimeToReachNextNode,\r\n          rearTimeToReachNextNode: droplet.rearTimeToReachNextNode,\r\n          frontVolumetricDistanceToNextNode: droplet.frontVolumetricDistanceToNextNode,\r\n          rearVolumetricDistanceToNextNode: droplet.rearVolumetricDistanceToNextNode,\r\n          volume: droplet.parameters.find(p => p.name === 'volume')?.value || 0,\r\n          frontNextNodeID: droplet.frontNextNodeID,\r\n          rearNextNodeID: droplet.rearNextNodeID\r\n        }))\r\n      };\r\n      setDropletHistory(prev => [...prev, dropletState]);\r\n\r\n      \r\n\r\n      //if (timePassed > 9999) {//here for testing, preventing infinite loop\r\n      //  lastDropletRearPosition = 88100;\r\n      //}\r\n\r\n    }\r\n    event = {//it is ok\r\n      type: 'setPumpSpeed',\r\n      target: selectedCarrierPumps[0],\r\n      time: timePassed,\r\n      value: 0\r\n    };\r\n    eventList.push(event);\r\n\r\n    eventList = cleanAndSortEventList(eventList);\r\n    console.log('dropletHistory in event generator: ', dropletHistory);\r\n    console.log('eventList: ', eventList.sort((a, b) => a.time - b.time));\r\n    setPumpEvents(extractPumpEvents(eventList));\r\n    setDetectorEvents(extractDetectorEvents(eventList));\r\n    console.log('Detector events:', extractDetectorEvents(eventList));\r\n    return eventList;\r\n  }\r\n  // First useEffect to set initial graphData\r\n  useEffect(() => {\r\n    setDropletHistory([]);\r\n    if (nodes.length > 0 && edges.length > 0) {\r\n      const graphNodes = nodes.map(node => ({\r\n        id: node.id,\r\n        label: node.data.label,\r\n        type: node.data.type,\r\n        x: 0,\r\n        y: 0,\r\n        volumetricPosition: 0\r\n      }));\r\n\r\n      const graphLinks = edges.map(edge => ({\r\n        source: edge.source,\r\n        target: edge.target,\r\n        length: edge.data?.properties?.length || 100,\r\n        diameter: edge.data?.properties?.diameter || 1,\r\n      }));\r\n\r\n      setGraphData({ nodes: graphNodes, links: graphLinks });\r\n    }\r\n    \r\n  }, [nodes, edges]);\r\n\r\n  // Second useEffect to calculate nodes positions and set up simulation data\r\n  useEffect(() => {\r\n    if (!graphData.nodes.length || !graphData.links.length || !droplets.length) {\r\n      console.log('Missing required data for simulation setup:', {\r\n        nodesLength: graphData.nodes.length,\r\n        linksLength: graphData.links.length,\r\n        dropletsLength: droplets.length\r\n      });\r\n      return;\r\n    }\r\n\r\n    const graphNodes = [...graphData.nodes];\r\n    \r\n    // Find outlet node first\r\n    const outletNode = findOutletNode(graphData.nodes);\r\n    if (!outletNode) {\r\n      console.error('No outlet node found. Cannot set up simulation.');\r\n      return;\r\n    }\r\n\r\n    // Get ordered nodes from outlet\r\n    const orderedNodes = orderNodesByDistance(outletNode, graphData.nodes, graphData.links);\r\n    \r\n    // Separate nodes into main line and secondary line\r\n    const mainLineNodes = orderedNodes\r\n      .filter(({node}) => \r\n        setOfMainLineNodes.includes(node.type))\r\n      .reverse();\r\n      \r\n    const secondaryLineNodes = orderedNodes\r\n      .filter(({node}) => setOfSecondaryLineNodes.includes(node.type))\r\n      .sort((a, b) => b.distance - a.distance);\r\n\r\n    // Position settings\r\n    const mainLineY = 300;\r\n    const secondaryLineY = 150;\r\n    const pumpSpacing = 100; // Increased horizontal spacing between pumps\r\n    let currentX = 100;\r\n\r\n    // Position main line nodes\r\n    let currentVolumetricPosition = 0;\r\n    mainLineNodes.forEach(({node}, index) => {\r\n      const graphNode = graphNodes.find(n => n.id === node.id);\r\n      if (!graphNode) return;\r\n\r\n      graphNode.x = currentX;\r\n      graphNode.y = mainLineY;\r\n      graphNode.volumetricPosition = currentVolumetricPosition;\r\n      \r\n      if (index < mainLineNodes.length - 1) {\r\n        const nextNode = mainLineNodes[index + 1];\r\n        const edge = graphData.links.find(e => \r\n          (e.source === graphNode.id && e.target === nextNode.node.id) ||\r\n          (e.target === graphNode.id && e.source === nextNode.node.id)\r\n        );\r\n        \r\n        if (edge && edge.length) {\r\n          currentX += edge.length * 2;\r\n          // Use existing calculateEdgeVolume function\r\n          const edgeVolume = calculateEdgeVolume(edge);\r\n          currentVolumetricPosition += edgeVolume;\r\n        } else {\r\n          currentX += 200;\r\n          currentVolumetricPosition += 150;\r\n        }\r\n      }\r\n    });\r\n\r\n    // Group secondary nodes by distance\r\n    const nodesByDistance = {};\r\n    secondaryLineNodes.forEach(({node, distance}) => {\r\n      if (!nodesByDistance[distance]) {\r\n        nodesByDistance[distance] = [];\r\n      }\r\n      nodesByDistance[distance].push(node);\r\n    });\r\n\r\n    // Position secondary nodes based on their connected main line nodes\r\n    const pumpOffset = 50; // Add this constant for pump spacing\r\n    Object.entries(nodesByDistance).forEach(([distance, nodes]) => {\r\n      nodes.forEach((node, index) => {\r\n        const graphNode = graphNodes.find(n => n.id === node.id);\r\n        if (!graphNode) return;\r\n\r\n        // Find connected main line node through edges\r\n        const connectedEdge = edges.find(e => \r\n          e.source === node.id || e.target === node.id\r\n        );\r\n        \r\n        if (connectedEdge) {\r\n          const connectedNodeId = connectedEdge.source === node.id ? connectedEdge.target : connectedEdge.source;\r\n          const connectedMainNode = graphNodes.find(n => n.id === connectedNodeId);\r\n          \r\n          if (connectedMainNode) {\r\n            // Position pump above its connected main line node with offset if needed\r\n            graphNode.x = connectedMainNode.x + (index * pumpOffset) - ((nodes.length - 1) * pumpOffset / 2);\r\n            graphNode.y = secondaryLineY;\r\n          }\r\n        }\r\n      });\r\n    });\r\n\r\n    setGraphData(prev => ({ ...prev, nodes: graphNodes }));\r\n    \r\n    // Only calculate volumes and blocks if not already done\r\n    if (currentBlockDroplets.length === 0) {\r\n      console.log('Calculating thermostat volumes and blocks for droplets:', droplets.length);\r\n      const thermoVol = calculateVolumesBetweenThermostats(graphData);\r\n      \r\n      // Create deep copy of droplets to avoid mutation issues\r\n      const dropletsCopy = JSON.parse(JSON.stringify(droplets));\r\n      const blocks = divideDropletsIntoBlocks(dropletsCopy, thermoVol);\r\n      \r\n      if (blocks.length > 0) {\r\n        setCurrentBlockDroplets(blocks[0].droplets);\r\n        // Generate event list only once when initializing\r\n        const eventList = generateEventList(blocks);\r\n        const eventListForDevices = recalculateEventListForDevices(eventList);\r\n      }\r\n    }\r\n    \r\n    // Important: the dependency array includes currentBlockDroplets.length to prevent infinite recalculations\r\n  }, [graphData.nodes.length, graphData.links.length, droplets, edges, currentBlockDroplets.length]);\r\n\r\n  const startSimulation = useCallback(() => {\r\n    setIsSimulationRunning(true);\r\n    lastFrameTimeRef.current = null; // Reset the last frame time\r\n  }, []);\r\n\r\n  const stopSimulation = useCallback(() => {\r\n    setIsSimulationRunning(false);\r\n    if (animationFrameRef.current) {\r\n      cancelAnimationFrame(animationFrameRef.current);\r\n      animationFrameRef.current = null;\r\n    }\r\n  }, []);\r\n\r\n  const restartSimulation = useCallback(() => {\r\n    stopSimulation();\r\n    setKey(prevKey => prevKey + 1);\r\n    setCurrentTime(0);\r\n    startSimulation();\r\n  }, [stopSimulation, startSimulation]);\r\n\r\n\r\n  const getNodeColor = (node) => {\r\n    switch (node.type) {\r\n      case 'pump': return '#4CAF50';\r\n      case 'connector': return '#2196F3';\r\n      case 'outlet': return '#F44336';\r\n      default: return '#FFA000'; // Default color for unknown types\r\n    }\r\n  };\r\n\r\n  // Update volumetricToXPosition function\r\n  const volumetricToXPosition = useCallback((volumetricPosition) => {\r\n    const outletNode = findOutletNode(graphData.nodes);\r\n    const furthestNode = findFurthestNode(outletNode, graphData.nodes, graphData.links);\r\n    \r\n    if (!outletNode || !furthestNode) return 0;\r\n\r\n    const totalVolume = getVolumeBetweenNodes(furthestNode.id, outletNode.id, graphData.nodes, graphData.links);\r\n    const outletX = graphData.nodes.find(n => n.id === outletNode.id)?.x || 0;\r\n    const furthestX = graphData.nodes.find(n => n.id === furthestNode.id)?.x || 0;\r\n    \r\n    // Handle edge cases\r\n    if (!totalVolume || totalVolume === 0 || isNaN(totalVolume)) {\r\n      console.warn('Total volume is invalid:', totalVolume);\r\n      return furthestX;\r\n    }\r\n\r\n    if (volumetricPosition === undefined || volumetricPosition === null || isNaN(volumetricPosition)) {\r\n      console.warn('Volumetric position is invalid:', volumetricPosition);\r\n      return furthestX;\r\n    }\r\n\r\n    // Clamp the position to valid range\r\n    const clampedPosition = Math.max(-totalVolume, Math.min(totalVolume, volumetricPosition));\r\n    \r\n    // Apply scaling factor to the position calculation\r\n    const scaledX = furthestX + ((clampedPosition / totalVolume) * (outletX - furthestX));\r\n    \r\n    // Ensure the returned value is a valid number\r\n    if (!isFinite(scaledX) || isNaN(scaledX)) {\r\n      console.warn('Invalid scaled position calculated:', {\r\n        scaledX,\r\n        clampedPosition,\r\n        totalVolume,\r\n        outletX,\r\n        furthestX\r\n      });\r\n      return furthestX;\r\n    }\r\n    \r\n    return scaledX;\r\n  }, [graphData.nodes]);    \r\n\r\n  // Update the updateDropletPositions function\r\n  const updateDropletPositions = useCallback((timestamp) => {\r\n    if (!isSimulationRunning || dropletHistory.length === 0) return;\r\n\r\n    if (!lastFrameTimeRef.current) {\r\n      lastFrameTimeRef.current = timestamp;\r\n      animationFrameRef.current = requestAnimationFrame(updateDropletPositions);\r\n      return;\r\n    }\r\n\r\n    const deltaTime = (timestamp - lastFrameTimeRef.current) / 1000; // Convert to seconds\r\n    const simulationDeltaTime = deltaTime * timeScale;\r\n    \r\n    setCurrentTime(prevTime => {\r\n      const newTime = prevTime + simulationDeltaTime;\r\n      \r\n      // Get the time range of our history\r\n      const lastHistoryTime = dropletHistory[dropletHistory.length - 1].time;\r\n      \r\n      // If we've reached the end, loop back to start\r\n      if (newTime >= lastHistoryTime) {\r\n        setCurrentTime(0);\r\n        return 0;\r\n      }\r\n\r\n      // Find the appropriate states to interpolate between\r\n      const currentState = interpolateDropletState(newTime);\r\n      // Update droplet visualization\r\n      const updatedDroplets = currentState.map(droplet => {\r\n        const frontX = volumetricToXPosition(droplet.frontVolumetricPosition);\r\n        const rearX = volumetricToXPosition(droplet.rearVolumetricPosition);\r\n\r\n        if (isNaN(frontX) || isNaN(rearX)) {\r\n          console.warn('Invalid droplet position calculated:', {\r\n            dropletId: droplet.id,\r\n            frontPosition: droplet.frontVolumetricPosition,\r\n            rearPosition: droplet.rearVolumetricPosition,\r\n            frontX,\r\n            rearX\r\n          });\r\n          return null;\r\n        }\r\n\r\n        return {\r\n          id: droplet.id,\r\n          frontX,\r\n          rearX,\r\n          y: 300,\r\n          volume: droplet.frontVolumetricPosition-droplet.rearVolumetricPosition,\r\n          speed: droplet.frontVolumetricSpeed\r\n        };\r\n      }).filter(Boolean);\r\n\r\n      setSimulationDroplets(updatedDroplets);\r\n      return newTime;\r\n    });\r\n\r\n    lastFrameTimeRef.current = timestamp;\r\n    animationFrameRef.current = requestAnimationFrame(updateDropletPositions);\r\n  }, [isSimulationRunning, timeScale, volumetricToXPosition, dropletHistory]);\r\n\r\n  // Add animation effect\r\n  useEffect(() => {\r\n    if (isSimulationRunning) {\r\n      lastFrameTimeRef.current = null;\r\n      animationFrameRef.current = requestAnimationFrame(updateDropletPositions);\r\n    }\r\n    return () => {\r\n      if (animationFrameRef.current) {\r\n        cancelAnimationFrame(animationFrameRef.current);\r\n      }\r\n    };\r\n  }, [isSimulationRunning, updateDropletPositions]);\r\n\r\n  // Add this helper function for interpolation\r\n  const interpolateDropletState = (time) => {\r\n    if (!dropletHistory.length) return [];\r\n    \r\n    // Find the two closest states\r\n    const index = dropletHistory.findIndex(state => state.time > time);\r\n    if (index === -1) return dropletHistory[dropletHistory.length - 1].droplets;\r\n    if (index === 0) return dropletHistory[0].droplets;\r\n    \r\n    const beforeState = dropletHistory[index - 1];\r\n    const afterState = dropletHistory[index];\r\n    const fraction = (time - beforeState.time) / (afterState.time - beforeState.time);\r\n    \r\n    return beforeState.droplets.map(beforeDroplet => {\r\n      const afterDroplet = afterState.droplets.find(d => d.id === beforeDroplet.id);\r\n      if (!afterDroplet) return beforeDroplet;\r\n      \r\n      return {\r\n        ...beforeDroplet,\r\n        frontVolumetricPosition: beforeDroplet.frontVolumetricPosition + \r\n          (afterDroplet.frontVolumetricPosition - beforeDroplet.frontVolumetricPosition) * fraction,\r\n        rearVolumetricPosition: beforeDroplet.rearVolumetricPosition + \r\n          (afterDroplet.rearVolumetricPosition - beforeDroplet.rearVolumetricPosition) * fraction,\r\n      };\r\n    });\r\n  };\r\n\r\n  // Add navigation functions\r\n  const jumpToTimepoint = useCallback((index) => {\r\n    if (index >= 0 && index < dropletHistory.length) {\r\n      setCurrentTimepoint(index);\r\n      setCurrentTime(dropletHistory[index].time);\r\n    }\r\n  }, [dropletHistory]);\r\n\r\n  const nextTimepoint = useCallback(() => {\r\n    jumpToTimepoint(currentTimepoint + 1);\r\n  }, [currentTimepoint, jumpToTimepoint]);\r\n\r\n  const previousTimepoint = useCallback(() => {\r\n    jumpToTimepoint(currentTimepoint - 1);\r\n  }, [currentTimepoint, jumpToTimepoint]);\r\n\r\n\r\n\r\n  const handleNodeClick = (node) => {\r\n    console.log('Node clicked:', node);\r\n    console.log('Node type:', node.type);\r\n    console.log('Node data type:', node.data?.type);\r\n    \r\n    // Check both node.type and node.data.type\r\n    const nodeType = node.type || node.data?.type;\r\n    console.log('Determined node type:', nodeType);\r\n    \r\n    if (nodeType === 'pump' || nodeType === 'USBSpectrometer' || nodeType === 'MQTTSpectrometer') {\r\n      setSelectedNode(node);\r\n      console.log('Selected node set:', node.id, nodeType);\r\n    }\r\n    if (node.type === 'detector' || node.type === 'USBSpectrometer' || node.type === 'MQTTSpectrometer') {\r\n      // Store the graph ref when opening a spectrometer\r\n      const graphRef = React.createRef();\r\n      graphRefs.current[node.id] = graphRef;\r\n      \r\n      // ... rest of the existing handleNodeClick code ...\r\n    }\r\n  };\r\n\r\n  const handleNodeAction = (action) => {\r\n    console.log('Node action:', action);\r\n    // Here you would implement the actual device communication\r\n    // based on the action type and parameters\r\n  };\r\n\r\n  const togglePumpSpeeds = () => {\r\n    setDisplayPumpSpeeds(!displayPumpSpeeds);\r\n  };\r\n\r\n  // Toggle functions for each display option\r\n  const toggleNodeIds = () => {\r\n    setDisplayNodeIds(!displayNodeIds);\r\n  };\r\n  \r\n  const toggleDropletInfo = () => {\r\n    setDisplayDropletInfo(!displayDropletInfo);\r\n  };\r\n  \r\n  const toggleDropletGaps = () => {\r\n    setDisplayDropletGaps(!displayDropletGaps);\r\n  };\r\n  \r\n  const toggleEdgeLabels = () => {\r\n    setDisplayEdgeLabels(!displayEdgeLabels);\r\n  };\r\n  \r\n  const toggleDisplayMenu = () => {\r\n    setDisplayMenuOpen(!isDisplayMenuOpen);\r\n  };\r\n  \r\n  const toggleTimelineDropletInfo = () => {\r\n    setDisplayTimelineDropletInfo(!displayTimelineDropletInfo);\r\n  };\r\n  \r\n  const toggleDetectorEvents = () => {\r\n    setDisplayDetectorEvents(!displayDetectorEvents);\r\n  };\r\n  \r\n  // Close menu when clicking outside\r\n  useEffect(() => {\r\n    const handleClickOutside = (event) => {\r\n      if (displayMenuRef.current && !displayMenuRef.current.contains(event.target)) {\r\n        setDisplayMenuOpen(false);\r\n      }\r\n    };\r\n    \r\n    document.addEventListener('mousedown', handleClickOutside);\r\n    return () => {\r\n      document.removeEventListener('mousedown', handleClickOutside);\r\n    };\r\n  }, []);\r\n\r\n  // Function to toggle pump panel visibility\r\n  const togglePumpPanel = (pumpId) => {\r\n    setVisiblePumpPanel((prev) => (prev === pumpId ? null : pumpId));\r\n  };\r\n\r\n  // Add styles for the display menu\r\n  const styles = {\r\n    container: {\r\n      ...backgroundVariants.mainBackground,\r\n      padding: '20px',\r\n      minHeight: '100vh'\r\n    },\r\n    dropletInfo: {\r\n      padding: '8px',\r\n      borderRadius: '4px',\r\n      fontSize: '12px',\r\n      ...backgroundVariants.panelBackground,\r\n      color: '#fff',\r\n      minWidth: '150px'\r\n    },\r\n    timelineContainer: {\r\n      display: 'flex',\r\n      flexDirection: 'column',\r\n      gap: '10px',\r\n      marginBottom: '20px'\r\n    },\r\n    timeInput: {\r\n      width: '100px',\r\n      ...backgroundVariants.inputBackground,\r\n      padding: '5px',\r\n      borderRadius: '4px',\r\n      marginLeft: '8px'\r\n    },\r\n    buttonGroup: {\r\n      display: 'flex',\r\n      gap: '10px',\r\n      marginTop: '20px',\r\n      marginBottom: '20px'\r\n    },\r\n    timelineControls: {\r\n      display: 'flex',\r\n      flexDirection: 'column',\r\n      gap: '15px',\r\n      marginBottom: '20px',\r\n      ...backgroundVariants.panelBackground,\r\n      padding: '15px',\r\n      borderRadius: '4px'\r\n    },\r\n    timeControls: {\r\n      display: 'flex',\r\n      flexDirection: 'column',\r\n      gap: '15px'\r\n    },\r\n    sliderContainer: {\r\n      display: 'flex',\r\n      gap: '10px',\r\n      alignItems: 'center',\r\n      borderBottom: '1px solid rgba(255,255,255,0.1)',\r\n      paddingBottom: '15px'\r\n    },\r\n    timeStepButtons: {\r\n      display: 'flex',\r\n      gap: '5px',\r\n      alignItems: 'center',\r\n      justifyContent: 'flex-start'\r\n    },\r\n    timeScaleContainer: {\r\n      display: 'flex',\r\n      alignItems: 'center',\r\n      gap: '15px',\r\n      justifyContent: 'flex-start',\r\n      borderTop: '1px solid rgba(255,255,255,0.1)',\r\n      paddingTop: '15px'\r\n    },\r\n    svgContainer: {\r\n      background: backgroundVariants.panelBackground.background,\r\n      borderRadius: '4px',\r\n      padding: '10px'\r\n    },\r\n    navigationButtons: {\r\n      display: 'flex',\r\n      justifyContent: 'space-between',\r\n      marginBottom: '20px'\r\n    },\r\n    timeSlider: {\r\n      width: '33%',\r\n      ...backgroundVariants.inputBackground,\r\n      height: '20px',\r\n      borderRadius: '10px',\r\n      WebkitAppearance: 'none',\r\n      appearance: 'none',\r\n      background: backgroundVariants.inputBackground.background,\r\n      outline: 'none',\r\n      opacity: '0.7',\r\n      transition: 'opacity .2s',\r\n      '&:hover': {\r\n        opacity: '1'\r\n      },\r\n      '&::-webkit-slider-thumb': {\r\n        WebkitAppearance: 'none',\r\n        appearance: 'none',\r\n        width: '20px',\r\n        height: '20px',\r\n        background: '#4CAF50',\r\n        cursor: 'pointer',\r\n        borderRadius: '50%'\r\n      },\r\n      '&::-moz-range-thumb': {\r\n        width: '20px',\r\n        height: '20px',\r\n        background: '#4CAF50',\r\n        cursor: 'pointer',\r\n        borderRadius: '50%'\r\n      }\r\n    },\r\n    // Add styles for display menu\r\n    displayMenuButton: {\r\n      ...buttonVariants.infoButton,\r\n      position: 'relative'\r\n    },\r\n    displayMenu: {\r\n      position: 'absolute',\r\n      top: '100%',\r\n      right: 0,\r\n      backgroundColor: '#333',\r\n      border: '1px solid #555',\r\n      borderRadius: '4px',\r\n      padding: '8px 0',\r\n      zIndex: 1000,\r\n      width: '220px',\r\n      boxShadow: '0 2px 10px rgba(0, 0, 0, 0.3)'\r\n    },\r\n    menuItem: {\r\n      padding: '8px 16px',\r\n      cursor: 'pointer',\r\n      display: 'flex',\r\n      alignItems: 'center',\r\n      justifyContent: 'space-between',\r\n      color: 'white',\r\n      transition: 'background-color 0.2s',\r\n      '&:hover': {\r\n        backgroundColor: '#444'\r\n      }\r\n    },\r\n    checkmark: {\r\n      color: '#4CAF50',\r\n      fontWeight: 'bold'\r\n    }\r\n  };\r\n\r\n  const sliderStyle = {\r\n    width: '100%',\r\n    height: '10px',\r\n    borderRadius: '5px', \r\n    background: '#333',\r\n    outline: 'none',\r\n    opacity: '0.7',\r\n    transition: 'opacity .2s'\r\n    // Remove all pseudo-element styles that were here\r\n  };\r\n\r\n  return (\r\n    <div style={styles.container}>\r\n      <div style={styles.timelineControls}>\r\n        <div style={styles.timeControls}>\r\n          <div style={styles.sliderContainer}>\r\n            <input\r\n              type=\"range\"\r\n              min={0}\r\n              max={Math.max(0, dropletHistory.length - 1)}\r\n              value={currentTimepoint}\r\n              onChange={(e) => jumpToTimepoint(Number(e.target.value))}\r\n              disabled={isSimulationRunning}\r\n              style={styles.timeSlider}\r\n              className=\"time-slider\" // Add this className\r\n            />\r\n            {displayTimelineDropletInfo && (\r\n              <div style={{ display: 'flex', gap: '10px', flexWrap: 'wrap' }}>\r\n                {dropletHistory.length > 0 && dropletHistory[currentTimepoint]?.droplets.map((droplet, index) => (\r\n                  <div key={droplet.id} style={styles.dropletInfo}>\r\n                    <div>Droplet {index + 1}:</div>\r\n                    {droplet.frontNextNodeID && (\r\n                      <div>Front → {graphData.nodes.find(n => n.id === droplet.frontNextNodeID)?.label || droplet.frontNextNodeID}</div>\r\n                    )}\r\n                    {droplet.rearNextNodeID && (\r\n                      <div>Rear → {graphData.nodes.find(n => n.id === droplet.rearNextNodeID)?.label || droplet.rearNextNodeID}</div>\r\n                    )}\r\n                  </div>\r\n                ))}\r\n              </div>\r\n            )}\r\n          </div>\r\n\r\n          <div style={styles.timeStepButtons}>\r\n            <button\r\n              onClick={() => jumpToTimepoint(0)}\r\n              disabled={currentTimepoint === 0 || isSimulationRunning}\r\n              style={{ ...buttonVariants.secondaryButton, padding: '4px 8px' }}\r\n            >\r\n              ⏮️ Start\r\n            </button>\r\n            <button\r\n              onClick={() => jumpToTimepoint(currentTimepoint - 1)}\r\n              disabled={currentTimepoint === 0 || isSimulationRunning}\r\n              style={{ ...buttonVariants.secondaryButton, padding: '4px 8px' }}\r\n            >\r\n              ⏪ Previous\r\n            </button>\r\n            <button\r\n              onClick={() => jumpToTimepoint(currentTimepoint + 1)}\r\n              disabled={currentTimepoint >= dropletHistory.length - 1 || isSimulationRunning}\r\n              style={{ ...buttonVariants.secondaryButton, padding: '4px 8px' }}\r\n            >\r\n              Next ⏩\r\n            </button>\r\n            <button\r\n              onClick={() => jumpToTimepoint(dropletHistory.length - 1)}\r\n              disabled={currentTimepoint >= dropletHistory.length - 1 || isSimulationRunning}\r\n              style={{ ...buttonVariants.secondaryButton, padding: '4px 8px' }}\r\n            >\r\n              End ⏭️\r\n            </button>\r\n          </div>\r\n\r\n          <div style={styles.timeScaleContainer}>\r\n            <label style={{ color: '#fff', marginRight: '10px' }}>\r\n              Time Scale:\r\n              <select\r\n                value={timeScale}\r\n                onChange={(e) => setTimeScale(Number(e.target.value))}\r\n                style={styles.timeInput}\r\n              >\r\n                <option value={0.0625}>1/16x</option>\r\n                <option value={0.25}>1/4x</option>\r\n                <option value={1}>1x</option>\r\n                <option value={4}>4x</option>\r\n                <option value={16}>16x</option>\r\n                <option value={64}>64x</option>\r\n                <option value={256}>256x</option>\r\n                <option value={1024}>1024x</option>\r\n              </select>\r\n            </label>\r\n            <label style={{ color: '#fff', marginRight: '10px' }}>\r\n              Current Time: {currentTime.toFixed(2)}s\r\n            </label>\r\n            <label style={{ color: '#fff' }}>\r\n              Step: {currentTimepoint + 1}/{dropletHistory.length}\r\n            </label>\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      <div style={styles.buttonGroup}>\r\n        <button \r\n          onClick={isSimulationRunning ? stopSimulation : startSimulation} \r\n          style={{ ...buttonVariants.primaryButton }}\r\n        >\r\n          {isSimulationRunning ? 'Stop Simulation' : 'Start Simulation'}\r\n        </button>\r\n        <button \r\n          onClick={restartSimulation} \r\n          style={{ ...buttonVariants.secondaryButton }}\r\n        >\r\n          Restart simulation\r\n        </button>\r\n        <button \r\n          onClick={sendingEventsToDevices} \r\n          style={{ ...buttonVariants.primaryButton }}\r\n        >\r\n          Send Events to Devices\r\n        </button>\r\n        <div ref={displayMenuRef} style={{ position: 'relative', display: 'inline-block' }}>\r\n          <button \r\n            onClick={toggleDisplayMenu} \r\n            style={styles.displayMenuButton}\r\n          >\r\n            Display Settings\r\n          </button>\r\n          {isDisplayMenuOpen && (\r\n            <div style={styles.displayMenu}>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={toggleNodeIds}\r\n              >\r\n                <span>Show Node IDs</span>\r\n                <span style={styles.checkmark}>{displayNodeIds ? '✓' : ''}</span>\r\n              </div>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={toggleDropletInfo}\r\n              >\r\n                <span>Show Droplet Info</span>\r\n                <span style={styles.checkmark}>{displayDropletInfo ? '✓' : ''}</span>\r\n              </div>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={toggleDropletGaps}\r\n              >\r\n                <span>Show Droplet Gaps</span>\r\n                <span style={styles.checkmark}>{displayDropletGaps ? '✓' : ''}</span>\r\n              </div>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={toggleEdgeLabels}\r\n              >\r\n                <span>Show Tube Dimensions</span>\r\n                <span style={styles.checkmark}>{displayEdgeLabels ? '✓' : ''}</span>\r\n              </div>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={togglePumpSpeeds}\r\n              >\r\n                <span>Show Pump Speeds</span>\r\n                <span style={styles.checkmark}>{displayPumpSpeeds ? '✓' : ''}</span>\r\n              </div>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={toggleTimelineDropletInfo}\r\n              >\r\n                <span>Show Timeline Droplet Info</span>\r\n                <span style={styles.checkmark}>{displayTimelineDropletInfo ? '✓' : ''}</span>\r\n              </div>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={toggleDetectorEvents}\r\n              >\r\n                <span>Show Detector Events</span>\r\n                <span style={styles.checkmark}>{displayDetectorEvents ? '✓' : ''}</span>\r\n              </div>\r\n            </div>\r\n          )}\r\n        </div>\r\n      </div>\r\n\r\n      {/* Rest of the SVG rendering code */}\r\n      {graphData.nodes.length > 0 && (\r\n        <div style={styles.svgContainer}>\r\n          <svg width=\"2000\" height=\"400\">\r\n            {/* Render edges first (background) */}\r\n            {graphData.links.map((link, index) => {\r\n              const sourceNode = graphData.nodes.find(node => node.id === link.source);\r\n              const targetNode = graphData.nodes.find(node => node.id === link.target);\r\n              if (!sourceNode || !targetNode) return null;\r\n              \r\n              const midX = (sourceNode.x + targetNode.x) / 2;\r\n              const midY = (sourceNode.y + targetNode.y) / 2;\r\n              \r\n              return (\r\n                <g key={`edge-${index}`}>\r\n                  <line\r\n                    x1={sourceNode.x}\r\n                    y1={sourceNode.y}\r\n                    x2={targetNode.x}\r\n                    y2={targetNode.y}\r\n                    stroke=\"#999\"\r\n                    strokeWidth={2}\r\n                  />\r\n                  <text\r\n                    x={midX}\r\n                    y={midY - 20}\r\n                    textAnchor=\"middle\"\r\n                    fill=\"#fff\"\r\n                    fontSize=\"12px\"\r\n                    style={{ display: displayEdgeLabels ? 'block' : 'none' }}\r\n                  >\r\n                    {`${link.length} mm (Ø ${link.diameter} mm)`}\r\n                  </text>\r\n                </g>\r\n              );\r\n            })}\r\n\r\n            {/* Render nodes (on top) */}\r\n            {graphData.nodes.map((node, index) => (\r\n              <g key={`node-${index}`}>\r\n                <circle\r\n                  cx={node.x}\r\n                  cy={node.y}\r\n                  r={15}\r\n                  fill={getNodeColor(node)}\r\n                  stroke={selectedNode && selectedNode.id === node.id ? '#FFA500' : 'none'}\r\n                  strokeWidth={selectedNode && selectedNode.id === node.id ? '3' : '0'}\r\n                  onClick={() => handleNodeClick(node)}\r\n                  style={{ cursor: 'pointer' }}\r\n                />\r\n                <text\r\n                  x={node.x}\r\n                  y={node.y - 25}\r\n                  textAnchor=\"middle\"\r\n                  fill=\"#fff\"\r\n                  fontSize=\"12px\"\r\n                >\r\n                  {node.label}\r\n                </text>\r\n                <text\r\n                  x={node.x}\r\n                  y={node.y - 10}\r\n                  textAnchor=\"middle\"\r\n                  fill=\"#fff\"\r\n                  fontSize=\"10px\"\r\n                  style={{ display: displayNodeIds ? 'block' : 'none' }}\r\n                >\r\n                  {`ID: ${node.id}`}\r\n                </text>\r\n              </g>\r\n            ))}\r\n\r\n            {/* Render droplets and distances between them */}\r\n            {interpolateDropletState(currentTime).map((droplet, index, droplets) => {\r\n              const frontX = volumetricToXPosition(droplet.frontVolumetricPosition);\r\n              const rearX = volumetricToXPosition(droplet.rearVolumetricPosition);\r\n              const centerX = (frontX + rearX) / 2;\r\n              \r\n              // Calculate distance to next droplet if this isn't the last droplet\r\n              const distanceInfo = index < droplets.length - 1 ? {\r\n                nextDropletFront: droplets[index + 1].frontVolumetricPosition,\r\n                distance: Math.abs(droplets[index + 1].frontVolumetricPosition - droplet.rearVolumetricPosition)\r\n              } : null;\r\n              \r\n              // Calculate midpoint for distance label\r\n              const distanceLabelX = distanceInfo ? \r\n                (volumetricToXPosition(droplet.rearVolumetricPosition) + \r\n                 volumetricToXPosition(distanceInfo.nextDropletFront)) / 2 : null;\r\n\r\n              return (\r\n                <g key={`droplet-${droplet.id}`}>\r\n                  {/* Droplet body */}\r\n                  <line\r\n                    x1={rearX}\r\n                    y1={300}\r\n                    x2={frontX}\r\n                    y2={300}\r\n                    stroke=\"rgba(255, 100, 100, 0.9)\"\r\n                    strokeWidth={8}\r\n                    strokeLinecap=\"butt\"\r\n                  />\r\n                  \r\n                  {/* Distance to next droplet */}\r\n                  {distanceInfo && displayDropletGaps && (\r\n                    <g>\r\n                      {/* Distance line */}\r\n                      <line\r\n                        x1={rearX}\r\n                        y1={320}\r\n                        x2={volumetricToXPosition(distanceInfo.nextDropletFront)}\r\n                        y2={320}\r\n                        stroke=\"#fff\"\r\n                        strokeWidth={1}\r\n                        strokeDasharray=\"5,5\"\r\n                      />\r\n                      {/* Distance arrows */}\r\n                      <line\r\n                        x1={rearX}\r\n                        y1={315}\r\n                        x2={rearX}\r\n                        y2={325}\r\n                        stroke=\"#fff\"\r\n                        strokeWidth={1}\r\n                      />\r\n                      <line\r\n                        x1={volumetricToXPosition(distanceInfo.nextDropletFront)}\r\n                        y1={315}\r\n                        x2={volumetricToXPosition(distanceInfo.nextDropletFront)}\r\n                        y2={325}\r\n                        stroke=\"#666\"\r\n                        strokeWidth={1}\r\n                      />\r\n                      {/* Distance label */}\r\n                      <text\r\n                        x={distanceLabelX}\r\n                        y={335}\r\n                        textAnchor=\"middle\"\r\n                        fill=\"#666\"\r\n                        fontSize=\"12px\"\r\n                      >\r\n                        {`${distanceInfo.distance.toFixed(2)} μL`}\r\n                      </text>\r\n                    </g>\r\n                  )}\r\n                  \r\n                  {/* Droplet info - wrap all info texts in conditional rendering */}\r\n                  {displayDropletInfo && (\r\n                    <>\r\n                      <text\r\n                        x={centerX}\r\n                        y={270}\r\n                        textAnchor=\"middle\"\r\n                        fill=\"#6f6\"\r\n                        fontSize=\"12px\"\r\n                      >\r\n                        {`Vol: ${(droplet.frontVolumetricPosition-droplet.rearVolumetricPosition).toFixed(2)} μL`}\r\n                      </text>\r\n                      <text\r\n                        x={centerX}\r\n                        y={255}\r\n                        textAnchor=\"middle\"\r\n                        fill=\"#6f6\"\r\n                        fontSize=\"12px\"\r\n                      >\r\n                        {`Spd f: ${droplet.frontVolumetricSpeed.toFixed(2)} μL/s`}\r\n                      </text>\r\n                      <text\r\n                        x={centerX}\r\n                        y={240}\r\n                        textAnchor=\"middle\"\r\n                        fill=\"#6f6\"\r\n                        fontSize=\"12px\"\r\n                      >\r\n                        {`Spd r: ${droplet.rearVolumetricSpeed.toFixed(2)} μL/s`}\r\n                      </text>\r\n                      <text\r\n                        x={centerX}\r\n                        y={225}\r\n                        textAnchor=\"middle\"\r\n                        fill=\"#6f6\"\r\n                        fontSize=\"12px\"\r\n                      >\r\n                        {`mlt: ${droplet.pumpSpeedMultiplier.toFixed(2)}`}\r\n                      </text>\r\n                    </>\r\n                  )}\r\n                </g>\r\n              );\r\n            })}\r\n\r\n            {displayPumpSpeeds && graphData.nodes.map((node, index) => {\r\n              if (node.type === 'pump') {\r\n                const currentSpeed = getPumpSpeedAtTime(node.id, pumpEvents, currentTime);\r\n                const maxTime = dropletHistory[dropletHistory.length - 1]?.time || 1;\r\n                const pumpSpecificEvents = pumpEvents.filter(event => event.target === node.id);\r\n                \r\n                return (\r\n                  <g key={`pump-speed-${node.id}`}>\r\n                    {/* Current pump speed value */}\r\n                    <text\r\n                      x={node.x}\r\n                      y={node.y - 35}\r\n                      textAnchor=\"middle\"\r\n                      fill=\"#4CAF50\"\r\n                      fontSize=\"12px\"\r\n                    >\r\n                      {`${currentSpeed.toFixed(2)} μL/s`}\r\n                    </text>\r\n                    \r\n                    {/* Speed history visualization */}\r\n                    <g transform={`translate(${node.x - 40}, ${node.y - 65})`}>\r\n                      {pumpSpecificEvents.map((event, i, arr) => {\r\n                        const nextEvent = arr[i + 1];\r\n                        const width = 80;\r\n                        const x = 0;\r\n                        const y = 0;\r\n                        \r\n                        // Calculate position based on time\r\n                        const timePosition = (event.time / maxTime) * width;\r\n                        const nextTimePosition = nextEvent \r\n                          ? (nextEvent.time / maxTime) * width\r\n                          : width;\r\n                        \r\n                        // Calculate height based on speed value (normalized)\r\n                        const maxSpeed = Math.max(...pumpSpecificEvents.map(e => e.value));\r\n                        const normalizedHeight = event.value / (maxSpeed || 1) * 20;\r\n                        \r\n                        return (\r\n                          <g key={`pump-event-${i}`}>\r\n                            {/* Speed segment */}\r\n                            <line\r\n                              x1={x + timePosition}\r\n                              y1={y - normalizedHeight}\r\n                              x2={x + nextTimePosition}\r\n                              y2={y - normalizedHeight}\r\n                              stroke=\"#4CAF50\"\r\n                              strokeWidth={2}\r\n                            />\r\n                            {/* Event point */}\r\n                            <circle\r\n                              cx={x + timePosition}\r\n                              cy={y - normalizedHeight}\r\n                              r={2}\r\n                              fill=\"#4CAF50\"\r\n                            />\r\n                            {/* Time marker */}\r\n                            <text\r\n                              x={x + timePosition}\r\n                              y={y + 12}\r\n                              textAnchor=\"middle\"\r\n                              fill=\"#666\"\r\n                              fontSize=\"10px\"\r\n                            >\r\n                              {event.time.toFixed(1)}s\r\n                            </text>\r\n                            {/* Speed value */}\r\n                            <text\r\n                              x={x + timePosition}\r\n                              y={y - normalizedHeight - 5}\r\n                              textAnchor=\"middle\"\r\n                              fill=\"#4CAF50\"\r\n                              fontSize=\"8px\"\r\n                            >\r\n                              {event.value.toFixed(1)}\r\n                            </text>\r\n                          </g>\r\n                        );\r\n                      })}\r\n                      {/* Current time indicator */}\r\n                      <line\r\n                        x1={(currentTime / maxTime) * 80}\r\n                        y1={-25}\r\n                        x2={(currentTime / maxTime) * 80}\r\n                        y2={15}\r\n                        stroke=\"red\"\r\n                        strokeWidth={1}\r\n                        strokeDasharray=\"2,2\"\r\n                      />\r\n                    </g>\r\n                  </g>\r\n                );\r\n              }\r\n              return null;\r\n            })}\r\n\r\n            {/* Render detector events */}\r\n            {displayDetectorEvents && graphData.nodes.map((node, index) => {\r\n              if (node.type === 'detector' || node.type === 'USBSpectrometer' || node.type === 'MQTTSpectrometer') {\r\n                const currentEvents = getDetectorEventsAtTime(node.id, detectorEvents, currentTime);\r\n                const detectorSpecificEvents = detectorEvents.filter(event => event.target === node.id);\r\n                const maxTime = dropletHistory[dropletHistory.length - 1]?.time || 1;\r\n                \r\n                return (\r\n                  <g key={`detector-events-${node.id}`}>\r\n                    {/* Current detector events indicator */}\r\n                    {currentEvents.length > 0 && (\r\n                      <circle\r\n                        cx={node.x}\r\n                        cy={node.y}\r\n                        r={20}\r\n                        fill=\"none\"\r\n                        stroke=\"#FF6B35\"\r\n                        strokeWidth={3}\r\n                        opacity={0.8}\r\n                      />\r\n                    )}\r\n                    \r\n                    {/* Event count display */}\r\n                    <text\r\n                      x={node.x}\r\n                      y={node.y - 35}\r\n                      textAnchor=\"middle\"\r\n                      fill=\"#FF6B35\"\r\n                      fontSize=\"12px\"\r\n                    >\r\n                      {`Events: ${detectorSpecificEvents.length}`}\r\n                    </text>\r\n                    \r\n                    {/* Event timeline visualization */}\r\n                    <g transform={`translate(${node.x - 40}, ${node.y - 65})`}>\r\n                      {detectorSpecificEvents.map((event, i) => {\r\n                        const width = 80;\r\n                        const x = 0;\r\n                        const y = 0;\r\n                        \r\n                        // Calculate position based on time\r\n                        const timePosition = (event.time / maxTime) * width;\r\n                        \r\n                        return (\r\n                          <g key={`detector-event-${i}`}>\r\n                            {/* Event marker */}\r\n                            <circle\r\n                              cx={x + timePosition}\r\n                              cy={y}\r\n                              r={3}\r\n                              fill={event.eventSubtype === 'dropletFrontReached' ? '#FF6B35' : '#FFA500'}\r\n                            />\r\n                            {/* Event line */}\r\n                            <line\r\n                              x1={x + timePosition}\r\n                              y1={y - 5}\r\n                              x2={x + timePosition}\r\n                              y2={y + 5}\r\n                              stroke=\"#FF6B35\"\r\n                              strokeWidth={1}\r\n                            />\r\n                            {/* Time label */}\r\n                            <text\r\n                              x={x + timePosition}\r\n                              y={y + 15}\r\n                              textAnchor=\"middle\"\r\n                              fill=\"#FF6B35\"\r\n                              fontSize=\"8px\"\r\n                            >\r\n                              {event.time.toFixed(1)}s\r\n                            </text>\r\n                            {/* Droplet ID */}\r\n                            <text\r\n                              x={x + timePosition}\r\n                              y={y - 10}\r\n                              textAnchor=\"middle\"\r\n                              fill=\"#FF6B35\"\r\n                              fontSize=\"8px\"\r\n                            >\r\n                              D{event.dropletId}\r\n                            </text>\r\n                          </g>\r\n                        );\r\n                      })}\r\n                      {/* Current time indicator */}\r\n                      <line\r\n                        x1={(currentTime / maxTime) * 80}\r\n                        y1={-25}\r\n                        x2={(currentTime / maxTime) * 80}\r\n                        y2={25}\r\n                        stroke=\"red\"\r\n                        strokeWidth={1}\r\n                        strokeDasharray=\"2,2\"\r\n                      />\r\n                    </g>\r\n                  </g>\r\n                );\r\n              }\r\n              return null;\r\n            })}\r\n          </svg>\r\n        </div>\r\n      )}\r\n      \r\n      {selectedNode && (selectedNode.type === 'pump' || selectedNode.data?.type === 'pump') && (\r\n        <DraggablePanel \r\n          initialPosition={pumpPanelPosition}\r\n          title={`Pump Controls - ${selectedNode.label || selectedNode.id}`}\r\n        >\r\n          <PumpActions\r\n            node={selectedNode}\r\n            nodes={nodes}\r\n            edges={edges}\r\n            onAction={handleNodeAction}\r\n          />\r\n        </DraggablePanel>\r\n      )}\r\n      {selectedNode && (selectedNode.type === 'USBSpectrometer' || selectedNode.data?.type === 'USBSpectrometer') && (\r\n        <>\r\n          {console.log('Rendering USBSpectrometer component for node:', selectedNode)}\r\n          <USBSpectrometer\r\n            detector={selectedNode}\r\n            detectorId={selectedNode.id}\r\n            detectorName={selectedNode.label || selectedNode.id}\r\n            onClose={() => setSelectedNode(null)}\r\n            initialPosition={{ x: 150, y: 100 }}\r\n            isVisible={true}\r\n          />\r\n        </>\r\n      )}\r\n      {selectedNode && (selectedNode.type === 'MQTTSpectrometer' || selectedNode.data?.type === 'MQTTSpectrometer') && (\r\n        <>\r\n          {console.log('Rendering SpectrometerMQTT component for node:', selectedNode)}\r\n          <SpectrometerMQTT\r\n            detector={selectedNode}\r\n            detectorId={selectedNode.id}\r\n            detectorName={selectedNode.label || selectedNode.id}\r\n            onClose={() => setSelectedNode(null)}\r\n            initialPosition={{ x: 150, y: 100 }}\r\n            isVisible={true}\r\n          />\r\n        </>\r\n      )}\r\n      {/* Add styles for PumpActions */}\r\n      <style>\r\n        {`\r\n          .node-actions {\r\n            position: fixed;\r\n            top: 20px;\r\n            right: 20px;\r\n            background: black;\r\n            padding: 20px;\r\n            border: 1px solid #ccc;\r\n            border-radius: 5px;\r\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\r\n          }\r\n          .node-actions h3 {\r\n            margin: 0 0 15px 0;\r\n            color: #333;\r\n          }\r\n          .node-actions button {\r\n            margin: 5px;\r\n            padding: 8px 16px;\r\n            background: #4CAF50;\r\n            color: white;\r\n            border: none;\r\n            border-radius: 4px;\r\n            cursor: pointer;\r\n          }\r\n          .node-actions button:disabled {\r\n            background: #ccc;\r\n            cursor: not-allowed;\r\n          }\r\n          .node-actions input {\r\n            margin: 5px;\r\n            padding: 8px;\r\n            border: 1px solid #ccc;\r\n            border-radius: 4px;\r\n            width: 80px;\r\n          }\r\n          .move-controls {\r\n            display: flex;\r\n            flex-direction: column;\r\n            gap: 10px;\r\n            margin-top: 10px;\r\n          }\r\n          .input-group {\r\n            display: flex;\r\n            align-items: center;\r\n            gap: 10px;\r\n          }\r\n          .input-group label {\r\n            min-width: 100px;\r\n            text-align: right;\r\n            color: #666;\r\n          }\r\n        `}\r\n      </style>\r\n      {overlayComponent && (\r\n        <div style={{\r\n          position: 'fixed',\r\n          top: 0,\r\n          left: 0,\r\n          right: 0,\r\n          bottom: 0,\r\n          zIndex: 9999,\r\n          pointerEvents: 'none'\r\n        }}>\r\n          <Suspense fallback={\r\n            <div style={{\r\n              position: 'fixed',\r\n              top: '50%',\r\n              left: '50%',\r\n              transform: 'translate(-50%, -50%)',\r\n              background: 'rgba(0,0,0,0.8)',\r\n              padding: '20px',\r\n              borderRadius: '8px',\r\n              color: 'white',\r\n              pointerEvents: 'auto'\r\n            }}>\r\n              <h2>Loading Component...</h2>\r\n            </div>\r\n          }>\r\n            {overlayComponent.type === 'USBSpectrometer' && (\r\n              <div style={{ pointerEvents: 'auto' }}>\r\n                <USBSpectrometer {...overlayComponent.props} />\r\n              </div>\r\n            )}\r\n            {overlayComponent.type === 'MQTTSpectrometer' && (\r\n              <div style={{ pointerEvents: 'auto' }}>\r\n                <SpectrometerMQTT \r\n                  {...overlayComponent.props} \r\n                  graphRef={graphRefs.current[overlayComponent.props.detector.id]}\r\n                />\r\n              </div>\r\n            )}\r\n            {overlayComponent.type === 'PumpPanel' && (\r\n              <div style={{ pointerEvents: 'auto' }}>\r\n                <PumpPanel {...overlayComponent.props} />\r\n              </div>\r\n            )}\r\n          </Suspense>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Simulation;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}