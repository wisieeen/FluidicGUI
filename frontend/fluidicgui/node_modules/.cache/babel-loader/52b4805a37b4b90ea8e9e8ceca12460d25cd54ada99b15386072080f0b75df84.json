{"ast":null,"code":"var _jsxFileName = \"E:\\\\flow chemistry\\\\fluidicGUI\\\\frontend\\\\fluidicgui\\\\src\\\\components\\\\Simulation\\\\SpectrometerMQTT\\\\MQTTCameraComponent.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useRef, useEffect, useImperativeHandle } from 'react';\nimport { useButtonStyles } from '../../../styles/ButtonStyleProvider';\nimport { WS_URL } from '../../../config';\nimport { floatingComponentStyles } from '../../../styles/FloatingComponentStyles';\n\n// Constants for settings\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst SETTINGS_STORAGE_KEY = 'fluidicgui_settings';\nconst MIN_LINE_LENGTH = 10; // Minimum length in pixels for a valid line\nconst MIN_CROP_SIZE = 1; // Minimum crop rectangle size\n\n// Helper function to get settings from localStorage\nconst getSettingsFromStorage = () => {\n  try {\n    const settings = localStorage.getItem(SETTINGS_STORAGE_KEY);\n    return settings ? JSON.parse(settings) : {\n      mqttBroker: 'localhost',\n      port: '1883'\n    };\n  } catch (error) {\n    console.error('Error reading settings from localStorage:', error);\n    return {\n      mqttBroker: 'localhost',\n      port: '1883'\n    };\n  }\n};\nconst MQTTCameraComponent = /*#__PURE__*/_s(/*#__PURE__*/React.forwardRef(_c = _s((props, ref) => {\n  _s();\n  const {\n    onResize,\n    detectorId\n  } = props;\n  const buttonVariants = useButtonStyles();\n\n  // Camera view state\n  const [cameraSize, setCameraSize] = useState({\n    width: 640,\n    height: 480\n  });\n  const [isResizing, setIsResizing] = useState(false);\n  const [showResizeInfo, setShowResizeInfo] = useState(false);\n  const [imageAspectRatio, setImageAspectRatio] = useState(640 / 480);\n\n  // MQTT connection state\n  const [mqttTopic, setMqttTopic] = useState(detectorId || 'spectrometer_1');\n  const [mqttClient, setMqttClient] = useState(null);\n  const [isMqttConnected, setIsMqttConnected] = useState(false);\n  const [lastMqttResponse, setLastMqttResponse] = useState(null);\n  const [isStreaming, setIsStreaming] = useState(false);\n  const [pollingInterval, setPollingInterval] = useState(500);\n  const intervalRef = useRef(null);\n  const [isWaitingForResponse, setIsWaitingForResponse] = useState(false);\n  const [isWaitingForCropResponse, setIsWaitingForCropResponse] = useState(false);\n\n  // Camera operation state\n  const [isCameraActive, setIsCameraActive] = useState(false);\n  const [showAdvancedCapabilities, setShowAdvancedCapabilities] = useState(false);\n  const [cameraCapabilities, setCameraCapabilities] = useState(null);\n  const [exposureMode, setExposureMode] = useState('continuous');\n\n  // Line drawing state\n  const [isDrawing, setIsDrawing] = useState(false);\n  const [currentLine, setCurrentLine] = useState(null);\n  const [isLineDrawn, setIsLineDrawn] = useState(false);\n\n  // Line adjustment state\n  const [lineYOffset, setLineYOffset] = useState(0);\n  const [lineXOffset, setLineXOffset] = useState(0);\n  const [originalLineStart, setOriginalLineStart] = useState({\n    x: 0,\n    y: 0\n  });\n  const [originalLineEnd, setOriginalLineEnd] = useState({\n    x: 0,\n    y: 0\n  });\n\n  // Crop frame state\n  const [isCropMode, setIsCropMode] = useState(false);\n  const [isDrawingCrop, setIsDrawingCrop] = useState(false);\n  const [cropStart, setCropStart] = useState(null);\n  const [cropEnd, setCropEnd] = useState(null);\n  const [cropRange, setCropRange] = useState([0, 0, 0, 0]); // [x_min, y_min, x_max, y_max]\n  const [cropInterval, setCropInterval] = useState(0);\n  const [isCropStreaming, setIsCropStreaming] = useState(false);\n  const [cropPreviewImage, setCropPreviewImage] = useState(null);\n  const cropIntervalRef = useRef(null);\n\n  // Camera settings\n  const [cameraResolution, setCameraResolution] = useState('640x480');\n  const [showConfigMenu, setShowConfigMenu] = useState(false);\n  const [cameraConfig, setCameraConfig] = useState({\n    camera: {\n      exposure_time: null,\n      exposure_mode: 'auto',\n      iso: null\n    },\n    processing: {\n      roi: [0, 0, 1280, 720]\n    }\n  });\n  const [pendingConfig, setPendingConfig] = useState(null);\n\n  // Refs\n  const cameraContainerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const imageRef = useRef(null);\n  const animationRequestRef = useRef(null);\n  const lastLineUpdateTimeRef = useRef(0);\n\n  // MQTT settings\n  const [mqttSettings, setMqttSettings] = useState(() => {\n    const savedSettings = getSettingsFromStorage();\n    return {\n      host: savedSettings.mqttBroker || 'localhost',\n      port: savedSettings.port || 1883,\n      protocol: 'ws',\n      clientId: `fluidic_gui_${Math.random().toString(16).substr(2, 8)}`\n    };\n  });\n\n  // Effects to reload settings if they change in localStorage\n  useEffect(() => {\n    const handleStorageChange = () => {\n      const savedSettings = getSettingsFromStorage();\n      setMqttSettings(prev => ({\n        ...prev,\n        host: savedSettings.mqttBroker || prev.host,\n        port: savedSettings.port || prev.port\n      }));\n    };\n    window.addEventListener('storage', handleStorageChange);\n    return () => window.removeEventListener('storage', handleStorageChange);\n  }, []);\n  const [availableResolutions, setAvailableResolutions] = useState(['640x480', '800x600', '1024x768', '1280x960']);\n  const [lastPublishedMessage, setLastPublishedMessage] = useState(null);\n  const [lastReceivedMessage, setLastReceivedMessage] = useState(null);\n  const [debugMode, setDebugMode] = useState(true);\n\n  // Debug log for detectorId\n  console.log('[MQTTCameraComponent] Initialized with detectorId:', detectorId);\n\n  // Debug log when mqttTopic changes\n  useEffect(() => {\n    console.log('[MQTTCameraComponent] MQTT topic set to:', mqttTopic);\n  }, [mqttTopic]);\n\n  // Expose methods to parent component via ref\n  useImperativeHandle(ref, () => ({\n    // Get current camera settings\n    getSettings: () => {\n      return {\n        mqttTopic: mqttTopic,\n        pollingInterval: pollingInterval,\n        mqttBroker: mqttSettings,\n        resolution: cameraResolution,\n        // Line drawing settings\n        isLineDrawn: isLineDrawn,\n        lineStart: originalLineStart,\n        lineEnd: originalLineEnd,\n        lineYOffset: lineYOffset,\n        lineXOffset: lineXOffset,\n        // Crop settings\n        cropRange: cropRange,\n        cropInterval: cropInterval\n      };\n    },\n    // Get just the crop frame settings\n    getCropSettings: () => {\n      return {\n        cropRange: cropRange,\n        cropInterval: cropInterval,\n        isCropMode: isCropMode,\n        isCropStreaming: isCropStreaming,\n        streamImage: streamCropImage,\n        toGraph: cropToGraph,\n        fullData: sendFullData\n      };\n    },\n    // Apply crop settings from saved config\n    applyCropSettings: settings => {\n      if (!settings) return false;\n      try {\n        // Apply crop range settings\n        if (settings.cropRange && Array.isArray(settings.cropRange) && settings.cropRange.length === 4) {\n          setCropRange(settings.cropRange);\n\n          // If crop range is valid (not all zeros), enable crop mode\n          if (settings.cropRange.some(val => val !== 0)) {\n            setIsCropMode(true);\n          }\n        }\n\n        // Apply crop interval\n        if (typeof settings.cropInterval === 'number') {\n          setCropInterval(settings.cropInterval);\n        }\n\n        // Apply stream image setting if available\n        if (typeof settings.streamImage === 'boolean') {\n          setStreamCropImage(settings.streamImage);\n        }\n\n        // Apply to graph setting if available\n        if (typeof settings.toGraph === 'boolean') {\n          setCropToGraph(settings.toGraph);\n        }\n\n        // Apply crop streaming state if explicitly set\n        if (typeof settings.isCropStreaming === 'boolean' && settings.isCropStreaming) {\n          // Only start streaming if we have a valid crop range and mqtt is connected\n          if (cropRange.some(val => val !== 0) && isMqttConnected) {\n            // Wait for next tick to ensure crop range is updated\n            setTimeout(() => {\n              startCropStreaming();\n            }, 500);\n          }\n        }\n        return true;\n      } catch (error) {\n        console.error('Error applying crop settings:', error);\n        return false;\n      }\n    },\n    // Expose startCamera method to parent\n    startCamera: async () => {\n      if (!isCameraActive) {\n        return connectToMqttAndStartStreaming();\n      }\n      return Promise.resolve(false);\n    },\n    // Apply saved camera settings\n    applySettings: async settings => {\n      if (!settings) return false;\n\n      // Disconnect and reconnect if topic changes\n      let shouldReconnect = false;\n      if (settings.mqttTopic && settings.mqttTopic !== mqttTopic) {\n        setMqttTopic(settings.mqttTopic);\n        shouldReconnect = true;\n      }\n      try {\n        // Apply MQTT settings if provided\n        if (settings.pollingInterval) {\n          setPollingInterval(settings.pollingInterval);\n        }\n\n        // Apply resolution\n        if (settings.resolution) {\n          setCameraResolution(settings.resolution);\n\n          // Parse the resolution into width and height\n          const [width, height] = settings.resolution.split('x').map(Number);\n\n          // Update camera size based on resolution\n          setCameraSize({\n            width,\n            height\n          });\n\n          // Update aspect ratio\n          if (width && height) {\n            setImageAspectRatio(width / height);\n          }\n        }\n\n        // Apply crop settings if available\n        if (settings.cropRange && Array.isArray(settings.cropRange) && settings.cropRange.length === 4) {\n          setCropRange(settings.cropRange);\n\n          // Enable crop mode if we have a valid crop range\n          if (settings.cropRange.some(val => val !== 0)) {\n            setIsCropMode(true);\n          }\n        }\n        if (typeof settings.cropInterval === 'number') {\n          setCropInterval(settings.cropInterval);\n        }\n\n        // Apply stream image setting if available\n        if (typeof settings.streamImage === 'boolean') {\n          setStreamCropImage(settings.streamImage);\n        }\n\n        // Apply to graph setting if available\n        if (typeof settings.toGraph === 'boolean') {\n          setCropToGraph(settings.toGraph);\n        }\n\n        // If camera is not active OR if topic changed, start/restart connection\n        if (!isCameraActive || shouldReconnect) {\n          if (isCameraActive) {\n            disconnectFromMqtt(); // Disconnect first if topic changed\n            await new Promise(resolve => setTimeout(resolve, 500)); // Wait for disconnect\n          }\n          // Short delay to allow state update\n          setTimeout(() => connectToMqttAndStartStreaming(), 100);\n\n          // Wait for camera to start before continuing\n          await new Promise(resolve => setTimeout(resolve, 1000));\n        }\n\n        // After camera settings are applied, handle line drawing settings\n        if (settings.isLineDrawn && settings.lineStart && settings.lineEnd) {\n          // Set original line points\n          setOriginalLineStart(settings.lineStart);\n          setOriginalLineEnd(settings.lineEnd);\n\n          // Set current line points (will be adjusted by offset/rotation later)\n          setCurrentLine(settings);\n\n          // Mark line as drawn\n          setIsLineDrawn(true);\n\n          // Apply line adjustments\n          if (settings.lineYOffset !== undefined) {\n            setLineYOffset(settings.lineYOffset);\n          }\n          if (settings.lineXOffset !== undefined) {\n            setLineXOffset(settings.lineXOffset);\n          }\n\n          // Send the loaded line to the backend immediately\n          // Use a timeout to ensure connection is established after potential restart\n          setTimeout(() => {\n            const finalLine = calculateTransformedLinePosition(settings.lineStart, settings.lineEnd, settings.lineYOffset, settings.lineXOffset);\n            sendLineUpdate(finalLine);\n            redrawCanvas(); // Redraw with the loaded line\n          }, 1500); // Increased delay to ensure connection\n        }\n        return true;\n      } catch (error) {\n        console.error('Error applying camera settings:', error);\n        return false;\n      }\n    }\n  }));\n\n  // Connect to MQTT broker and start streaming\n  const connectToMqttAndStartStreaming = async () => {\n    try {\n      // Use the WS_URL from config instead of trying to connect directly to MQTT broker\n      console.log('Connecting to WebSocket server at:', WS_URL);\n\n      // Create WebSocket connection using WS_URL\n      const websocket = new WebSocket(WS_URL);\n      websocket.onopen = () => {\n        console.log('Connected to WebSocket server successfully');\n        setIsMqttConnected(true);\n\n        // Explicitly subscribe to the response topic via WebSocket\n        const subscribeMessage = {\n          topic: \"common/subscribe\",\n          payload: `${mqttTopic}/response/full_frame`\n        };\n        websocket.send(JSON.stringify(subscribeMessage));\n\n        // Subscribe to config response topic\n        const subscribeConfig = {\n          topic: \"common/subscribe\",\n          payload: `${mqttTopic}/response/config`\n        };\n        websocket.send(JSON.stringify(subscribeConfig));\n\n        // Subscribe to cropped frame response topic\n        const subscribeCroppedFrame = {\n          topic: \"common/subscribe\",\n          payload: `${mqttTopic}/response/crop_frame`\n        };\n        console.log(`[MQTTCamera] Subscribing to cropped frame topic: ${subscribeCroppedFrame.payload}`);\n        websocket.send(JSON.stringify(subscribeCroppedFrame));\n\n        // Request current config\n        const requestConfigMessage = {\n          topic: `${mqttTopic}/request/config`,\n          payload: {\n            timestamp: Date.now()\n          }\n        };\n        websocket.send(JSON.stringify(requestConfigMessage));\n        setLastPublishedMessage(requestConfigMessage);\n\n        // Add a diagnostic function to verify and re-subscribe if needed\n        const diagnosticCheckCallback = () => {\n          if (websocket && websocket.readyState === WebSocket.OPEN) {\n            console.log(\"[MQTTCamera] Running subscription diagnostic check\");\n\n            // Re-subscribe to crop_frame topic to ensure it's active\n            const resubCroppedFrame = {\n              topic: \"common/subscribe\",\n              payload: `${mqttTopic}/response/crop_frame`\n            };\n            websocket.send(JSON.stringify(resubCroppedFrame));\n            console.log(`[MQTTCamera] Re-subscribed to cropped frame topic: ${resubCroppedFrame.payload}`);\n\n            // Request subscription status if supported by server\n            const statusRequest = {\n              topic: \"common/subscription_status\",\n              payload: {\n                client_id: mqttSettings.clientId\n              }\n            };\n            websocket.send(JSON.stringify(statusRequest));\n          }\n        };\n\n        // Run diagnostic check after a delay\n        setTimeout(diagnosticCheckCallback, 3000);\n\n        // Start streaming right away\n        startStreaming(websocket);\n      };\n      websocket.onmessage = event => {\n        try {\n          const rawData = event.data;\n          console.debug('[MQTTCamera] Raw WS Message:', rawData);\n          const data = JSON.parse(rawData);\n\n          // Handle cropped frame response\n          if (data.topic === `${mqttTopic}/response/crop_frame`) {\n            try {\n              console.log(\"[MQTTCamera] Received cropped frame response:\", data);\n              let imageData = null;\n\n              // Handle payload based on its type\n              if (data.payload) {\n                if (typeof data.payload === 'string') {\n                  try {\n                    console.log(\"[MQTTCamera] Parsing string payload:\", data.payload.substring(0, 100) + \"...\");\n                    const parsedPayload = JSON.parse(data.payload);\n                    if (parsedPayload.image) {\n                      imageData = parsedPayload.image;\n                      console.log(\"[MQTTCamera] Found image in parsed payload, length:\", imageData.length);\n                    }\n                  } catch (e) {\n                    console.warn(\"[MQTTCamera] Error parsing payload:\", e);\n                    // Silent catch - not valid JSON\n                  }\n                } else if (typeof data.payload === 'object' && data.payload.image) {\n                  imageData = data.payload.image;\n                  console.log(\"[MQTTCamera] Found image in object payload, length:\", imageData.length);\n                }\n              }\n              if (imageData) {\n                updateCropPreviewWithBase64Image(imageData);\n                console.log(\"[MQTTCamera] Updated crop preview with image data\");\n              } else {\n                console.warn('⚠️ Cropped frame response has no image data');\n              }\n\n              // Mark that we've received a crop response and can send another request\n              setIsWaitingForCropResponse(false);\n            } catch (err) {\n              console.error('Error processing cropped frame response:', err);\n              setIsWaitingForCropResponse(false); // Reset flag even on error\n            }\n            return; // Exit after handling cropped frame\n          }\n\n          // Handle Config Response\n          if (data.topic === `${mqttTopic}/response/config`) {\n            try {\n              let configData = null;\n              console.debug('[MQTTCamera] Received config response, Payload type:', typeof data.payload, 'Payload:', data.payload);\n              if (data.payload) {\n                if (typeof data.payload === 'string') {\n                  // Attempt to parse if it looks like JSON\n                  try {\n                    configData = JSON.parse(data.payload);\n                    console.debug('[MQTTCamera] Parsed string payload to config object:', configData);\n                  } catch (e) {\n                    console.warn('[MQTTCamera] Config payload is a string but not valid JSON:', data.payload, 'Error:', e);\n                    // Keep configData null\n                  }\n                } else {\n                  // Payload is already an object\n                  configData = data.payload;\n                  console.debug('[MQTTCamera] Config payload is already an object:', configData);\n                }\n              }\n              if (configData) {\n                console.log(\"[MQTTCamera] Processing received config:\", configData);\n                // Validate received config structure slightly\n                if (configData.camera && configData.processing && configData.processing.roi) {\n                  setCameraConfig(configData);\n                  setPendingConfig(JSON.parse(JSON.stringify(configData))); // Update pending config too\n                  // Update relevant states based on config if needed (e.g., ROI might affect cameraSize view)\n                  const [w, h] = configData.camera.resolution || [640, 480]; // Fallback resolution\n                  if (w && h) {\n                    setCameraSize({\n                      width: w,\n                      height: h\n                    });\n                    setImageAspectRatio(w / h);\n                  }\n                } else {\n                  console.warn(\"Received invalid config structure\", configData);\n                }\n              } else {\n                console.warn(\"Received empty or non-parsable config response payload\");\n                // Maybe add error state here?\n              }\n            } catch (err) {\n              console.error('Error processing config response:', err, 'Data:', data.payload);\n            }\n            return; // Processed config, exit\n          }\n\n          // DIRECTLY CHECK for the specific response topic first\n          if (data.topic === `${mqttTopic}/response/full_frame`) {\n            try {\n              let imageData = null;\n\n              // Handle payload based on its type\n              let resolution = null;\n              if (data.payload) {\n                if (typeof data.payload === 'string') {\n                  try {\n                    const parsedPayload = JSON.parse(data.payload);\n                    if (parsedPayload.image) {\n                      imageData = parsedPayload.image;\n                    }\n                    if (parsedPayload.resolution) {\n                      resolution = parsedPayload.resolution;\n                    }\n                  } catch (e) {\n                    // Silently continue\n                  }\n                } else if (typeof data.payload === 'object' && data.payload.image) {\n                  imageData = data.payload.image;\n                  if (data.payload.resolution) {\n                    resolution = data.payload.resolution;\n                  }\n                }\n              }\n              if (imageData) {\n                // If resolution was sent with the image, update aspect ratio based on it\n                if (resolution && Array.isArray(resolution) && resolution.length === 2) {\n                  const [imgW, imgH] = resolution;\n                  if (imgW > 0 && imgH > 0) {\n                    updateAspectRatioAndResolutions(imgW, imgH);\n                  }\n                }\n                setLastMqttResponse(data.payload);\n                updateVideoWithBase64Image(imageData);\n              } else {\n                console.warn('⚠️ Response has correct topic but no image data found');\n              }\n\n              // Mark that we've received a response and can send another request\n              setIsWaitingForResponse(false);\n            } catch (err) {\n              console.error('Error processing response:', err);\n              setIsWaitingForResponse(false); // Reset flag even on error\n            }\n\n            // Return after handling the main topic to avoid redundant processing\n            return;\n          }\n\n          // Log unhandled message topics for debugging\n          if (data.topic && data.topic.includes(mqttTopic) && data.topic !== `${mqttTopic}/response/full_frame` && data.topic !== `${mqttTopic}/response/crop_frame` && data.topic !== `${mqttTopic}/response/config` && data.topic !== `${mqttTopic}/response/data`) {\n            console.log(`[MQTTCamera] Unhandled topic received: ${data.topic}`, data);\n          }\n\n          // Fallback: Check for common/device_response which might contain our response\n          if (data.topic === 'common/device_response') {\n            // Process common/device_response\n            if (data.payload && typeof data.payload === 'string') {\n              if (data.payload.includes(mqttTopic)) {\n                try {\n                  if (data.payload.includes('image')) {\n                    const responseData = JSON.parse(data.payload);\n                    if (responseData.image) {\n                      updateVideoWithBase64Image(responseData.image);\n                      setLastMqttResponse(responseData);\n                    }\n                  }\n                } catch (err) {\n                  console.error('Error parsing device response:', err);\n                }\n              }\n            }\n          }\n\n          // Final fallback: Look for anything that might contain image data\n          const fullEventData = JSON.stringify(data).toLowerCase();\n          if (fullEventData.includes('image') || fullEventData.includes('frame') || fullEventData.includes('response')) {\n            tryExtractAndShowImage(data);\n          }\n        } catch (error) {\n          console.error('❌ Error processing WebSocket message:', error, 'Raw data:', event.data);\n          // Reset waiting flags in case of error\n          setIsWaitingForResponse(false);\n          setIsWaitingForCropResponse(false);\n        }\n      };\n      websocket.onerror = error => {\n        console.error('WebSocket error:', error);\n        setIsMqttConnected(false);\n        setIsCameraActive(false);\n      };\n      setMqttClient(websocket);\n      setIsCameraActive(true);\n      return true;\n    } catch (error) {\n      console.error('Error connecting to WebSocket:', error);\n      return false;\n    }\n  };\n\n  // Disconnect from MQTT broker\n  const disconnectFromMqtt = () => {\n    // Stop streaming first\n    stopStreaming();\n\n    // Unsubscribe from the response topic before closing the connection\n    if (mqttClient && mqttClient.readyState === WebSocket.OPEN) {\n      // Send unsubscribe message\n      const unsubscribeMessage = {\n        topic: \"common/unsubscribe\",\n        payload: `${mqttTopic}/response/full_frame`\n      };\n      mqttClient.send(JSON.stringify(unsubscribeMessage));\n\n      // Add a small delay before closing to ensure the unsubscribe is processed\n      setTimeout(() => {\n        mqttClient.close();\n      }, 100);\n    }\n    setIsMqttConnected(false);\n    setIsCameraActive(false);\n    setMqttClient(null);\n  };\n\n  // Start streaming frames\n  const startStreaming = websocket => {\n    if (!websocket) return;\n    setIsStreaming(true);\n\n    // Send first frame request immediately\n    requestFullFrame(websocket);\n\n    // Set up interval to check if we should request a new frame\n    intervalRef.current = setInterval(() => {\n      // Only send a new request if:\n      // 1. We're not in crop mode\n      // 2. We're not already waiting for a response\n      // 3. WebSocket is connected\n      if (!isCropMode && !isWaitingForResponse && websocket && websocket.readyState === WebSocket.OPEN) {\n        requestFullFrame(websocket);\n      }\n    }, pollingInterval);\n  };\n\n  // Request a single full frame\n  const requestFullFrame = websocket => {\n    // Format the message according to the system's expected format\n    const message = {\n      topic: `${mqttTopic}/request/full_frame`,\n      payload: {\n        timestamp: Date.now()\n      }\n    };\n    setLastPublishedMessage(message);\n    setIsWaitingForResponse(true);\n    websocket.send(JSON.stringify(message));\n  };\n\n  // Stop streaming frames\n  const stopStreaming = () => {\n    if (intervalRef.current) {\n      clearInterval(intervalRef.current);\n      intervalRef.current = null;\n      setIsStreaming(false);\n    }\n  };\n\n  // Update aspect ratio and available resolutions when we receive an image\n  const updateAspectRatioAndResolutions = (width, height) => {\n    const newAspectRatio = width / height;\n    if (Math.abs(newAspectRatio - imageAspectRatio) > 0.01) {\n      // Small threshold to avoid unnecessary updates\n      setImageAspectRatio(newAspectRatio);\n\n      // Generate resolution options that match this aspect ratio\n      const baseWidths = [640, 800, 1024, 1280, 1600, 1920];\n      const newResolutions = baseWidths.map(w => {\n        const h = Math.round(w / newAspectRatio);\n        return `${w}x${h}`;\n      });\n      setAvailableResolutions(newResolutions);\n\n      // Set cameraResolution to match actual camera resolution\n      setCameraResolution(`${width}x${height}`);\n\n      // Adjust current camera size to match aspect ratio\n      setCameraSize(prev => ({\n        width: prev.width,\n        height: Math.round(prev.width / newAspectRatio)\n      }));\n    }\n  };\n\n  // Update video with base64 encoded image data\n  const updateVideoWithBase64Image = base64Data => {\n    if (!base64Data) {\n      console.error('Cannot update image: missing base64 data');\n      return;\n    }\n    if (!canvasRef.current) {\n      console.error('Cannot update image: canvas reference is null');\n      return;\n    }\n\n    // Validate that the base64 string looks correct\n    if (!base64Data.match(/^[A-Za-z0-9+/=]+$/)) {\n      console.error('Invalid base64 data format. Data does not appear to be valid base64.');\n      return;\n    }\n\n    // Create an image element to load the data\n    const img = new Image();\n\n    // Add load event listener before setting src\n    img.onload = () => {\n      // Store the image reference for later use\n      imageRef.current = img;\n\n      // Update aspect ratio and available resolutions\n      updateAspectRatioAndResolutions(img.width, img.height);\n\n      // Call redrawCanvas instead of drawing directly here\n      redrawCanvas();\n    };\n    img.onerror = error => {\n      console.error('Failed to load image:', error);\n      console.error('Image load failed. This usually means the base64 data is invalid or incomplete.');\n    };\n\n    // Set the image source to the base64 data\n    try {\n      img.src = `data:image/jpeg;base64,${base64Data}`;\n    } catch (e) {\n      console.error('Error setting image source:', e);\n    }\n  };\n\n  // Update preview with base64 encoded cropped image data\n  const updateCropPreviewWithBase64Image = base64Data => {\n    if (!base64Data) {\n      console.error('Cannot update crop preview: missing base64 data');\n      return;\n    }\n\n    // Set the preview image data\n    setCropPreviewImage(`data:image/jpeg;base64,${base64Data}`);\n  };\n\n  // Clean up on component unmount\n  useEffect(() => {\n    return () => {\n      stopStreaming();\n      stopCropStreaming();\n      disconnectFromMqtt();\n    };\n  }, []);\n\n  // Initialize canvas size when video size changes\n  useEffect(() => {\n    if (canvasRef.current) {\n      canvasRef.current.width = cameraSize.width;\n      canvasRef.current.height = cameraSize.height;\n\n      // If line is drawn, redraw it when canvas size changes\n      if (isLineDrawn) {\n        // Ensure the redraw happens after the canvas size is updated\n        // by using a small timeout\n        setTimeout(() => {\n          redrawCanvas(); // Use redrawCanvas which handles coordinates\n\n          // Double-check with another redraw after a slight delay\n          setTimeout(() => redrawCanvas(), 100);\n        }, 0);\n      }\n    }\n  }, [cameraSize.width, cameraSize.height, isLineDrawn]);\n\n  // Effect for continuous redrawing of the canvas (image + line)\n  useEffect(() => {\n    let animationId;\n\n    // Function to continuously redraw the canvas (image + line)\n    const redrawLoop = () => {\n      if (canvasRef.current) {\n        redrawCanvas();\n      }\n      animationId = requestAnimationFrame(redrawLoop);\n    };\n\n    // Start animation loop if camera is active\n    if (isCameraActive || isLineDrawn) {\n      animationId = requestAnimationFrame(redrawLoop);\n      console.debug(\"[Animation] Starting redraw loop\");\n    }\n\n    // Cleanup function\n    return () => {\n      if (animationId) {\n        console.debug(\"[Animation] Stopping redraw loop\");\n        cancelAnimationFrame(animationId);\n      }\n    };\n  }, [isCameraActive, isLineDrawn]); // Re-run when camera activity or line drawing state changes\n\n  // Start camera stream (now connects to MQTT)\n  const startCamera = async () => {\n    return connectToMqttAndStartStreaming();\n  };\n\n  // Stop camera stream (now disconnects from MQTT)\n  const stopCamera = () => {\n    disconnectFromMqtt();\n  };\n\n  // Function to send the line update to the backend\n  const sendLineUpdate = line => {\n    if (mqttClient && mqttClient.readyState === WebSocket.OPEN && line) {\n      // Ensure we have valid coordinates\n      if (!line.start || !line.end) {\n        console.warn('Invalid line coordinates:', line);\n        return;\n      }\n\n      // Send integer coordinates\n      const payload = {\n        start_x: Math.round(line.start.x),\n        end_x: Math.round(line.end.x),\n        y: Math.round(line.start.y) // Y is the same for start and end since line is horizontal\n      };\n      const message = {\n        topic: `${mqttTopic}/request/set_line`,\n        payload: payload\n      };\n      console.log(\"Sending line update:\", message);\n      mqttClient.send(JSON.stringify(message));\n      setLastPublishedMessage(message);\n    } else {\n      console.warn('Cannot send line update: WebSocket not connected or line not defined.', {\n        wsState: mqttClient === null || mqttClient === void 0 ? void 0 : mqttClient.readyState,\n        line: line\n      });\n    }\n  };\n\n  // Calculate the current line position with offsets applied\n  const calculateTransformedLinePosition = () => {\n    if (!originalLineStart || !originalLineEnd) return null;\n\n    // Return the original line coordinates with any offsets applied\n    return {\n      start: {\n        x: originalLineStart.x,\n        y: originalLineStart.y\n      },\n      end: {\n        x: originalLineEnd.x,\n        y: originalLineEnd.y\n      }\n    };\n  };\n\n  // Handle line Y-offset adjustment\n  const handleLineYOffsetChange = e => {\n    const newOffset = parseInt(e.target.value);\n    setLineYOffset(newOffset);\n    // Send update only on adjustment, not during initial draw\n    if (isLineDrawn && originalLineStart && originalLineEnd) {\n      const newLine = calculateTransformedLinePosition(originalLineStart, originalLineEnd, newOffset, lineXOffset);\n      // Force redraw immediately to improve responsiveness\n      redrawCanvas();\n      sendLineUpdate(newLine);\n    }\n  };\n\n  // Handle line X-offset adjustment\n  const handleLineXOffsetChange = e => {\n    const newOffset = parseInt(e.target.value);\n    setLineXOffset(newOffset);\n    // Send update only on adjustment, not during initial draw\n    if (isLineDrawn && originalLineStart && originalLineEnd) {\n      const newLine = calculateTransformedLinePosition(originalLineStart, originalLineEnd, lineYOffset, newOffset);\n      // Force redraw immediately to improve responsiveness  \n      redrawCanvas();\n      sendLineUpdate(newLine);\n    }\n  };\n\n  // Convert canvas coordinates to relative image coordinates\n  const getRelativeImageCoordinates = event => {\n    if (!canvasRef.current || !imageRef.current) return null;\n    const canvas = canvasRef.current;\n    const image = imageRef.current;\n    const rect = canvas.getBoundingClientRect();\n\n    // Get click coordinates relative to canvas\n    const canvasX = event.clientX - rect.left;\n    const canvasY = event.clientY - rect.top;\n\n    // Calculate scale factors\n    const scaleX = image.naturalWidth / rect.width;\n    const scaleY = image.naturalHeight / rect.height;\n    const imageX = Math.round(canvasX * scaleX);\n    const imageY = Math.round(canvasY * scaleY);\n\n    // Add 2px margin to boundaries\n    const margin = 2;\n    if (imageX < margin || imageX > image.naturalWidth - margin || imageY < margin || imageY > image.naturalHeight - margin) {\n      console.warn('Click outside image boundaries');\n      return null;\n    }\n    return {\n      x: Math.round(imageX),\n      y: Math.round(imageY)\n    };\n  };\n\n  // Render camera controls\n  const renderCameraControls = () => {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      style: floatingComponentStyles.controls,\n      children: !isCameraActive ? /*#__PURE__*/_jsxDEV(\"button\", {\n        style: buttonVariants.primaryButton,\n        onClick: startCamera,\n        children: \"Connect to Device\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 946,\n        columnNumber: 11\n      }, this) : /*#__PURE__*/_jsxDEV(_Fragment, {\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          style: {\n            ...buttonVariants.primaryButton,\n            backgroundColor: 'rgba(255, 50, 50, 0.7)'\n          },\n          onClick: stopCamera,\n          children: \"Disconnect\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 954,\n          columnNumber: 13\n        }, this), isLineDrawn ? /*#__PURE__*/_jsxDEV(_Fragment, {\n          children: [/*#__PURE__*/_jsxDEV(\"button\", {\n            style: buttonVariants.smallSecondary,\n            onClick: clearLine,\n            children: \"Clear Line\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 966,\n            columnNumber: 17\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            style: buttonVariants.smallSecondary,\n            disabled: true // Disable extraction button as it's now handled by backend\n            ,\n            title: \"Data extraction handled by backend\",\n            children: \"Extract (Backend)\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 972,\n            columnNumber: 17\n          }, this)]\n        }, void 0, true) : /*#__PURE__*/_jsxDEV(\"button\", {\n          style: buttonVariants.smallSecondary,\n          disabled: isDrawing,\n          title: \"Click and drag on video to draw a line\",\n          children: \"Draw Line\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 981,\n          columnNumber: 15\n        }, this)]\n      }, void 0, true)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 943,\n      columnNumber: 7\n    }, this);\n  };\n\n  // Clear the drawn line\n  const clearLine = () => {\n    setIsLineDrawn(false);\n    setIsDrawing(false);\n    setCurrentLine(null);\n\n    // Send message to backend to clear the line (optional, or send invalid coords)\n    sendLineUpdate({\n      start: {\n        x: -1,\n        y: -1\n      },\n      end: {\n        x: -1,\n        y: -1\n      }\n    }); // Send dummy coords\n\n    // Clear canvas\n    if (canvasRef.current) {\n      const ctx = canvasRef.current.getContext('2d');\n      ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);\n      // Need to redraw the image after clearing\n      if (imageRef.current) {\n        redrawCanvas();\n      }\n    }\n  };\n\n  // Start line drawing on mouse down\n  const startLineDrawing = event => {\n    if (!canvasRef.current || !imageRef.current) return;\n    const coords = getRelativeImageCoordinates(event);\n    if (!coords) {\n      console.warn('Invalid start coordinates');\n      return;\n    }\n    setIsDrawing(true);\n    setCurrentLine({\n      start: coords,\n      end: coords\n    });\n    console.log('Started line at:', coords);\n  };\n\n  // Update line drawing on mouse move\n  const updateLineDrawing = event => {\n    if (!isDrawing || !canvasRef.current || !imageRef.current) return;\n    const coords = getRelativeImageCoordinates(event);\n    if (!coords) {\n      console.warn('Invalid move coordinates');\n      return;\n    }\n\n    // Force horizontal line by keeping Y coordinate the same as start\n    coords.y = currentLine.start.y;\n    setCurrentLine(prev => ({\n      ...prev,\n      end: coords\n    }));\n    redrawCanvas();\n  };\n\n  // Finish line drawing on mouse up\n  const finishLineDrawing = event => {\n    if (!isDrawing || !canvasRef.current || !imageRef.current) return;\n    const coords = getRelativeImageCoordinates(event);\n    if (!coords) {\n      console.warn('Invalid end coordinates');\n      setIsDrawing(false);\n      setCurrentLine(null);\n      return;\n    }\n\n    // Force horizontal line\n    coords.y = currentLine.start.y;\n    const finalLine = {\n      start: currentLine.start,\n      end: coords\n    };\n\n    // Calculate distance\n    const distance = Math.abs(finalLine.end.x - finalLine.start.x);\n    console.log('Line distance:', distance, 'px');\n    if (distance < MIN_LINE_LENGTH) {\n      console.warn(`Line too short (distance: ${distance}px). Clearing.`);\n      setIsDrawing(false);\n      setCurrentLine(null);\n      redrawCanvas();\n      return;\n    }\n\n    // Ensure start_x is always less than end_x\n    if (finalLine.start.x > finalLine.end.x) {\n      const temp = finalLine.start;\n      finalLine.start = finalLine.end;\n      finalLine.end = temp;\n    }\n    console.log('Finished line:', finalLine);\n    setIsDrawing(false);\n    setCurrentLine(finalLine);\n    sendLineUpdate(finalLine);\n    redrawCanvas();\n  };\n\n  // Handle resize start\n  const handleResizeStart = e => {\n    e.preventDefault();\n    e.stopPropagation();\n    const startX = e.clientX;\n    const startY = e.clientY;\n    const startWidth = cameraSize.width;\n    const startHeight = cameraSize.height;\n    setIsResizing(true);\n    setShowResizeInfo(true);\n    const handleMouseMove = moveEvent => {\n      const deltaX = moveEvent.clientX - startX;\n\n      // Calculate new width, constrained to minimum of 320px\n      const newWidth = Math.max(320, startWidth + deltaX);\n\n      // Calculate height based on aspect ratio\n      const newHeight = Math.round(newWidth / imageAspectRatio);\n      setCameraSize({\n        width: newWidth,\n        height: newHeight\n      });\n\n      // Notify parent if onResize callback is provided\n      if (onResize) {\n        onResize({\n          width: newWidth,\n          height: newHeight\n        });\n      }\n      moveEvent.preventDefault();\n    };\n    const handleMouseUp = () => {\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n      setIsResizing(false);\n      setTimeout(() => setShowResizeInfo(false), 1000);\n    };\n    document.addEventListener('mousemove', handleMouseMove);\n    document.addEventListener('mouseup', handleMouseUp);\n  };\n\n  // Helper function to try extracting and displaying image data from various message formats\n  const tryExtractAndShowImage = data => {\n    try {\n      // Check multiple potential payload locations\n      let imageData = null;\n      let imagePayload = null;\n\n      // Case 1: data.payload is an object with image property\n      if (data.payload && typeof data.payload === 'object' && data.payload.image) {\n        imageData = data.payload.image;\n        imagePayload = data.payload;\n      }\n      // Case 2: data.payload is a string that might be JSON\n      else if (data.payload && typeof data.payload === 'string') {\n        try {\n          const parsedPayload = JSON.parse(data.payload);\n          if (parsedPayload && parsedPayload.image) {\n            imageData = parsedPayload.image;\n            imagePayload = parsedPayload;\n          }\n        } catch (e) {\n          // Silent catch - not valid JSON\n        }\n      }\n      // Case 3: data itself has an image property\n      else if (data.image) {\n        imageData = data.image;\n        imagePayload = data;\n      }\n      if (imageData) {\n        setLastMqttResponse(imagePayload);\n        updateVideoWithBase64Image(imageData);\n        return true;\n      } else {\n        return false;\n      }\n    } catch (err) {\n      console.error('Error trying to extract image data:', err);\n      return false;\n    }\n  };\n\n  // State variables for camera settings\n  const [cropToGraph, setCropToGraph] = useState(false);\n  const [streamCropImage, setStreamCropImage] = useState(true); // Default to true for backward compatibility\n  const [sendFullData, setSendFullData] = useState(false); // Add state for full data checkbox\n\n  // Import spectral_config.json for wavelength channel ranges\n  useEffect(() => {\n    import('./SpectrometerMQTT/spectral_config.json').then(config => {\n      console.log(\"[MQTTCamera] Loaded spectral_config.json:\", config);\n    }).catch(err => {\n      console.error(\"[MQTTCamera] Error loading spectral_config.json:\", err);\n    });\n  }, []);\n\n  // Function to calculate pixel ranges based on wavelength ranges\n  const calculateWavelengthToPixelRanges = calibrationPoints => {\n    try {\n      // Try to import spectral_config.json\n      const spectralConfig = require('./SpectrometerMQTT/spectral_config.json');\n      const channelRanges = spectralConfig.CHANNEL_RANGES;\n\n      // If calibration points aren't available, return null\n      if (!calibrationPoints || calibrationPoints.length < 2) {\n        console.warn(\"[MQTTCamera] Not enough calibration points to calculate wavelength ranges\");\n        return null;\n      }\n\n      // Extract calibration data from calibration points\n      const point1 = calibrationPoints[0];\n      const point2 = calibrationPoints[1];\n\n      // Calculate linear relationship between pixel position and wavelength\n      const pixelToWavelengthSlope = (point2.wavelength - point1.wavelength) / (point2.position - point1.position);\n      const pixelToWavelengthIntercept = point1.wavelength - pixelToWavelengthSlope * point1.position;\n\n      // Function to convert wavelength to pixel position\n      const wavelengthToPixel = wavelength => {\n        return (wavelength - pixelToWavelengthIntercept) / pixelToWavelengthSlope;\n      };\n\n      // Calculate pixel ranges for each channel\n      const pixelRanges = {\n        r: [Math.round(wavelengthToPixel(channelRanges.r[0])), Math.round(wavelengthToPixel(channelRanges.r[1]))],\n        g: [Math.round(wavelengthToPixel(channelRanges.g[0])), Math.round(wavelengthToPixel(channelRanges.g[1]))],\n        b: [Math.round(wavelengthToPixel(channelRanges.b[0])), Math.round(wavelengthToPixel(channelRanges.b[1]))]\n      };\n      console.log(\"[MQTTCamera] Calculated pixel ranges:\", pixelRanges);\n      return pixelRanges;\n    } catch (error) {\n      console.error(\"[MQTTCamera] Error calculating wavelength to pixel ranges:\", error);\n      return null;\n    }\n  };\n\n  // Start crop frame streaming - Modified to include pixel ranges for wavelength filtering\n  const startCropStreaming = () => {\n    if (!mqttClient || mqttClient.readyState !== WebSocket.OPEN) {\n      console.error('Cannot start crop streaming: WebSocket not connected');\n      return;\n    }\n    if (!cropRange || cropRange.every(val => val === 0)) {\n      console.error('Cannot start crop streaming: No crop region defined');\n      return;\n    }\n\n    // Stop any existing crop interval\n    stopCropStreaming();\n\n    // If we're starting crop streaming, stop full frame streaming\n    if (intervalRef.current) {\n      clearInterval(intervalRef.current);\n      intervalRef.current = null;\n    }\n\n    // Get pixel ranges for RGB channels from calibration if available\n    let pixelRanges = null;\n\n    // Try to get calibration from graph component via parent ref\n    if (!sendFullData && props.graphRef && props.graphRef.current && props.graphRef.current.getCalibrationSettings) {\n      try {\n        const calibrationSettings = props.graphRef.current.getCalibrationSettings();\n        pixelRanges = calculateWavelengthToPixelRanges(calibrationSettings.calibrationPoints);\n      } catch (error) {\n        console.warn(\"[MQTTCamera] Error getting calibration settings:\", error);\n      }\n    }\n\n    // Send crop request with interval in the payload - server will handle streaming\n    const message = {\n      topic: `${mqttTopic}/request/crop_frame`,\n      payload: {\n        interval: cropInterval,\n        // Pass actual interval to server\n        crop_range: cropRange,\n        to_graph: cropToGraph,\n        // Add flag to indicate if the crop should be processed for graph\n        stream_image: streamCropImage,\n        // Add flag to indicate if the image should be sent\n        full_data: sendFullData,\n        // Add flag to indicate if full data should be sent\n        pixel_ranges: pixelRanges // Add pixel ranges for wavelength filtering\n      }\n    };\n    console.log(`Starting crop streaming with interval ${cropInterval}ms`, message);\n    mqttClient.send(JSON.stringify(message));\n    setLastPublishedMessage(message);\n\n    // Set streaming state if interval > 0 and we want to stream images\n    if (cropInterval > 0 && (streamCropImage || cropToGraph)) {\n      setIsCropStreaming(true);\n      setIsWaitingForCropResponse(true);\n    } else {\n      // Single frame request\n      setIsWaitingForCropResponse(true);\n    }\n  };\n\n  // Stop crop frame streaming\n  const stopCropStreaming = () => {\n    if (cropIntervalRef.current) {\n      clearInterval(cropIntervalRef.current);\n      cropIntervalRef.current = null;\n    }\n    if (mqttClient && mqttClient.readyState === WebSocket.OPEN) {\n      // Send message to stop streaming (interval=0)\n      const message = {\n        topic: `${mqttTopic}/request/crop_frame`,\n        payload: {\n          interval: 0,\n          crop_range: cropRange\n        }\n      };\n      mqttClient.send(JSON.stringify(message));\n      setLastPublishedMessage(message);\n    }\n    setIsCropStreaming(false);\n    setIsWaitingForCropResponse(false); // Reset waiting state when stopping\n  };\n\n  // Convert crop points to crop range\n  const pointsToCropRange = (start, end) => {\n    if (!start || !end) return [0, 0, 0, 0];\n\n    // Ensure start is top-left and end is bottom-right\n    const x_min = Math.min(start.x, end.x);\n    const y_min = Math.min(start.y, end.y);\n    const x_max = Math.max(start.x, end.x);\n    const y_max = Math.max(start.y, end.y);\n    return [x_min, y_min, x_max, y_max];\n  };\n\n  // Handle crop start (mousedown)\n  const startCropDrawing = event => {\n    if (!isCropMode || !canvasRef.current || !imageRef.current) return;\n    event.preventDefault();\n    const coords = getRelativeImageCoordinates(event);\n    if (!coords) return;\n    setIsDrawingCrop(true);\n    setCropStart(coords);\n    setCropEnd(coords);\n  };\n\n  // Handle crop update (mousemove)\n  const updateCropDrawing = event => {\n    if (!isDrawingCrop || !isCropMode) return;\n    event.preventDefault();\n    const coords = getRelativeImageCoordinates(event);\n    if (!coords) return;\n    setCropEnd(coords);\n\n    // Update the crop range during drawing\n    setCropRange(pointsToCropRange(cropStart, coords));\n\n    // Redraw canvas to show current crop rectangle\n    redrawCanvas();\n  };\n\n  // Handle crop end (mouseup)\n  const finishCropDrawing = event => {\n    if (!isDrawingCrop || !isCropMode) return;\n    event.preventDefault();\n    const coords = getRelativeImageCoordinates(event);\n    if (!coords) {\n      setIsDrawingCrop(false);\n      return;\n    }\n    setCropEnd(coords);\n\n    // Calculate final crop range\n    const newCropRange = pointsToCropRange(cropStart, coords);\n\n    // Check if crop size is valid\n    const width = newCropRange[2] - newCropRange[0];\n    const height = newCropRange[3] - newCropRange[1];\n    if (width < MIN_CROP_SIZE || height < MIN_CROP_SIZE) {\n      console.warn(`Crop rectangle too small (${width}x${height}px). Minimum size is ${MIN_CROP_SIZE}x${MIN_CROP_SIZE}px.`);\n      setIsDrawingCrop(false);\n      // Reset crop\n      setCropStart(null);\n      setCropEnd(null);\n      setCropRange([0, 0, 0, 0]);\n      redrawCanvas();\n      return;\n    }\n\n    // Set the final crop range\n    setCropRange(newCropRange);\n    setIsDrawingCrop(false);\n\n    // Request a single cropped frame to preview\n    requestCroppedFrame(newCropRange);\n\n    // Redraw to show the final crop rectangle\n    redrawCanvas();\n  };\n\n  // Modify requestCroppedFrame to include the same pixel ranges\n  const requestCroppedFrame = range => {\n    if (!mqttClient || mqttClient.readyState !== WebSocket.OPEN) return;\n\n    // Get pixel ranges for RGB channels from calibration if available\n    let pixelRanges = null;\n\n    // Try to get calibration from graph component via parent ref\n    if (!sendFullData && props.graphRef && props.graphRef.current && props.graphRef.current.getCalibrationSettings) {\n      try {\n        const calibrationSettings = props.graphRef.current.getCalibrationSettings();\n        pixelRanges = calculateWavelengthToPixelRanges(calibrationSettings.calibrationPoints);\n      } catch (error) {\n        console.warn(\"[MQTTCamera] Error getting calibration settings:\", error);\n      }\n    }\n    const message = {\n      topic: `${mqttTopic}/request/crop_frame`,\n      payload: {\n        interval: 0,\n        // Single frame\n        crop_range: range,\n        to_graph: cropToGraph,\n        // Add flag to indicate if the crop should be processed for graph\n        stream_image: streamCropImage,\n        // Add flag to indicate if the image should be sent\n        full_data: sendFullData,\n        // Add flag to indicate if full data should be sent\n        pixel_ranges: pixelRanges // Add pixel ranges for wavelength filtering\n      }\n    };\n    mqttClient.send(JSON.stringify(message));\n    setLastPublishedMessage(message);\n    setIsWaitingForCropResponse(true);\n  };\n\n  // Handle manual crop range input change\n  const handleCropRangeChange = (index, value) => {\n    const newCropRange = [...cropRange];\n    newCropRange[index] = parseInt(value) || 0;\n\n    // Ensure min <= max\n    if (index === 0 && newCropRange[0] > newCropRange[2]) {\n      newCropRange[2] = newCropRange[0];\n    }\n    if (index === 1 && newCropRange[1] > newCropRange[3]) {\n      newCropRange[3] = newCropRange[1];\n    }\n    if (index === 2 && newCropRange[2] < newCropRange[0]) {\n      newCropRange[0] = newCropRange[2];\n    }\n    if (index === 3 && newCropRange[3] < newCropRange[1]) {\n      newCropRange[1] = newCropRange[3];\n    }\n    setCropRange(newCropRange);\n    redrawCanvas();\n  };\n\n  // Toggle crop mode\n  const toggleCropMode = () => {\n    const newCropMode = !isCropMode;\n    setIsCropMode(newCropMode);\n    if (!newCropMode) {\n      // Exiting crop mode, clean up and restart full frame streaming\n      setIsDrawingCrop(false);\n      stopCropStreaming();\n\n      // Restart full frame streaming if camera is active\n      if (isCameraActive && mqttClient && mqttClient.readyState === WebSocket.OPEN) {\n        startStreaming(mqttClient);\n      }\n    } else {\n      // Entering crop mode, stop full frame streaming\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n        intervalRef.current = null;\n      }\n      // Stop line drawing if active\n      setIsDrawing(false);\n    }\n    redrawCanvas();\n  };\n\n  // Reset crop\n  const resetCrop = () => {\n    setCropStart(null);\n    setCropEnd(null);\n    setCropRange([0, 0, 0, 0]);\n    setCropPreviewImage(null);\n    stopCropStreaming();\n    redrawCanvas();\n  };\n\n  // Render crop controls - modified to add \"full data\" checkbox\n  const renderCropControls = () => {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      style: floatingComponentStyles.cropControls,\n      children: [/*#__PURE__*/_jsxDEV(\"h4\", {\n        style: floatingComponentStyles.cropTitle,\n        children: \"Crop Frame Settings\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1523,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: floatingComponentStyles.cropInputGroup,\n        children: [/*#__PURE__*/_jsxDEV(\"label\", {\n          style: floatingComponentStyles.cropLabel,\n          children: \"X Min:\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1526,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"number\",\n          value: cropRange[0],\n          onChange: e => handleCropRangeChange(0, e.target.value),\n          style: floatingComponentStyles.cropInput,\n          disabled: !isCameraActive\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1527,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"label\", {\n          style: floatingComponentStyles.cropLabel,\n          children: \"Y Min:\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1535,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"number\",\n          value: cropRange[1],\n          onChange: e => handleCropRangeChange(1, e.target.value),\n          style: floatingComponentStyles.cropInput,\n          disabled: !isCameraActive\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1536,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1525,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: floatingComponentStyles.cropInputGroup,\n        children: [/*#__PURE__*/_jsxDEV(\"label\", {\n          style: floatingComponentStyles.cropLabel,\n          children: \"X Max:\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1546,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"number\",\n          value: cropRange[2],\n          onChange: e => handleCropRangeChange(2, e.target.value),\n          style: floatingComponentStyles.cropInput,\n          disabled: !isCameraActive\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1547,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"label\", {\n          style: floatingComponentStyles.cropLabel,\n          children: \"Y Max:\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1555,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"number\",\n          value: cropRange[3],\n          onChange: e => handleCropRangeChange(3, e.target.value),\n          style: floatingComponentStyles.cropInput,\n          disabled: !isCameraActive\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1556,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1545,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: floatingComponentStyles.cropInputGroup,\n        children: [/*#__PURE__*/_jsxDEV(\"label\", {\n          style: floatingComponentStyles.cropLabel,\n          children: \"Interval (ms):\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1566,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"number\",\n          value: cropInterval,\n          onChange: e => setCropInterval(parseInt(e.target.value) || 0),\n          style: floatingComponentStyles.cropInput,\n          min: \"0\",\n          step: \"100\",\n          disabled: !isCameraActive\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1567,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: floatingComponentStyles.cropHint,\n          children: \"0 = single capture\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1576,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1565,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: floatingComponentStyles.cropButtonGroup,\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          style: buttonVariants.smallSecondary,\n          onClick: toggleCropMode,\n          disabled: !isCameraActive,\n          children: isCropMode ? 'Exit Crop Mode' : 'Enter Crop Mode'\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1582,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          style: buttonVariants.smallSecondary,\n          onClick: resetCrop,\n          disabled: !isCameraActive || cropRange.every(val => val === 0),\n          children: \"Reset Crop\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1590,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1581,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: floatingComponentStyles.checkboxGroup,\n        children: [/*#__PURE__*/_jsxDEV(\"label\", {\n          style: floatingComponentStyles.checkboxLabel,\n          children: [/*#__PURE__*/_jsxDEV(\"input\", {\n            type: \"checkbox\",\n            checked: streamCropImage,\n            onChange: e => setStreamCropImage(e.target.checked),\n            style: floatingComponentStyles.checkbox,\n            disabled: !isCameraActive\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1601,\n            columnNumber: 13\n          }, this), \"Stream Image\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1600,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"label\", {\n          style: floatingComponentStyles.checkboxLabel,\n          children: [/*#__PURE__*/_jsxDEV(\"input\", {\n            type: \"checkbox\",\n            checked: cropToGraph,\n            onChange: e => setCropToGraph(e.target.checked),\n            style: floatingComponentStyles.checkbox,\n            disabled: !isCameraActive\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1612,\n            columnNumber: 13\n          }, this), \"To Graph\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1611,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"label\", {\n          style: floatingComponentStyles.checkboxLabel,\n          children: [/*#__PURE__*/_jsxDEV(\"input\", {\n            type: \"checkbox\",\n            checked: sendFullData,\n            onChange: e => setSendFullData(e.target.checked),\n            style: floatingComponentStyles.checkbox,\n            disabled: !isCameraActive\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1623,\n            columnNumber: 13\n          }, this), \"Full Data\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1622,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1599,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: floatingComponentStyles.cropButtonGroup,\n        children: !isCropStreaming ? /*#__PURE__*/_jsxDEV(\"button\", {\n          style: buttonVariants.smallPrimary,\n          onClick: startCropStreaming,\n          disabled: !isCameraActive || cropRange.every(val => val === 0) || !streamCropImage && !cropToGraph,\n          children: cropInterval > 0 ? 'Start Streaming' : 'Capture Frame'\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1636,\n          columnNumber: 13\n        }, this) : /*#__PURE__*/_jsxDEV(\"button\", {\n          style: {\n            ...buttonVariants.smallPrimary,\n            backgroundColor: 'rgba(255, 50, 50, 0.7)'\n          },\n          onClick: stopCropStreaming,\n          children: \"Stop Streaming\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1644,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1634,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1522,\n      columnNumber: 7\n    }, this);\n  };\n\n  // Render crop preview\n  const renderCropPreview = () => {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      style: floatingComponentStyles.cropPreviewContainer,\n      children: [/*#__PURE__*/_jsxDEV(\"h4\", {\n        style: floatingComponentStyles.cropTitle,\n        children: \"Crop Preview\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1660,\n        columnNumber: 9\n      }, this), cropPreviewImage ? /*#__PURE__*/_jsxDEV(\"img\", {\n        src: cropPreviewImage,\n        alt: \"Cropped preview\",\n        style: floatingComponentStyles.cropPreviewImage\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1662,\n        columnNumber: 11\n      }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n        style: floatingComponentStyles.cropPreviewPlaceholder,\n        children: \"No crop preview available\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1668,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1659,\n      columnNumber: 7\n    }, this);\n  };\n\n  // Function to render the configuration menu\n  const renderConfigMenu = () => {\n    // Handler for input changes within the config menu\n    const handleConfigChange = (section, key, value) => {\n      setPendingConfig(prev => {\n        const newConfig = JSON.parse(JSON.stringify(prev)); // Deep copy\n        if (section === 'roi') {\n          // ROI is an array [x, y, w, h]\n          const roiIndex = {\n            'x': 0,\n            'y': 1,\n            'w': 2,\n            'h': 3\n          }[key];\n          newConfig.processing.roi[roiIndex] = parseInt(value) || 0;\n        } else {\n          newConfig[section][key] = value;\n        }\n\n        // Trigger redraw immediately after ROI change\n        if (section === 'roi') {\n          requestAnimationFrame(redrawCanvas);\n        }\n        return newConfig;\n      });\n    };\n\n    // Handler to send config update\n    const applyConfigChanges = () => {\n      if (pendingConfig) {\n        sendCameraConfigUpdate(pendingConfig);\n      }\n    };\n    if (!pendingConfig) {\n      return /*#__PURE__*/_jsxDEV(\"div\", {\n        children: \"Loading configuration...\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1706,\n        columnNumber: 14\n      }, this); // Or some loading indicator\n    }\n    const roi = pendingConfig.processing.roi || [0, 0, 0, 0];\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      style: floatingComponentStyles.configMenuContainer,\n      children: [/*#__PURE__*/_jsxDEV(\"h4\", {\n        children: \"Camera Configuration\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1713,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: floatingComponentStyles.configRow,\n        children: [/*#__PURE__*/_jsxDEV(\"label\", {\n          style: floatingComponentStyles.configLabel,\n          children: \"Exposure Time (\\u03BCs):\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1717,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"number\",\n          value: pendingConfig.camera.exposure_time || '',\n          onChange: e => handleConfigChange('camera', 'exposure_time', e.target.value),\n          style: floatingComponentStyles.configInput,\n          disabled: pendingConfig.camera.exposure_mode !== 'manual'\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1718,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1716,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: floatingComponentStyles.configRow,\n        children: [/*#__PURE__*/_jsxDEV(\"label\", {\n          style: floatingComponentStyles.configLabel,\n          children: \"Exposure Mode:\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1727,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"select\", {\n          value: pendingConfig.camera.exposure_mode || 'auto',\n          onChange: e => handleConfigChange('camera', 'exposure_mode', e.target.value),\n          style: floatingComponentStyles.configInput,\n          children: [/*#__PURE__*/_jsxDEV(\"option\", {\n            value: \"auto\",\n            children: \"Auto\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1733,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n            value: \"manual\",\n            children: \"Manual\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1734,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1728,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1726,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: floatingComponentStyles.configRow,\n        children: [/*#__PURE__*/_jsxDEV(\"label\", {\n          style: floatingComponentStyles.configLabel,\n          children: \"ISO:\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1740,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"number\",\n          value: pendingConfig.camera.iso || '' // Handle null case\n          ,\n          onChange: e => handleConfigChange('camera', 'iso', e.target.value ? parseInt(e.target.value) : null) // Send null if empty\n          ,\n          style: floatingComponentStyles.configInput,\n          min: \"100\" // Example range, adjust as needed\n          ,\n          max: \"1600\",\n          step: \"100\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1741,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1739,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        style: {\n          ...buttonVariants.smallPrimary,\n          marginTop: '10px'\n        },\n        onClick: applyConfigChanges,\n        children: \"Apply Configuration\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1752,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1712,\n      columnNumber: 7\n    }, this);\n  };\n\n  // Function to send camera configuration update via MQTT\n  const sendCameraConfigUpdate = configToSend => {\n    if (mqttClient && mqttClient.readyState === WebSocket.OPEN) {\n      const message = {\n        topic: `${mqttTopic}/request/set_config`,\n        // Assuming this is the topic the backend listens on\n        payload: configToSend\n      };\n      console.log(\"Sending config update:\", message);\n      mqttClient.send(JSON.stringify(message));\n      setLastPublishedMessage(message);\n      // Optional: Maybe reset pendingConfig or wait for confirmation?\n    } else {\n      console.error('Cannot send config: WebSocket not connected');\n    }\n  };\n\n  // Centralized drawing function\n  const redrawCanvas = () => {\n    if (!canvasRef.current || !imageRef.current) return;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    const image = imageRef.current;\n\n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Draw image\n    ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n\n    // Draw line if we have valid coordinates\n    if (currentLine && currentLine.start && currentLine.end) {\n      ctx.beginPath();\n      ctx.moveTo(currentLine.start.x, currentLine.start.y);\n      ctx.lineTo(currentLine.end.x, currentLine.end.y);\n      ctx.strokeStyle = 'red';\n      ctx.lineWidth = 1;\n      ctx.stroke();\n    }\n\n    // Draw crop rectangle if in crop mode and we have valid coordinates\n    if (isCropMode && cropRange && cropRange.some(val => val !== 0)) {\n      const [x_min, y_min, x_max, y_max] = cropRange;\n\n      // Draw rectangle\n      ctx.beginPath();\n      ctx.rect(x_min, y_min, x_max - x_min, y_max - y_min);\n\n      // Use green while drawing, yellow when set\n      if (isDrawingCrop) {\n        ctx.strokeStyle = 'green';\n        ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';\n      } else {\n        ctx.strokeStyle = 'yellow';\n        ctx.fillStyle = 'rgba(255, 255, 0, 0.1)';\n      }\n      ctx.lineWidth = 2;\n      ctx.stroke();\n\n      // Semi-transparent fill\n      ctx.fill();\n\n      // Draw corner markers\n      const markerSize = 5;\n      ctx.fillStyle = isDrawingCrop ? 'green' : 'yellow';\n\n      // Top-left\n      ctx.fillRect(x_min - markerSize, y_min - markerSize, markerSize * 2, markerSize * 2);\n      // Top-right\n      ctx.fillRect(x_max - markerSize, y_min - markerSize, markerSize * 2, markerSize * 2);\n      // Bottom-left\n      ctx.fillRect(x_min - markerSize, y_max - markerSize, markerSize * 2, markerSize * 2);\n      // Bottom-right\n      ctx.fillRect(x_max - markerSize, y_max - markerSize, markerSize * 2, markerSize * 2);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: floatingComponentStyles.container,\n    children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n      style: floatingComponentStyles.title,\n      children: \"Spectrometer Feed\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1842,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: floatingComponentStyles.mqttInputs,\n      children: [/*#__PURE__*/_jsxDEV(\"label\", {\n        style: floatingComponentStyles.inputLabel,\n        children: \"MQTT Topic:\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1846,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n        type: \"text\",\n        value: mqttTopic,\n        onChange: e => setMqttTopic(e.target.value),\n        style: floatingComponentStyles.input,\n        disabled: isCameraActive,\n        placeholder: \"e.g. spectrometer_1\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1847,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1845,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: floatingComponentStyles.mqttInputs,\n      children: [/*#__PURE__*/_jsxDEV(\"label\", {\n        style: floatingComponentStyles.inputLabel,\n        children: \"Poll Rate:\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1859,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n        type: \"range\",\n        min: \"100\",\n        max: \"2000\",\n        step: \"100\",\n        value: pollingInterval,\n        onChange: e => setPollingInterval(parseInt(e.target.value)),\n        style: floatingComponentStyles.slider,\n        disabled: !isCameraActive\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1860,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n        style: floatingComponentStyles.value,\n        children: [pollingInterval, \"ms\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1870,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1858,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      ref: cameraContainerRef,\n      style: floatingComponentStyles.cameraView,\n      onMouseDown: isCameraActive ? isCropMode ? startCropDrawing : startLineDrawing : undefined,\n      onMouseMove: isCameraActive ? isCropMode ? updateCropDrawing : updateLineDrawing : undefined,\n      onMouseUp: isCameraActive ? isCropMode ? finishCropDrawing : finishLineDrawing : undefined,\n      onMouseLeave: isCameraActive ? isCropMode ? finishCropDrawing : finishLineDrawing : undefined,\n      children: [!isCameraActive && /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          position: 'absolute',\n          top: '50%',\n          left: '50%',\n          transform: 'translate(-50%, -50%)',\n          color: '#999'\n        },\n        children: \"Device feed will appear here when connected\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1883,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n        ref: canvasRef,\n        style: {\n          ...floatingComponentStyles.canvas,\n          aspectRatio: `${cameraSize.width} / ${cameraSize.height}`,\n          cursor: isCameraActive ? isCropMode ? 'crosshair' : 'crosshair' : 'default'\n        },\n        width: cameraSize.width,\n        height: cameraSize.height\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1888,\n        columnNumber: 9\n      }, this), isCameraActive && !isLineDrawn && !isDrawing && !isCropMode && /*#__PURE__*/_jsxDEV(\"div\", {\n        style: floatingComponentStyles.overlayText,\n        children: \"Click and drag to draw a line\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1901,\n        columnNumber: 11\n      }, this), isCameraActive && isCropMode && !isDrawingCrop && /*#__PURE__*/_jsxDEV(\"div\", {\n        style: floatingComponentStyles.overlayText,\n        children: \"Click and drag to define crop region\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1907,\n        columnNumber: 11\n      }, this), isDrawing && /*#__PURE__*/_jsxDEV(\"div\", {\n        style: floatingComponentStyles.overlayText,\n        children: \"Drawing line...\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1914,\n        columnNumber: 11\n      }, this), isDrawingCrop && /*#__PURE__*/_jsxDEV(\"div\", {\n        style: floatingComponentStyles.overlayText,\n        children: \"Drawing crop region...\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1920,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: floatingComponentStyles.connectionStatusOverlay,\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            ...floatingComponentStyles.statusIndicator,\n            backgroundColor: isMqttConnected ? '#0f0' : '#f00'\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1927,\n          columnNumber: 11\n        }, this), isMqttConnected ? 'Connected' : 'Disconnected']\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1926,\n        columnNumber: 9\n      }, this), showResizeInfo && /*#__PURE__*/_jsxDEV(\"div\", {\n        style: floatingComponentStyles.resizeInfo,\n        children: [cameraSize.width, \" \\xD7 \", cameraSize.height]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1933,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: floatingComponentStyles.resizeHandle,\n        onMouseDown: handleResizeStart,\n        title: \"Resize camera view\",\n        children: /*#__PURE__*/_jsxDEV(\"svg\", {\n          width: \"12\",\n          height: \"12\",\n          viewBox: \"0 0 12 12\",\n          children: /*#__PURE__*/_jsxDEV(\"path\", {\n            d: \"M9,3 L3,9 M11,5 L5,11 M11,8 L8,11\",\n            stroke: \"white\",\n            strokeWidth: \"1.5\",\n            strokeLinecap: \"round\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1945,\n            columnNumber: 13\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1944,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1939,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1874,\n      columnNumber: 7\n    }, this), renderCameraControls(), /*#__PURE__*/_jsxDEV(\"button\", {\n      style: {\n        ...buttonVariants.smallSecondary,\n        marginTop: '8px'\n      },\n      onClick: () => {\n        // Initialize default config if none exists\n        if (!pendingConfig) {\n          setPendingConfig({\n            camera: {\n              exposure_time: 10000,\n              exposure_mode: 'auto',\n              iso: 100,\n              resolution: [cameraSize.width, cameraSize.height]\n            },\n            processing: {\n              roi: [0, 0, cameraSize.width, cameraSize.height]\n            }\n          });\n        }\n        setShowConfigMenu(!showConfigMenu);\n      },\n      children: showConfigMenu ? 'Hide Config' : 'Show Config'\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1959,\n      columnNumber: 7\n    }, this), showConfigMenu && renderConfigMenu(), isLineDrawn && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: floatingComponentStyles.lineControls,\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        style: floatingComponentStyles.controlRow,\n        children: [/*#__PURE__*/_jsxDEV(\"label\", {\n          style: floatingComponentStyles.controlLabel,\n          children: \"Y Offset:\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1989,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"range\",\n          min: \"-50\",\n          max: \"50\",\n          value: lineYOffset,\n          onChange: handleLineYOffsetChange,\n          style: floatingComponentStyles.slider\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1990,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n          style: floatingComponentStyles.value,\n          children: [lineYOffset, \"px\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1998,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1988,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: floatingComponentStyles.controlRow,\n        children: [/*#__PURE__*/_jsxDEV(\"label\", {\n          style: floatingComponentStyles.controlLabel,\n          children: \"X Offset:\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2002,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"range\",\n          min: \"-50\",\n          max: \"50\",\n          value: lineXOffset,\n          onChange: handleLineXOffsetChange,\n          style: floatingComponentStyles.slider\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2003,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n          style: floatingComponentStyles.value,\n          children: [lineXOffset, \"px\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 2011,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 2001,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1987,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: floatingComponentStyles.cropSection,\n      children: [renderCropControls(), renderCropPreview()]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 2017,\n      columnNumber: 7\n    }, this), debugMode && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: floatingComponentStyles.debugPanel,\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          display: 'flex',\n          justifyContent: 'space-between',\n          marginBottom: '5px'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"strong\", {\n          children: \"MQTT Debug:\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2026,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => setDebugMode(false),\n          style: floatingComponentStyles.debugHideButton,\n          children: \"Hide\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2027,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 2025,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          margin: '4px 0'\n        },\n        children: [\"Status: \", isMqttConnected ? '✅ Connected' : '❌ Disconnected']\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 2034,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          margin: '4px 0'\n        },\n        children: [\"Topic ID: \", /*#__PURE__*/_jsxDEV(\"span\", {\n          style: {\n            color: '#4CAF50'\n          },\n          children: mqttTopic\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2035,\n          columnNumber: 52\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 2035,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          margin: '4px 0'\n        },\n        children: [\"WebSocket Connection: \", /*#__PURE__*/_jsxDEV(\"span\", {\n          style: {\n            color: '#4CAF50'\n          },\n          children: WS_URL\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2036,\n          columnNumber: 64\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 2036,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          margin: '4px 0'\n        },\n        children: [\"MQTT Broker: \", mqttSettings.protocol, \"://\", mqttSettings.host, \":\", mqttSettings.port, \" (via WebSocket server)\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 2037,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          margin: '4px 0'\n        },\n        children: [\"Waiting for full frame: \", /*#__PURE__*/_jsxDEV(\"span\", {\n          style: {\n            color: isWaitingForResponse ? '#f44336' : '#4CAF50'\n          },\n          children: isWaitingForResponse ? 'Yes' : 'No'\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2041,\n          columnNumber: 37\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 2040,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          margin: '4px 0'\n        },\n        children: [\"Waiting for crop frame: \", /*#__PURE__*/_jsxDEV(\"span\", {\n          style: {\n            color: isWaitingForCropResponse ? '#f44336' : '#4CAF50'\n          },\n          children: isWaitingForCropResponse ? 'Yes' : 'No'\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2046,\n          columnNumber: 37\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 2045,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: floatingComponentStyles.debugInfoRow,\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          children: [/*#__PURE__*/_jsxDEV(\"strong\", {\n            children: \"Display:\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 2054,\n            columnNumber: 15\n          }, this), \" \", cameraSize.width, \"x\", cameraSize.height]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 2053,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          children: [/*#__PURE__*/_jsxDEV(\"strong\", {\n            children: \"Aspect Ratio:\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 2057,\n            columnNumber: 15\n          }, this), \" \", imageAspectRatio.toFixed(2)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 2056,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          children: [/*#__PURE__*/_jsxDEV(\"strong\", {\n            children: \"Resolution:\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 2060,\n            columnNumber: 15\n          }, this), \" \", cameraResolution]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 2059,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 2052,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: floatingComponentStyles.debugMessageBlock,\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          children: /*#__PURE__*/_jsxDEV(\"strong\", {\n            children: \"Last published:\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 2065,\n            columnNumber: 18\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2065,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"pre\", {\n          style: floatingComponentStyles.debugPre,\n          children: lastPublishedMessage ? JSON.stringify(lastPublishedMessage, null, 2) : 'None'\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2066,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 2064,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: floatingComponentStyles.debugMessageBlock,\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          children: /*#__PURE__*/_jsxDEV(\"strong\", {\n            children: \"Last received:\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 2071,\n            columnNumber: 18\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2071,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"pre\", {\n          style: floatingComponentStyles.debugPre,\n          children: lastReceivedMessage ? lastReceivedMessage.payload && typeof lastReceivedMessage.payload === 'object' && lastReceivedMessage.payload.image ? `${JSON.stringify({\n            ...lastReceivedMessage,\n            payload: {\n              ...lastReceivedMessage.payload,\n              image: '[Image data truncated]'\n            }\n          }, null, 2)}` : JSON.stringify(lastReceivedMessage, null, 2) : 'None'\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2072,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 2070,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 2024,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 1841,\n    columnNumber: 5\n  }, this);\n}, \"Wub7rb6c7Vyx10bVuM/Yeo4m54U=\", false, function () {\n  return [useButtonStyles];\n})), \"Wub7rb6c7Vyx10bVuM/Yeo4m54U=\", false, function () {\n  return [useButtonStyles];\n});\n\n// Add custom styles for crop features to floating component styles\n_c2 = MQTTCameraComponent;\nconst cropStyles = {\n  cropSection: {\n    display: 'flex',\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    marginTop: '15px',\n    gap: '15px'\n  },\n  cropControls: {\n    flex: '1',\n    padding: '10px',\n    backgroundColor: 'rgba(0, 0, 0, 0.05)',\n    borderRadius: '5px',\n    border: '1px solid rgba(0, 0, 0, 0.1)'\n  },\n  cropPreviewContainer: {\n    flex: '1',\n    padding: '10px',\n    backgroundColor: 'rgba(0, 0, 0, 0.05)',\n    borderRadius: '5px',\n    border: '1px solid rgba(0, 0, 0, 0.1)',\n    display: 'flex',\n    flexDirection: 'column',\n    alignItems: 'center'\n  },\n  cropTitle: {\n    margin: '0 0 10px 0',\n    fontSize: '14px',\n    fontWeight: 'bold'\n  },\n  cropInputGroup: {\n    display: 'flex',\n    alignItems: 'center',\n    marginBottom: '8px',\n    flexWrap: 'wrap'\n  },\n  cropLabel: {\n    width: '60px',\n    fontSize: '12px'\n  },\n  cropInput: {\n    width: '60px',\n    padding: '4px',\n    marginRight: '10px',\n    border: '1px solid #ccc',\n    borderRadius: '3px'\n  },\n  cropButtonGroup: {\n    display: 'flex',\n    justifyContent: 'space-between',\n    marginTop: '10px',\n    gap: '8px'\n  },\n  cropHint: {\n    fontSize: '11px',\n    color: '#666',\n    marginLeft: '5px'\n  },\n  cropPreviewImage: {\n    maxWidth: '100%',\n    maxHeight: '200px',\n    borderRadius: '3px',\n    border: '1px solid rgba(0, 0, 0, 0.2)'\n  },\n  cropPreviewPlaceholder: {\n    width: '100%',\n    height: '150px',\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'center',\n    color: '#999',\n    fontSize: '12px',\n    border: '1px dashed #ccc',\n    borderRadius: '3px'\n  },\n  toGraphLabel: {\n    display: 'flex',\n    alignItems: 'center',\n    gap: '4px',\n    fontSize: '12px',\n    color: '#fff',\n    marginLeft: '8px'\n  },\n  toGraphCheckbox: {\n    margin: 0\n  },\n  checkboxGroup: {\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    marginBottom: '10px'\n  },\n  checkboxLabel: {\n    display: 'flex',\n    alignItems: 'center',\n    gap: '4px',\n    fontSize: '12px',\n    color: '#fff',\n    cursor: 'pointer'\n  },\n  checkbox: {\n    margin: 0,\n    cursor: 'pointer'\n  }\n};\n\n// Add the crop styles to the floatingComponentStyles object\nObject.assign(floatingComponentStyles, cropStyles);\n\n// Add display name for debugging\nMQTTCameraComponent.displayName = 'MQTTCameraComponent';\nexport default MQTTCameraComponent;\nvar _c, _c2;\n$RefreshReg$(_c, \"MQTTCameraComponent$React.forwardRef\");\n$RefreshReg$(_c2, \"MQTTCameraComponent\");","map":{"version":3,"names":["React","useState","useRef","useEffect","useImperativeHandle","useButtonStyles","WS_URL","floatingComponentStyles","jsxDEV","_jsxDEV","Fragment","_Fragment","SETTINGS_STORAGE_KEY","MIN_LINE_LENGTH","MIN_CROP_SIZE","getSettingsFromStorage","settings","localStorage","getItem","JSON","parse","mqttBroker","port","error","console","MQTTCameraComponent","_s","forwardRef","_c","props","ref","onResize","detectorId","buttonVariants","cameraSize","setCameraSize","width","height","isResizing","setIsResizing","showResizeInfo","setShowResizeInfo","imageAspectRatio","setImageAspectRatio","mqttTopic","setMqttTopic","mqttClient","setMqttClient","isMqttConnected","setIsMqttConnected","lastMqttResponse","setLastMqttResponse","isStreaming","setIsStreaming","pollingInterval","setPollingInterval","intervalRef","isWaitingForResponse","setIsWaitingForResponse","isWaitingForCropResponse","setIsWaitingForCropResponse","isCameraActive","setIsCameraActive","showAdvancedCapabilities","setShowAdvancedCapabilities","cameraCapabilities","setCameraCapabilities","exposureMode","setExposureMode","isDrawing","setIsDrawing","currentLine","setCurrentLine","isLineDrawn","setIsLineDrawn","lineYOffset","setLineYOffset","lineXOffset","setLineXOffset","originalLineStart","setOriginalLineStart","x","y","originalLineEnd","setOriginalLineEnd","isCropMode","setIsCropMode","isDrawingCrop","setIsDrawingCrop","cropStart","setCropStart","cropEnd","setCropEnd","cropRange","setCropRange","cropInterval","setCropInterval","isCropStreaming","setIsCropStreaming","cropPreviewImage","setCropPreviewImage","cropIntervalRef","cameraResolution","setCameraResolution","showConfigMenu","setShowConfigMenu","cameraConfig","setCameraConfig","camera","exposure_time","exposure_mode","iso","processing","roi","pendingConfig","setPendingConfig","cameraContainerRef","canvasRef","imageRef","animationRequestRef","lastLineUpdateTimeRef","mqttSettings","setMqttSettings","savedSettings","host","protocol","clientId","Math","random","toString","substr","handleStorageChange","prev","window","addEventListener","removeEventListener","availableResolutions","setAvailableResolutions","lastPublishedMessage","setLastPublishedMessage","lastReceivedMessage","setLastReceivedMessage","debugMode","setDebugMode","log","getSettings","resolution","lineStart","lineEnd","getCropSettings","streamImage","streamCropImage","toGraph","cropToGraph","fullData","sendFullData","applyCropSettings","Array","isArray","length","some","val","setStreamCropImage","setCropToGraph","setTimeout","startCropStreaming","startCamera","connectToMqttAndStartStreaming","Promise","resolve","applySettings","shouldReconnect","split","map","Number","disconnectFromMqtt","undefined","finalLine","calculateTransformedLinePosition","sendLineUpdate","redrawCanvas","websocket","WebSocket","onopen","subscribeMessage","topic","payload","send","stringify","subscribeConfig","subscribeCroppedFrame","requestConfigMessage","timestamp","Date","now","diagnosticCheckCallback","readyState","OPEN","resubCroppedFrame","statusRequest","client_id","startStreaming","onmessage","event","rawData","data","debug","imageData","substring","parsedPayload","image","e","warn","updateCropPreviewWithBase64Image","err","configData","w","h","imgW","imgH","updateAspectRatioAndResolutions","updateVideoWithBase64Image","includes","responseData","fullEventData","toLowerCase","tryExtractAndShowImage","onerror","stopStreaming","unsubscribeMessage","close","requestFullFrame","current","setInterval","message","clearInterval","newAspectRatio","abs","baseWidths","newResolutions","round","base64Data","match","img","Image","onload","src","stopCropStreaming","animationId","redrawLoop","requestAnimationFrame","cancelAnimationFrame","stopCamera","line","start","end","start_x","end_x","wsState","handleLineYOffsetChange","newOffset","parseInt","target","value","newLine","handleLineXOffsetChange","getRelativeImageCoordinates","canvas","rect","getBoundingClientRect","canvasX","clientX","left","canvasY","clientY","top","scaleX","naturalWidth","scaleY","naturalHeight","imageX","imageY","margin","renderCameraControls","style","controls","children","primaryButton","onClick","fileName","_jsxFileName","lineNumber","columnNumber","backgroundColor","smallSecondary","clearLine","disabled","title","ctx","getContext","clearRect","startLineDrawing","coords","updateLineDrawing","finishLineDrawing","distance","temp","handleResizeStart","preventDefault","stopPropagation","startX","startY","startWidth","startHeight","handleMouseMove","moveEvent","deltaX","newWidth","max","newHeight","handleMouseUp","document","imagePayload","setSendFullData","then","config","catch","calculateWavelengthToPixelRanges","calibrationPoints","spectralConfig","require","channelRanges","CHANNEL_RANGES","point1","point2","pixelToWavelengthSlope","wavelength","position","pixelToWavelengthIntercept","wavelengthToPixel","pixelRanges","r","g","b","every","graphRef","getCalibrationSettings","calibrationSettings","interval","crop_range","to_graph","stream_image","full_data","pixel_ranges","pointsToCropRange","x_min","min","y_min","x_max","y_max","startCropDrawing","updateCropDrawing","finishCropDrawing","newCropRange","requestCroppedFrame","range","handleCropRangeChange","index","toggleCropMode","newCropMode","resetCrop","renderCropControls","cropControls","cropTitle","cropInputGroup","cropLabel","type","onChange","cropInput","step","cropHint","cropButtonGroup","checkboxGroup","checkboxLabel","checked","checkbox","smallPrimary","renderCropPreview","cropPreviewContainer","alt","cropPreviewPlaceholder","renderConfigMenu","handleConfigChange","section","key","newConfig","roiIndex","applyConfigChanges","sendCameraConfigUpdate","configMenuContainer","configRow","configLabel","configInput","marginTop","configToSend","drawImage","beginPath","moveTo","lineTo","strokeStyle","lineWidth","stroke","fillStyle","fill","markerSize","fillRect","container","mqttInputs","inputLabel","input","placeholder","slider","cameraView","onMouseDown","onMouseMove","onMouseUp","onMouseLeave","transform","color","aspectRatio","cursor","overlayText","connectionStatusOverlay","statusIndicator","resizeInfo","resizeHandle","viewBox","d","strokeWidth","strokeLinecap","lineControls","controlRow","controlLabel","cropSection","debugPanel","display","justifyContent","marginBottom","debugHideButton","debugInfoRow","toFixed","debugMessageBlock","debugPre","_c2","cropStyles","flexDirection","gap","flex","padding","borderRadius","border","alignItems","fontSize","fontWeight","flexWrap","marginRight","marginLeft","maxWidth","maxHeight","toGraphLabel","toGraphCheckbox","Object","assign","displayName","$RefreshReg$"],"sources":["E:/flow chemistry/fluidicGUI/frontend/fluidicgui/src/components/Simulation/SpectrometerMQTT/MQTTCameraComponent.js"],"sourcesContent":["import React, { useState, useRef, useEffect, useImperativeHandle } from 'react';\r\nimport { useButtonStyles } from '../../../styles/ButtonStyleProvider';\r\nimport { WS_URL } from '../../../config';\r\nimport { floatingComponentStyles } from '../../../styles/FloatingComponentStyles';\r\n\r\n// Constants for settings\r\nconst SETTINGS_STORAGE_KEY = 'fluidicgui_settings';\r\nconst MIN_LINE_LENGTH = 10; // Minimum length in pixels for a valid line\r\nconst MIN_CROP_SIZE = 1; // Minimum crop rectangle size\r\n\r\n// Helper function to get settings from localStorage\r\nconst getSettingsFromStorage = () => {\r\n  try {\r\n    const settings = localStorage.getItem(SETTINGS_STORAGE_KEY);\r\n    return settings ? JSON.parse(settings) : {\r\n      mqttBroker: 'localhost',\r\n      port: '1883'\r\n    };\r\n  } catch (error) {\r\n    console.error('Error reading settings from localStorage:', error);\r\n    return {\r\n      mqttBroker: 'localhost',\r\n      port: '1883'\r\n    };\r\n  }\r\n};\r\n\r\nconst MQTTCameraComponent = React.forwardRef((props, ref) => {\r\n  const { onResize, detectorId } = props;\r\n  const buttonVariants = useButtonStyles();\r\n  \r\n  // Camera view state\r\n  const [cameraSize, setCameraSize] = useState({ width: 640, height: 480 });\r\n  const [isResizing, setIsResizing] = useState(false);\r\n  const [showResizeInfo, setShowResizeInfo] = useState(false);\r\n  const [imageAspectRatio, setImageAspectRatio] = useState(640/480);\r\n  \r\n  // MQTT connection state\r\n  const [mqttTopic, setMqttTopic] = useState(detectorId || 'spectrometer_1');\r\n  const [mqttClient, setMqttClient] = useState(null);\r\n  const [isMqttConnected, setIsMqttConnected] = useState(false);\r\n  const [lastMqttResponse, setLastMqttResponse] = useState(null);\r\n  const [isStreaming, setIsStreaming] = useState(false);\r\n  const [pollingInterval, setPollingInterval] = useState(500);\r\n  const intervalRef = useRef(null);\r\n  const [isWaitingForResponse, setIsWaitingForResponse] = useState(false);\r\n  const [isWaitingForCropResponse, setIsWaitingForCropResponse] = useState(false);\r\n  \r\n  // Camera operation state\r\n  const [isCameraActive, setIsCameraActive] = useState(false);\r\n  const [showAdvancedCapabilities, setShowAdvancedCapabilities] = useState(false);\r\n  const [cameraCapabilities, setCameraCapabilities] = useState(null);\r\n  const [exposureMode, setExposureMode] = useState('continuous');\r\n  \r\n  // Line drawing state\r\n  const [isDrawing, setIsDrawing] = useState(false);\r\n  const [currentLine, setCurrentLine] = useState(null);\r\n  const [isLineDrawn, setIsLineDrawn] = useState(false);\r\n  \r\n  // Line adjustment state\r\n  const [lineYOffset, setLineYOffset] = useState(0);\r\n  const [lineXOffset, setLineXOffset] = useState(0);\r\n  const [originalLineStart, setOriginalLineStart] = useState({ x: 0, y: 0 });\r\n  const [originalLineEnd, setOriginalLineEnd] = useState({ x: 0, y: 0 });\r\n  \r\n  // Crop frame state\r\n  const [isCropMode, setIsCropMode] = useState(false);\r\n  const [isDrawingCrop, setIsDrawingCrop] = useState(false);\r\n  const [cropStart, setCropStart] = useState(null);\r\n  const [cropEnd, setCropEnd] = useState(null);\r\n  const [cropRange, setCropRange] = useState([0, 0, 0, 0]); // [x_min, y_min, x_max, y_max]\r\n  const [cropInterval, setCropInterval] = useState(0);\r\n  const [isCropStreaming, setIsCropStreaming] = useState(false);\r\n  const [cropPreviewImage, setCropPreviewImage] = useState(null);\r\n  const cropIntervalRef = useRef(null);\r\n  \r\n  // Camera settings\r\n  const [cameraResolution, setCameraResolution] = useState('640x480');\r\n  const [showConfigMenu, setShowConfigMenu] = useState(false);\r\n  const [cameraConfig, setCameraConfig] = useState({\r\n    camera: { exposure_time: null, exposure_mode: 'auto', iso: null },\r\n    processing: { roi: [0, 0, 1280, 720] }\r\n  });\r\n  const [pendingConfig, setPendingConfig] = useState(null);\r\n  \r\n  // Refs\r\n  const cameraContainerRef = useRef(null);\r\n  const canvasRef = useRef(null);\r\n  const imageRef = useRef(null);\r\n  const animationRequestRef = useRef(null);\r\n  const lastLineUpdateTimeRef = useRef(0);\r\n\r\n  // MQTT settings\r\n  const [mqttSettings, setMqttSettings] = useState(() => {\r\n    const savedSettings = getSettingsFromStorage();\r\n    return {\r\n      host: savedSettings.mqttBroker || 'localhost',\r\n      port: savedSettings.port || 1883,\r\n      protocol: 'ws',\r\n      clientId: `fluidic_gui_${Math.random().toString(16).substr(2, 8)}`\r\n    };\r\n  });\r\n  \r\n  // Effects to reload settings if they change in localStorage\r\n  useEffect(() => {\r\n    const handleStorageChange = () => {\r\n      const savedSettings = getSettingsFromStorage();\r\n      setMqttSettings(prev => ({\r\n        ...prev,\r\n        host: savedSettings.mqttBroker || prev.host,\r\n        port: savedSettings.port || prev.port\r\n      }));\r\n    };\r\n    \r\n    window.addEventListener('storage', handleStorageChange);\r\n    return () => window.removeEventListener('storage', handleStorageChange);\r\n  }, []);\r\n  \r\n  const [availableResolutions, setAvailableResolutions] = useState(['640x480', '800x600', '1024x768', '1280x960']);\r\n  const [lastPublishedMessage, setLastPublishedMessage] = useState(null);\r\n  const [lastReceivedMessage, setLastReceivedMessage] = useState(null);\r\n  const [debugMode, setDebugMode] = useState(true);\r\n  \r\n  // Debug log for detectorId\r\n  console.log('[MQTTCameraComponent] Initialized with detectorId:', detectorId);\r\n  \r\n  // Debug log when mqttTopic changes\r\n  useEffect(() => {\r\n    console.log('[MQTTCameraComponent] MQTT topic set to:', mqttTopic);\r\n  }, [mqttTopic]);\r\n  \r\n  // Expose methods to parent component via ref\r\n  useImperativeHandle(ref, () => ({\r\n    // Get current camera settings\r\n    getSettings: () => {\r\n      return {\r\n        mqttTopic: mqttTopic,\r\n        pollingInterval: pollingInterval,\r\n        mqttBroker: mqttSettings,\r\n        resolution: cameraResolution,\r\n        // Line drawing settings\r\n        isLineDrawn: isLineDrawn,\r\n        lineStart: originalLineStart,\r\n        lineEnd: originalLineEnd,\r\n        lineYOffset: lineYOffset,\r\n        lineXOffset: lineXOffset,\r\n        // Crop settings\r\n        cropRange: cropRange,\r\n        cropInterval: cropInterval\r\n      };\r\n    },\r\n    \r\n    // Get just the crop frame settings\r\n    getCropSettings: () => {\r\n      return {\r\n        cropRange: cropRange,\r\n        cropInterval: cropInterval,\r\n        isCropMode: isCropMode,\r\n        isCropStreaming: isCropStreaming,\r\n        streamImage: streamCropImage,\r\n        toGraph: cropToGraph,\r\n        fullData: sendFullData\r\n      };\r\n    },\r\n    \r\n    // Apply crop settings from saved config\r\n    applyCropSettings: (settings) => {\r\n      if (!settings) return false;\r\n      \r\n      try {\r\n        // Apply crop range settings\r\n        if (settings.cropRange && Array.isArray(settings.cropRange) && settings.cropRange.length === 4) {\r\n          setCropRange(settings.cropRange);\r\n          \r\n          // If crop range is valid (not all zeros), enable crop mode\r\n          if (settings.cropRange.some(val => val !== 0)) {\r\n            setIsCropMode(true);\r\n          }\r\n        }\r\n        \r\n        // Apply crop interval\r\n        if (typeof settings.cropInterval === 'number') {\r\n          setCropInterval(settings.cropInterval);\r\n        }\r\n        \r\n        // Apply stream image setting if available\r\n        if (typeof settings.streamImage === 'boolean') {\r\n          setStreamCropImage(settings.streamImage);\r\n        }\r\n        \r\n        // Apply to graph setting if available\r\n        if (typeof settings.toGraph === 'boolean') {\r\n          setCropToGraph(settings.toGraph);\r\n        }\r\n        \r\n        // Apply crop streaming state if explicitly set\r\n        if (typeof settings.isCropStreaming === 'boolean' && settings.isCropStreaming) {\r\n          // Only start streaming if we have a valid crop range and mqtt is connected\r\n          if (cropRange.some(val => val !== 0) && isMqttConnected) {\r\n            // Wait for next tick to ensure crop range is updated\r\n            setTimeout(() => {\r\n              startCropStreaming();\r\n            }, 500);\r\n          }\r\n        }\r\n        \r\n        return true;\r\n      } catch (error) {\r\n        console.error('Error applying crop settings:', error);\r\n        return false;\r\n      }\r\n    },\r\n    \r\n    // Expose startCamera method to parent\r\n    startCamera: async () => {\r\n      if (!isCameraActive) {\r\n        return connectToMqttAndStartStreaming();\r\n      }\r\n      return Promise.resolve(false);\r\n    },\r\n    \r\n    // Apply saved camera settings\r\n    applySettings: async (settings) => {\r\n      if (!settings) return false;\r\n      \r\n      // Disconnect and reconnect if topic changes\r\n      let shouldReconnect = false;\r\n      if (settings.mqttTopic && settings.mqttTopic !== mqttTopic) {\r\n          setMqttTopic(settings.mqttTopic);\r\n        shouldReconnect = true;\r\n        }\r\n        \r\n      try {\r\n        // Apply MQTT settings if provided\r\n        if (settings.pollingInterval) {\r\n          setPollingInterval(settings.pollingInterval);\r\n        }\r\n        \r\n        // Apply resolution\r\n        if (settings.resolution) {\r\n          setCameraResolution(settings.resolution);\r\n          \r\n          // Parse the resolution into width and height\r\n          const [width, height] = settings.resolution.split('x').map(Number);\r\n          \r\n          // Update camera size based on resolution\r\n          setCameraSize({ width, height });\r\n          \r\n          // Update aspect ratio\r\n          if (width && height) {\r\n            setImageAspectRatio(width / height);\r\n          }\r\n        }\r\n\r\n        // Apply crop settings if available\r\n        if (settings.cropRange && Array.isArray(settings.cropRange) && settings.cropRange.length === 4) {\r\n          setCropRange(settings.cropRange);\r\n          \r\n          // Enable crop mode if we have a valid crop range\r\n          if (settings.cropRange.some(val => val !== 0)) {\r\n            setIsCropMode(true);\r\n          }\r\n        }\r\n        \r\n        if (typeof settings.cropInterval === 'number') {\r\n          setCropInterval(settings.cropInterval);\r\n        }\r\n        \r\n        // Apply stream image setting if available\r\n        if (typeof settings.streamImage === 'boolean') {\r\n          setStreamCropImage(settings.streamImage);\r\n        }\r\n        \r\n        // Apply to graph setting if available\r\n        if (typeof settings.toGraph === 'boolean') {\r\n          setCropToGraph(settings.toGraph);\r\n        }\r\n        \r\n        // If camera is not active OR if topic changed, start/restart connection\r\n        if (!isCameraActive || shouldReconnect) {\r\n          if (isCameraActive) {\r\n            disconnectFromMqtt(); // Disconnect first if topic changed\r\n            await new Promise(resolve => setTimeout(resolve, 500)); // Wait for disconnect\r\n          }\r\n          // Short delay to allow state update\r\n          setTimeout(() => connectToMqttAndStartStreaming(), 100);\r\n          \r\n          // Wait for camera to start before continuing\r\n          await new Promise(resolve => setTimeout(resolve, 1000));\r\n        }\r\n        \r\n        // After camera settings are applied, handle line drawing settings\r\n        if (settings.isLineDrawn && settings.lineStart && settings.lineEnd) {\r\n          // Set original line points\r\n          setOriginalLineStart(settings.lineStart);\r\n          setOriginalLineEnd(settings.lineEnd);\r\n          \r\n          // Set current line points (will be adjusted by offset/rotation later)\r\n          setCurrentLine(settings);\r\n          \r\n          // Mark line as drawn\r\n          setIsLineDrawn(true);\r\n          \r\n          // Apply line adjustments\r\n          if (settings.lineYOffset !== undefined) {\r\n            setLineYOffset(settings.lineYOffset);\r\n          }\r\n          \r\n          if (settings.lineXOffset !== undefined) {\r\n            setLineXOffset(settings.lineXOffset);\r\n          }\r\n          \r\n          // Send the loaded line to the backend immediately\r\n          // Use a timeout to ensure connection is established after potential restart\r\n          setTimeout(() => {\r\n            const finalLine = calculateTransformedLinePosition(settings.lineStart, settings.lineEnd, settings.lineYOffset, settings.lineXOffset);\r\n            sendLineUpdate(finalLine);\r\n            redrawCanvas(); // Redraw with the loaded line\r\n          }, 1500); // Increased delay to ensure connection\r\n        }\r\n        \r\n        return true;\r\n      } catch (error) {\r\n        console.error('Error applying camera settings:', error);\r\n        return false;\r\n      }\r\n    }\r\n  }));\r\n  \r\n  // Connect to MQTT broker and start streaming\r\n  const connectToMqttAndStartStreaming = async () => {\r\n    try {\r\n      // Use the WS_URL from config instead of trying to connect directly to MQTT broker\r\n      console.log('Connecting to WebSocket server at:', WS_URL);\r\n      \r\n      // Create WebSocket connection using WS_URL\r\n      const websocket = new WebSocket(WS_URL);\r\n      \r\n      websocket.onopen = () => {\r\n        console.log('Connected to WebSocket server successfully');\r\n        setIsMqttConnected(true);\r\n        \r\n        // Explicitly subscribe to the response topic via WebSocket\r\n        const subscribeMessage = {\r\n          topic: \"common/subscribe\",\r\n          payload: `${mqttTopic}/response/full_frame`\r\n        };\r\n        \r\n        websocket.send(JSON.stringify(subscribeMessage));\r\n        \r\n        // Subscribe to config response topic\r\n        const subscribeConfig = {\r\n          topic: \"common/subscribe\",\r\n          payload: `${mqttTopic}/response/config`\r\n        };\r\n        websocket.send(JSON.stringify(subscribeConfig));\r\n\r\n        // Subscribe to cropped frame response topic\r\n        const subscribeCroppedFrame = {\r\n          topic: \"common/subscribe\",\r\n          payload: `${mqttTopic}/response/crop_frame`\r\n        };\r\n        console.log(`[MQTTCamera] Subscribing to cropped frame topic: ${subscribeCroppedFrame.payload}`);\r\n        websocket.send(JSON.stringify(subscribeCroppedFrame));\r\n\r\n        // Request current config\r\n        const requestConfigMessage = {\r\n          topic: `${mqttTopic}/request/config`,\r\n          payload: { timestamp: Date.now() }\r\n        };\r\n        websocket.send(JSON.stringify(requestConfigMessage));\r\n        setLastPublishedMessage(requestConfigMessage);\r\n        \r\n        // Add a diagnostic function to verify and re-subscribe if needed\r\n        const diagnosticCheckCallback = () => {\r\n          if (websocket && websocket.readyState === WebSocket.OPEN) {\r\n            console.log(\"[MQTTCamera] Running subscription diagnostic check\");\r\n            \r\n            // Re-subscribe to crop_frame topic to ensure it's active\r\n            const resubCroppedFrame = {\r\n              topic: \"common/subscribe\",\r\n              payload: `${mqttTopic}/response/crop_frame`\r\n            };\r\n            websocket.send(JSON.stringify(resubCroppedFrame));\r\n            console.log(`[MQTTCamera] Re-subscribed to cropped frame topic: ${resubCroppedFrame.payload}`);\r\n            \r\n            // Request subscription status if supported by server\r\n            const statusRequest = {\r\n              topic: \"common/subscription_status\",\r\n              payload: { client_id: mqttSettings.clientId }\r\n            };\r\n            websocket.send(JSON.stringify(statusRequest));\r\n          }\r\n        };\r\n        \r\n        // Run diagnostic check after a delay\r\n        setTimeout(diagnosticCheckCallback, 3000);\r\n        \r\n        // Start streaming right away\r\n        startStreaming(websocket);\r\n      };\r\n\r\n      websocket.onmessage = (event) => {\r\n        try {\r\n          const rawData = event.data;\r\n          console.debug('[MQTTCamera] Raw WS Message:', rawData);\r\n          const data = JSON.parse(rawData);\r\n          \r\n          // Handle cropped frame response\r\n          if (data.topic === `${mqttTopic}/response/crop_frame`) {\r\n            try {\r\n              console.log(\"[MQTTCamera] Received cropped frame response:\", data);\r\n              let imageData = null;\r\n              \r\n              // Handle payload based on its type\r\n              if (data.payload) {\r\n                if (typeof data.payload === 'string') {\r\n                  try {\r\n                    console.log(\"[MQTTCamera] Parsing string payload:\", data.payload.substring(0, 100) + \"...\");\r\n                    const parsedPayload = JSON.parse(data.payload);\r\n                    if (parsedPayload.image) {\r\n                      imageData = parsedPayload.image;\r\n                      console.log(\"[MQTTCamera] Found image in parsed payload, length:\", imageData.length);\r\n                    }\r\n                  } catch (e) {\r\n                    console.warn(\"[MQTTCamera] Error parsing payload:\", e);\r\n                    // Silent catch - not valid JSON\r\n                  }\r\n                } else if (typeof data.payload === 'object' && data.payload.image) {\r\n                  imageData = data.payload.image;\r\n                  console.log(\"[MQTTCamera] Found image in object payload, length:\", imageData.length);\r\n                }\r\n              }\r\n              \r\n              if (imageData) {\r\n                updateCropPreviewWithBase64Image(imageData);\r\n                console.log(\"[MQTTCamera] Updated crop preview with image data\");\r\n              } else {\r\n                console.warn('⚠️ Cropped frame response has no image data');\r\n              }\r\n\r\n              // Mark that we've received a crop response and can send another request\r\n              setIsWaitingForCropResponse(false);\r\n            } catch (err) {\r\n              console.error('Error processing cropped frame response:', err);\r\n              setIsWaitingForCropResponse(false); // Reset flag even on error\r\n            }\r\n            return; // Exit after handling cropped frame\r\n          }\r\n          \r\n          // Handle Config Response\r\n          if (data.topic === `${mqttTopic}/response/config`) {\r\n            try {\r\n              let configData = null;\r\n              console.debug('[MQTTCamera] Received config response, Payload type:', typeof data.payload, 'Payload:', data.payload);\r\n              if (data.payload) {\r\n                if (typeof data.payload === 'string') {\r\n                  // Attempt to parse if it looks like JSON\r\n                  try {\r\n                  configData = JSON.parse(data.payload);\r\n                    console.debug('[MQTTCamera] Parsed string payload to config object:', configData);\r\n                  } catch (e) {\r\n                    console.warn('[MQTTCamera] Config payload is a string but not valid JSON:', data.payload, 'Error:', e);\r\n                    // Keep configData null\r\n                  }\r\n                } else { // Payload is already an object\r\n                  configData = data.payload;\r\n                  console.debug('[MQTTCamera] Config payload is already an object:', configData);\r\n                }\r\n              }\r\n              \r\n              if (configData) {\r\n                console.log(\"[MQTTCamera] Processing received config:\", configData);\r\n                // Validate received config structure slightly\r\n                if (configData.camera && configData.processing && configData.processing.roi) {\r\n                  setCameraConfig(configData);\r\n                  setPendingConfig(JSON.parse(JSON.stringify(configData))); // Update pending config too\r\n                  // Update relevant states based on config if needed (e.g., ROI might affect cameraSize view)\r\n                  const [w, h] = configData.camera.resolution || [640, 480]; // Fallback resolution\r\n                  if (w && h) {\r\n                  setCameraSize({ width: w, height: h });\r\n                  setImageAspectRatio(w / h);\r\n                  }\r\n                } else {\r\n                  console.warn(\"Received invalid config structure\", configData);\r\n                }\r\n              } else {\r\n                console.warn(\"Received empty or non-parsable config response payload\");\r\n                // Maybe add error state here?\r\n              }\r\n            } catch (err) {\r\n              console.error('Error processing config response:', err, 'Data:', data.payload);\r\n            }\r\n            return; // Processed config, exit\r\n          }\r\n          \r\n          // DIRECTLY CHECK for the specific response topic first\r\n          if (data.topic === `${mqttTopic}/response/full_frame`) {\r\n            try {\r\n              let imageData = null;\r\n              \r\n              // Handle payload based on its type\r\n              let resolution = null;\r\n              if (data.payload) {\r\n                if (typeof data.payload === 'string') {\r\n                  try {\r\n                    const parsedPayload = JSON.parse(data.payload);\r\n                    if (parsedPayload.image) {\r\n                      imageData = parsedPayload.image;\r\n                    }\r\n                    if (parsedPayload.resolution) {\r\n                      resolution = parsedPayload.resolution;\r\n                    }\r\n                  } catch (e) {\r\n                    // Silently continue\r\n                  }\r\n                }\r\n                else if (typeof data.payload === 'object' && data.payload.image) {\r\n                  imageData = data.payload.image;\r\n                  if (data.payload.resolution) {\r\n                    resolution = data.payload.resolution;\r\n                  }\r\n                }\r\n              }\r\n              \r\n              if (imageData) {\r\n                // If resolution was sent with the image, update aspect ratio based on it\r\n                if (resolution && Array.isArray(resolution) && resolution.length === 2) {\r\n                  const [imgW, imgH] = resolution;\r\n                  if (imgW > 0 && imgH > 0) {\r\n                    updateAspectRatioAndResolutions(imgW, imgH);\r\n                  }\r\n                }\r\n                setLastMqttResponse(data.payload);\r\n                updateVideoWithBase64Image(imageData);\r\n              } else {\r\n                console.warn('⚠️ Response has correct topic but no image data found');\r\n              }\r\n\r\n              // Mark that we've received a response and can send another request\r\n              setIsWaitingForResponse(false);\r\n            } catch (err) {\r\n              console.error('Error processing response:', err);\r\n              setIsWaitingForResponse(false); // Reset flag even on error\r\n            }\r\n            \r\n            // Return after handling the main topic to avoid redundant processing\r\n            return;\r\n          }\r\n          \r\n          // Log unhandled message topics for debugging\r\n          if (data.topic && data.topic.includes(mqttTopic) && \r\n              data.topic !== `${mqttTopic}/response/full_frame` && \r\n              data.topic !== `${mqttTopic}/response/crop_frame` && \r\n              data.topic !== `${mqttTopic}/response/config` &&\r\n              data.topic !== `${mqttTopic}/response/data`) {\r\n            console.log(`[MQTTCamera] Unhandled topic received: ${data.topic}`, data);\r\n          }\r\n          \r\n          // Fallback: Check for common/device_response which might contain our response\r\n          if (data.topic === 'common/device_response') {\r\n            // Process common/device_response\r\n            if (data.payload && typeof data.payload === 'string') {\r\n              if (data.payload.includes(mqttTopic)) {\r\n                try {\r\n                  if (data.payload.includes('image')) {\r\n                    const responseData = JSON.parse(data.payload);\r\n                    if (responseData.image) {\r\n                      updateVideoWithBase64Image(responseData.image);\r\n                      setLastMqttResponse(responseData);\r\n                    }\r\n                  }\r\n                } catch (err) {\r\n                  console.error('Error parsing device response:', err);\r\n                }\r\n              }\r\n            }\r\n          }\r\n          \r\n          // Final fallback: Look for anything that might contain image data\r\n          const fullEventData = JSON.stringify(data).toLowerCase();\r\n          if (\r\n            fullEventData.includes('image') || \r\n            fullEventData.includes('frame') || \r\n            fullEventData.includes('response')\r\n          ) {\r\n            tryExtractAndShowImage(data);\r\n          }\r\n          \r\n        } catch (error) {\r\n          console.error('❌ Error processing WebSocket message:', error, 'Raw data:', event.data);\r\n          // Reset waiting flags in case of error\r\n          setIsWaitingForResponse(false);\r\n          setIsWaitingForCropResponse(false);\r\n        }\r\n      };\r\n\r\n      websocket.onerror = (error) => {\r\n        console.error('WebSocket error:', error);\r\n        setIsMqttConnected(false);\r\n        setIsCameraActive(false);\r\n      };\r\n\r\n      setMqttClient(websocket);\r\n      setIsCameraActive(true);\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error connecting to WebSocket:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Disconnect from MQTT broker\r\n  const disconnectFromMqtt = () => {\r\n    // Stop streaming first\r\n    stopStreaming();\r\n    \r\n    // Unsubscribe from the response topic before closing the connection\r\n    if (mqttClient && mqttClient.readyState === WebSocket.OPEN) {\r\n      // Send unsubscribe message\r\n      const unsubscribeMessage = {\r\n        topic: \"common/unsubscribe\", \r\n        payload: `${mqttTopic}/response/full_frame`\r\n      };\r\n      \r\n      mqttClient.send(JSON.stringify(unsubscribeMessage));\r\n      \r\n      // Add a small delay before closing to ensure the unsubscribe is processed\r\n      setTimeout(() => {\r\n        mqttClient.close();\r\n      }, 100);\r\n    }\r\n    \r\n    setIsMqttConnected(false);\r\n    setIsCameraActive(false);\r\n    setMqttClient(null);\r\n  };\r\n  \r\n  // Start streaming frames\r\n  const startStreaming = (websocket) => {\r\n    if (!websocket) return;\r\n    \r\n    setIsStreaming(true);\r\n    \r\n    // Send first frame request immediately\r\n    requestFullFrame(websocket);\r\n    \r\n    // Set up interval to check if we should request a new frame\r\n    intervalRef.current = setInterval(() => {\r\n      // Only send a new request if:\r\n      // 1. We're not in crop mode\r\n      // 2. We're not already waiting for a response\r\n      // 3. WebSocket is connected\r\n      if (!isCropMode && !isWaitingForResponse && websocket && websocket.readyState === WebSocket.OPEN) {\r\n        requestFullFrame(websocket);\r\n      }\r\n    }, pollingInterval);\r\n  };\r\n  \r\n  // Request a single full frame\r\n  const requestFullFrame = (websocket) => {\r\n    // Format the message according to the system's expected format\r\n    const message = {\r\n      topic: `${mqttTopic}/request/full_frame`,\r\n      payload: { timestamp: Date.now() }\r\n    };\r\n    \r\n    setLastPublishedMessage(message);\r\n    setIsWaitingForResponse(true);\r\n    \r\n    websocket.send(JSON.stringify(message));\r\n  };\r\n  \r\n  // Stop streaming frames\r\n  const stopStreaming = () => {\r\n    if (intervalRef.current) {\r\n      clearInterval(intervalRef.current);\r\n      intervalRef.current = null;\r\n      setIsStreaming(false);\r\n    }\r\n  };\r\n  \r\n  // Update aspect ratio and available resolutions when we receive an image\r\n  const updateAspectRatioAndResolutions = (width, height) => {\r\n    const newAspectRatio = width / height;\r\n    if (Math.abs(newAspectRatio - imageAspectRatio) > 0.01) { // Small threshold to avoid unnecessary updates\r\n      setImageAspectRatio(newAspectRatio);\r\n      \r\n      // Generate resolution options that match this aspect ratio\r\n      const baseWidths = [640, 800, 1024, 1280, 1600, 1920];\r\n      const newResolutions = baseWidths.map(w => {\r\n        const h = Math.round(w / newAspectRatio);\r\n        return `${w}x${h}`;\r\n      });\r\n      \r\n      setAvailableResolutions(newResolutions);\r\n      \r\n      // Set cameraResolution to match actual camera resolution\r\n      setCameraResolution(`${width}x${height}`);\r\n      \r\n      // Adjust current camera size to match aspect ratio\r\n      setCameraSize(prev => ({\r\n        width: prev.width,\r\n        height: Math.round(prev.width / newAspectRatio)\r\n      }));\r\n    }\r\n  };\r\n\r\n  // Update video with base64 encoded image data\r\n  const updateVideoWithBase64Image = (base64Data) => {\r\n    if (!base64Data) {\r\n      console.error('Cannot update image: missing base64 data');\r\n      return;\r\n    }\r\n    \r\n    if (!canvasRef.current) {\r\n      console.error('Cannot update image: canvas reference is null');\r\n      return;\r\n    }\r\n\r\n    // Validate that the base64 string looks correct\r\n    if (!base64Data.match(/^[A-Za-z0-9+/=]+$/)) {\r\n      console.error('Invalid base64 data format. Data does not appear to be valid base64.');\r\n      return;\r\n    }\r\n\r\n    // Create an image element to load the data\r\n    const img = new Image();\r\n    \r\n    // Add load event listener before setting src\r\n    img.onload = () => {\r\n      // Store the image reference for later use\r\n      imageRef.current = img;\r\n      \r\n      // Update aspect ratio and available resolutions\r\n      updateAspectRatioAndResolutions(img.width, img.height);\r\n      \r\n      // Call redrawCanvas instead of drawing directly here\r\n      redrawCanvas(); \r\n    };\r\n    \r\n    img.onerror = (error) => {\r\n      console.error('Failed to load image:', error);\r\n      console.error('Image load failed. This usually means the base64 data is invalid or incomplete.');\r\n    };\r\n    \r\n    // Set the image source to the base64 data\r\n    try {\r\n      img.src = `data:image/jpeg;base64,${base64Data}`;\r\n    } catch (e) {\r\n      console.error('Error setting image source:', e);\r\n    }\r\n  };\r\n  \r\n  // Update preview with base64 encoded cropped image data\r\n  const updateCropPreviewWithBase64Image = (base64Data) => {\r\n    if (!base64Data) {\r\n      console.error('Cannot update crop preview: missing base64 data');\r\n      return;\r\n    }\r\n\r\n    // Set the preview image data\r\n    setCropPreviewImage(`data:image/jpeg;base64,${base64Data}`);\r\n  };\r\n  \r\n  // Clean up on component unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      stopStreaming();\r\n      stopCropStreaming();\r\n      disconnectFromMqtt();\r\n    };\r\n  }, []);\r\n  \r\n  // Initialize canvas size when video size changes\r\n  useEffect(() => {\r\n    if (canvasRef.current) {\r\n      canvasRef.current.width = cameraSize.width;\r\n      canvasRef.current.height = cameraSize.height;\r\n      \r\n      // If line is drawn, redraw it when canvas size changes\r\n      if (isLineDrawn) {\r\n        // Ensure the redraw happens after the canvas size is updated\r\n        // by using a small timeout\r\n        setTimeout(() => {\r\n          redrawCanvas(); // Use redrawCanvas which handles coordinates\r\n          \r\n          // Double-check with another redraw after a slight delay\r\n          setTimeout(() => redrawCanvas(), 100);\r\n        }, 0);\r\n      }\r\n    }\r\n  }, [cameraSize.width, cameraSize.height, isLineDrawn]);\r\n  \r\n  // Effect for continuous redrawing of the canvas (image + line)\r\n  useEffect(() => {\r\n    let animationId;\r\n\r\n    // Function to continuously redraw the canvas (image + line)\r\n    const redrawLoop = () => {\r\n      if (canvasRef.current) {\r\n        redrawCanvas();\r\n      }\r\n      animationId = requestAnimationFrame(redrawLoop);\r\n    };\r\n\r\n    // Start animation loop if camera is active\r\n    if (isCameraActive || isLineDrawn) {\r\n      animationId = requestAnimationFrame(redrawLoop);\r\n      console.debug(\"[Animation] Starting redraw loop\");\r\n    }\r\n\r\n    // Cleanup function\r\n    return () => {\r\n      if (animationId) {\r\n        console.debug(\"[Animation] Stopping redraw loop\");\r\n        cancelAnimationFrame(animationId);\r\n      }\r\n    };\r\n  }, [isCameraActive, isLineDrawn]); // Re-run when camera activity or line drawing state changes\r\n\r\n  // Start camera stream (now connects to MQTT)\r\n  const startCamera = async () => {\r\n    return connectToMqttAndStartStreaming();\r\n  };\r\n  \r\n  // Stop camera stream (now disconnects from MQTT)\r\n  const stopCamera = () => {\r\n    disconnectFromMqtt();\r\n  };\r\n  \r\n  // Function to send the line update to the backend\r\n  const sendLineUpdate = (line) => {\r\n    if (mqttClient && mqttClient.readyState === WebSocket.OPEN && line) {\r\n      // Ensure we have valid coordinates\r\n      if (!line.start || !line.end) {\r\n        console.warn('Invalid line coordinates:', line);\r\n        return;\r\n      }\r\n\r\n      // Send integer coordinates\r\n      const payload = {\r\n        start_x: Math.round(line.start.x),\r\n        end_x: Math.round(line.end.x),\r\n        y: Math.round(line.start.y) // Y is the same for start and end since line is horizontal\r\n      };\r\n\r\n      const message = {\r\n        topic: `${mqttTopic}/request/set_line`,\r\n        payload: payload\r\n      };\r\n\r\n      console.log(\"Sending line update:\", message);\r\n      mqttClient.send(JSON.stringify(message));\r\n      setLastPublishedMessage(message);\r\n    } else {\r\n      console.warn('Cannot send line update: WebSocket not connected or line not defined.', {\r\n        wsState: mqttClient?.readyState,\r\n        line: line\r\n      });\r\n    }\r\n  };\r\n  \r\n  // Calculate the current line position with offsets applied\r\n  const calculateTransformedLinePosition = () => {\r\n    if (!originalLineStart || !originalLineEnd) return null;\r\n\r\n    // Return the original line coordinates with any offsets applied\r\n    return {\r\n      start: {\r\n        x: originalLineStart.x,\r\n        y: originalLineStart.y\r\n      },\r\n      end: {\r\n        x: originalLineEnd.x,\r\n        y: originalLineEnd.y\r\n      }\r\n    };\r\n  };\r\n  \r\n  // Handle line Y-offset adjustment\r\n  const handleLineYOffsetChange = (e) => {\r\n    const newOffset = parseInt(e.target.value);\r\n    setLineYOffset(newOffset);\r\n    // Send update only on adjustment, not during initial draw\r\n    if (isLineDrawn && originalLineStart && originalLineEnd) { \r\n        const newLine = calculateTransformedLinePosition(originalLineStart, originalLineEnd, newOffset, lineXOffset);\r\n        // Force redraw immediately to improve responsiveness\r\n        redrawCanvas();\r\n        sendLineUpdate(newLine);\r\n    }\r\n  };\r\n  \r\n  // Handle line X-offset adjustment\r\n  const handleLineXOffsetChange = (e) => {\r\n    const newOffset = parseInt(e.target.value);\r\n    setLineXOffset(newOffset);\r\n    // Send update only on adjustment, not during initial draw\r\n    if (isLineDrawn && originalLineStart && originalLineEnd) {\r\n        const newLine = calculateTransformedLinePosition(originalLineStart, originalLineEnd, lineYOffset, newOffset);\r\n        // Force redraw immediately to improve responsiveness  \r\n        redrawCanvas();\r\n        sendLineUpdate(newLine);\r\n    }\r\n  };\r\n  \r\n  // Convert canvas coordinates to relative image coordinates\r\n  const getRelativeImageCoordinates = (event) => {\r\n    if (!canvasRef.current || !imageRef.current) return null;\r\n\r\n    const canvas = canvasRef.current;\r\n    const image = imageRef.current;\r\n    const rect = canvas.getBoundingClientRect();\r\n\r\n    // Get click coordinates relative to canvas\r\n    const canvasX = event.clientX - rect.left;\r\n    const canvasY = event.clientY - rect.top;\r\n\r\n    // Calculate scale factors\r\n    const scaleX = image.naturalWidth / rect.width;\r\n    const scaleY = image.naturalHeight / rect.height;\r\n    const imageX = Math.round(canvasX * scaleX);\r\n    const imageY = Math.round(canvasY * scaleY);\r\n\r\n    // Add 2px margin to boundaries\r\n    const margin = 2;\r\n    if (imageX < margin || imageX > image.naturalWidth - margin ||\r\n        imageY < margin || imageY > image.naturalHeight - margin) {\r\n      console.warn('Click outside image boundaries');\r\n      return null;\r\n    }\r\n\r\n    return {\r\n      x: Math.round(imageX),\r\n      y: Math.round(imageY)\r\n    };\r\n  };\r\n\r\n  // Render camera controls\r\n  const renderCameraControls = () => {\r\n    return (\r\n      <div style={floatingComponentStyles.controls}>\r\n        {/* Camera/MQTT connection controls */}\r\n        {!isCameraActive ? (\r\n          <button \r\n            style={buttonVariants.primaryButton}\r\n            onClick={startCamera}\r\n          >\r\n            Connect to Device\r\n          </button>\r\n        ) : (\r\n          <>\r\n            <button \r\n              style={{\r\n                ...buttonVariants.primaryButton,\r\n                backgroundColor: 'rgba(255, 50, 50, 0.7)',\r\n              }}\r\n              onClick={stopCamera}\r\n            >\r\n              Disconnect\r\n            </button>\r\n            \r\n            {isLineDrawn ? (\r\n              <>\r\n                <button \r\n                  style={buttonVariants.smallSecondary}\r\n                  onClick={clearLine}\r\n                >\r\n                  Clear Line\r\n                </button>\r\n                <button \r\n                  style={buttonVariants.smallSecondary} \r\n                  disabled={true} // Disable extraction button as it's now handled by backend\r\n                  title=\"Data extraction handled by backend\"\r\n                >\r\n                  Extract (Backend)\r\n                </button>\r\n              </>\r\n            ) : (\r\n              <button \r\n                style={buttonVariants.smallSecondary}\r\n                disabled={isDrawing}\r\n                title=\"Click and drag on video to draw a line\"\r\n              >\r\n                Draw Line\r\n              </button>\r\n            )}\r\n          </>\r\n        )}\r\n      </div>\r\n    );\r\n  };\r\n  \r\n  // Clear the drawn line\r\n  const clearLine = () => {\r\n    setIsLineDrawn(false);\r\n    setIsDrawing(false);\r\n    setCurrentLine(null);\r\n    \r\n    // Send message to backend to clear the line (optional, or send invalid coords)\r\n    sendLineUpdate({ start: { x: -1, y: -1 }, end: { x: -1, y: -1 } }); // Send dummy coords\r\n    \r\n    // Clear canvas\r\n    if (canvasRef.current) {\r\n      const ctx = canvasRef.current.getContext('2d');\r\n      ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);\r\n      // Need to redraw the image after clearing\r\n      if (imageRef.current) {\r\n          redrawCanvas();\r\n      }\r\n    }\r\n  };\r\n\r\n  // Start line drawing on mouse down\r\n  const startLineDrawing = (event) => {\r\n    if (!canvasRef.current || !imageRef.current) return;\r\n\r\n    const coords = getRelativeImageCoordinates(event);\r\n    if (!coords) {\r\n      console.warn('Invalid start coordinates');\r\n      return;\r\n    }\r\n\r\n    setIsDrawing(true);\r\n    setCurrentLine({\r\n      start: coords,\r\n      end: coords\r\n    });\r\n    console.log('Started line at:', coords);\r\n  };\r\n\r\n  // Update line drawing on mouse move\r\n  const updateLineDrawing = (event) => {\r\n    if (!isDrawing || !canvasRef.current || !imageRef.current) return;\r\n\r\n    const coords = getRelativeImageCoordinates(event);\r\n    if (!coords) {\r\n      console.warn('Invalid move coordinates');\r\n      return;\r\n    }\r\n\r\n    // Force horizontal line by keeping Y coordinate the same as start\r\n    coords.y = currentLine.start.y;\r\n\r\n    setCurrentLine(prev => ({\r\n      ...prev,\r\n      end: coords\r\n    }));\r\n\r\n    redrawCanvas();\r\n  };\r\n\r\n  // Finish line drawing on mouse up\r\n  const finishLineDrawing = (event) => {\r\n    if (!isDrawing || !canvasRef.current || !imageRef.current) return;\r\n\r\n    const coords = getRelativeImageCoordinates(event);\r\n    if (!coords) {\r\n      console.warn('Invalid end coordinates');\r\n      setIsDrawing(false);\r\n      setCurrentLine(null);\r\n      return;\r\n    }\r\n\r\n    // Force horizontal line\r\n    coords.y = currentLine.start.y;\r\n\r\n    const finalLine = {\r\n      start: currentLine.start,\r\n      end: coords\r\n    };\r\n\r\n    // Calculate distance\r\n    const distance = Math.abs(finalLine.end.x - finalLine.start.x);\r\n    console.log('Line distance:', distance, 'px');\r\n\r\n    if (distance < MIN_LINE_LENGTH) {\r\n      console.warn(`Line too short (distance: ${distance}px). Clearing.`);\r\n      setIsDrawing(false);\r\n      setCurrentLine(null);\r\n      redrawCanvas();\r\n      return;\r\n    }\r\n\r\n    // Ensure start_x is always less than end_x\r\n    if (finalLine.start.x > finalLine.end.x) {\r\n      const temp = finalLine.start;\r\n      finalLine.start = finalLine.end;\r\n      finalLine.end = temp;\r\n    }\r\n\r\n    console.log('Finished line:', finalLine);\r\n    setIsDrawing(false);\r\n    setCurrentLine(finalLine);\r\n    sendLineUpdate(finalLine);\r\n    redrawCanvas();\r\n  };\r\n  \r\n  // Handle resize start\r\n  const handleResizeStart = (e) => {\r\n    e.preventDefault();\r\n    e.stopPropagation();\r\n    \r\n    const startX = e.clientX;\r\n    const startY = e.clientY;\r\n    const startWidth = cameraSize.width;\r\n    const startHeight = cameraSize.height;\r\n    \r\n    setIsResizing(true);\r\n    setShowResizeInfo(true);\r\n    \r\n    const handleMouseMove = (moveEvent) => {\r\n      const deltaX = moveEvent.clientX - startX;\r\n      \r\n      // Calculate new width, constrained to minimum of 320px\r\n      const newWidth = Math.max(320, startWidth + deltaX);\r\n      \r\n      // Calculate height based on aspect ratio\r\n      const newHeight = Math.round(newWidth / imageAspectRatio);\r\n      \r\n      setCameraSize({\r\n        width: newWidth,\r\n        height: newHeight\r\n      });\r\n      \r\n      // Notify parent if onResize callback is provided\r\n      if (onResize) {\r\n        onResize({ width: newWidth, height: newHeight });\r\n      }\r\n      \r\n      moveEvent.preventDefault();\r\n    };\r\n    \r\n    const handleMouseUp = () => {\r\n      document.removeEventListener('mousemove', handleMouseMove);\r\n      document.removeEventListener('mouseup', handleMouseUp);\r\n      \r\n      setIsResizing(false);\r\n      setTimeout(() => setShowResizeInfo(false), 1000);\r\n    };\r\n    \r\n    document.addEventListener('mousemove', handleMouseMove);\r\n    document.addEventListener('mouseup', handleMouseUp);\r\n  };\r\n\r\n  // Helper function to try extracting and displaying image data from various message formats\r\n  const tryExtractAndShowImage = (data) => {\r\n    try {\r\n      // Check multiple potential payload locations\r\n      let imageData = null;\r\n      let imagePayload = null;\r\n      \r\n      // Case 1: data.payload is an object with image property\r\n      if (data.payload && typeof data.payload === 'object' && data.payload.image) {\r\n        imageData = data.payload.image;\r\n        imagePayload = data.payload;\r\n      }\r\n      // Case 2: data.payload is a string that might be JSON\r\n      else if (data.payload && typeof data.payload === 'string') {\r\n        try {\r\n          const parsedPayload = JSON.parse(data.payload);\r\n          if (parsedPayload && parsedPayload.image) {\r\n            imageData = parsedPayload.image;\r\n            imagePayload = parsedPayload;\r\n          }\r\n        } catch (e) {\r\n          // Silent catch - not valid JSON\r\n        }\r\n      }\r\n      // Case 3: data itself has an image property\r\n      else if (data.image) {\r\n        imageData = data.image;\r\n        imagePayload = data;\r\n      }\r\n      \r\n      if (imageData) {\r\n        setLastMqttResponse(imagePayload);\r\n        updateVideoWithBase64Image(imageData);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    } catch (err) {\r\n      console.error('Error trying to extract image data:', err);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  // State variables for camera settings\r\n  const [cropToGraph, setCropToGraph] = useState(false);\r\n  const [streamCropImage, setStreamCropImage] = useState(true); // Default to true for backward compatibility\r\n  const [sendFullData, setSendFullData] = useState(false); // Add state for full data checkbox\r\n\r\n  // Import spectral_config.json for wavelength channel ranges\r\n  useEffect(() => {\r\n    import('./SpectrometerMQTT/spectral_config.json')\r\n      .then(config => {\r\n        console.log(\"[MQTTCamera] Loaded spectral_config.json:\", config);\r\n      })\r\n      .catch(err => {\r\n        console.error(\"[MQTTCamera] Error loading spectral_config.json:\", err);\r\n      });\r\n  }, []);\r\n\r\n  // Function to calculate pixel ranges based on wavelength ranges\r\n  const calculateWavelengthToPixelRanges = (calibrationPoints) => {\r\n    try {\r\n      // Try to import spectral_config.json\r\n      const spectralConfig = require('./SpectrometerMQTT/spectral_config.json');\r\n      const channelRanges = spectralConfig.CHANNEL_RANGES;\r\n\r\n      // If calibration points aren't available, return null\r\n      if (!calibrationPoints || calibrationPoints.length < 2) {\r\n        console.warn(\"[MQTTCamera] Not enough calibration points to calculate wavelength ranges\");\r\n        return null;\r\n      }\r\n\r\n      // Extract calibration data from calibration points\r\n      const point1 = calibrationPoints[0];\r\n      const point2 = calibrationPoints[1];\r\n      \r\n      // Calculate linear relationship between pixel position and wavelength\r\n      const pixelToWavelengthSlope = \r\n        (point2.wavelength - point1.wavelength) / (point2.position - point1.position);\r\n      const pixelToWavelengthIntercept = \r\n        point1.wavelength - (pixelToWavelengthSlope * point1.position);\r\n      \r\n      // Function to convert wavelength to pixel position\r\n      const wavelengthToPixel = (wavelength) => {\r\n        return (wavelength - pixelToWavelengthIntercept) / pixelToWavelengthSlope;\r\n      };\r\n\r\n      // Calculate pixel ranges for each channel\r\n      const pixelRanges = {\r\n        r: [Math.round(wavelengthToPixel(channelRanges.r[0])), Math.round(wavelengthToPixel(channelRanges.r[1]))],\r\n        g: [Math.round(wavelengthToPixel(channelRanges.g[0])), Math.round(wavelengthToPixel(channelRanges.g[1]))],\r\n        b: [Math.round(wavelengthToPixel(channelRanges.b[0])), Math.round(wavelengthToPixel(channelRanges.b[1]))]\r\n      };\r\n\r\n      console.log(\"[MQTTCamera] Calculated pixel ranges:\", pixelRanges);\r\n      return pixelRanges;\r\n    } catch (error) {\r\n      console.error(\"[MQTTCamera] Error calculating wavelength to pixel ranges:\", error);\r\n      return null;\r\n    }\r\n  };\r\n\r\n  // Start crop frame streaming - Modified to include pixel ranges for wavelength filtering\r\n  const startCropStreaming = () => {\r\n    if (!mqttClient || mqttClient.readyState !== WebSocket.OPEN) {\r\n      console.error('Cannot start crop streaming: WebSocket not connected');\r\n      return;\r\n    }\r\n    \r\n    if (!cropRange || cropRange.every(val => val === 0)) {\r\n      console.error('Cannot start crop streaming: No crop region defined');\r\n      return;\r\n    }\r\n    \r\n    // Stop any existing crop interval\r\n    stopCropStreaming();\r\n    \r\n    // If we're starting crop streaming, stop full frame streaming\r\n    if (intervalRef.current) {\r\n      clearInterval(intervalRef.current);\r\n      intervalRef.current = null;\r\n    }\r\n    \r\n    // Get pixel ranges for RGB channels from calibration if available\r\n    let pixelRanges = null;\r\n    \r\n    // Try to get calibration from graph component via parent ref\r\n    if (!sendFullData && props.graphRef && props.graphRef.current && \r\n        props.graphRef.current.getCalibrationSettings) {\r\n      try {\r\n        const calibrationSettings = props.graphRef.current.getCalibrationSettings();\r\n        pixelRanges = calculateWavelengthToPixelRanges(calibrationSettings.calibrationPoints);\r\n      } catch (error) {\r\n        console.warn(\"[MQTTCamera] Error getting calibration settings:\", error);\r\n      }\r\n    }\r\n    \r\n    // Send crop request with interval in the payload - server will handle streaming\r\n    const message = {\r\n      topic: `${mqttTopic}/request/crop_frame`,\r\n      payload: {\r\n        interval: cropInterval, // Pass actual interval to server\r\n        crop_range: cropRange,\r\n        to_graph: cropToGraph, // Add flag to indicate if the crop should be processed for graph\r\n        stream_image: streamCropImage, // Add flag to indicate if the image should be sent\r\n        full_data: sendFullData, // Add flag to indicate if full data should be sent\r\n        pixel_ranges: pixelRanges // Add pixel ranges for wavelength filtering\r\n      }\r\n    };\r\n    \r\n    console.log(`Starting crop streaming with interval ${cropInterval}ms`, message);\r\n    mqttClient.send(JSON.stringify(message));\r\n    setLastPublishedMessage(message);\r\n    \r\n    // Set streaming state if interval > 0 and we want to stream images\r\n    if (cropInterval > 0 && (streamCropImage || cropToGraph)) {\r\n      setIsCropStreaming(true);\r\n      setIsWaitingForCropResponse(true);\r\n    } else {\r\n      // Single frame request\r\n      setIsWaitingForCropResponse(true);\r\n    }\r\n  };\r\n  \r\n  // Stop crop frame streaming\r\n  const stopCropStreaming = () => {\r\n    if (cropIntervalRef.current) {\r\n      clearInterval(cropIntervalRef.current);\r\n      cropIntervalRef.current = null;\r\n    }\r\n    \r\n    if (mqttClient && mqttClient.readyState === WebSocket.OPEN) {\r\n      // Send message to stop streaming (interval=0)\r\n      const message = {\r\n        topic: `${mqttTopic}/request/crop_frame`,\r\n        payload: {\r\n          interval: 0,\r\n          crop_range: cropRange\r\n        }\r\n      };\r\n      \r\n      mqttClient.send(JSON.stringify(message));\r\n      setLastPublishedMessage(message);\r\n    }\r\n    \r\n    setIsCropStreaming(false);\r\n    setIsWaitingForCropResponse(false); // Reset waiting state when stopping\r\n  };\r\n  \r\n  // Convert crop points to crop range\r\n  const pointsToCropRange = (start, end) => {\r\n    if (!start || !end) return [0, 0, 0, 0];\r\n    \r\n    // Ensure start is top-left and end is bottom-right\r\n    const x_min = Math.min(start.x, end.x);\r\n    const y_min = Math.min(start.y, end.y);\r\n    const x_max = Math.max(start.x, end.x);\r\n    const y_max = Math.max(start.y, end.y);\r\n    \r\n    return [x_min, y_min, x_max, y_max];\r\n  };\r\n  \r\n  // Handle crop start (mousedown)\r\n  const startCropDrawing = (event) => {\r\n    if (!isCropMode || !canvasRef.current || !imageRef.current) return;\r\n    \r\n    event.preventDefault();\r\n    \r\n    const coords = getRelativeImageCoordinates(event);\r\n    if (!coords) return;\r\n    \r\n    setIsDrawingCrop(true);\r\n    setCropStart(coords);\r\n    setCropEnd(coords);\r\n  };\r\n  \r\n  // Handle crop update (mousemove)\r\n  const updateCropDrawing = (event) => {\r\n    if (!isDrawingCrop || !isCropMode) return;\r\n    \r\n    event.preventDefault();\r\n    \r\n    const coords = getRelativeImageCoordinates(event);\r\n    if (!coords) return;\r\n    \r\n    setCropEnd(coords);\r\n    \r\n    // Update the crop range during drawing\r\n    setCropRange(pointsToCropRange(cropStart, coords));\r\n    \r\n    // Redraw canvas to show current crop rectangle\r\n    redrawCanvas();\r\n  };\r\n  \r\n  // Handle crop end (mouseup)\r\n  const finishCropDrawing = (event) => {\r\n    if (!isDrawingCrop || !isCropMode) return;\r\n    \r\n    event.preventDefault();\r\n    \r\n    const coords = getRelativeImageCoordinates(event);\r\n    if (!coords) {\r\n      setIsDrawingCrop(false);\r\n      return;\r\n    }\r\n    \r\n    setCropEnd(coords);\r\n    \r\n    // Calculate final crop range\r\n    const newCropRange = pointsToCropRange(cropStart, coords);\r\n    \r\n    // Check if crop size is valid\r\n    const width = newCropRange[2] - newCropRange[0];\r\n    const height = newCropRange[3] - newCropRange[1];\r\n    \r\n    if (width < MIN_CROP_SIZE || height < MIN_CROP_SIZE) {\r\n      console.warn(`Crop rectangle too small (${width}x${height}px). Minimum size is ${MIN_CROP_SIZE}x${MIN_CROP_SIZE}px.`);\r\n      setIsDrawingCrop(false);\r\n      // Reset crop\r\n      setCropStart(null);\r\n      setCropEnd(null);\r\n      setCropRange([0, 0, 0, 0]);\r\n      redrawCanvas();\r\n      return;\r\n    }\r\n    \r\n    // Set the final crop range\r\n    setCropRange(newCropRange);\r\n    setIsDrawingCrop(false);\r\n    \r\n    // Request a single cropped frame to preview\r\n    requestCroppedFrame(newCropRange);\r\n    \r\n    // Redraw to show the final crop rectangle\r\n    redrawCanvas();\r\n  };\r\n  \r\n  // Modify requestCroppedFrame to include the same pixel ranges\r\n  const requestCroppedFrame = (range) => {\r\n    if (!mqttClient || mqttClient.readyState !== WebSocket.OPEN) return;\r\n    \r\n    // Get pixel ranges for RGB channels from calibration if available\r\n    let pixelRanges = null;\r\n    \r\n    // Try to get calibration from graph component via parent ref\r\n    if (!sendFullData && props.graphRef && props.graphRef.current && \r\n        props.graphRef.current.getCalibrationSettings) {\r\n      try {\r\n        const calibrationSettings = props.graphRef.current.getCalibrationSettings();\r\n        pixelRanges = calculateWavelengthToPixelRanges(calibrationSettings.calibrationPoints);\r\n      } catch (error) {\r\n        console.warn(\"[MQTTCamera] Error getting calibration settings:\", error);\r\n      }\r\n    }\r\n    \r\n    const message = {\r\n      topic: `${mqttTopic}/request/crop_frame`,\r\n      payload: {\r\n        interval: 0, // Single frame\r\n        crop_range: range,\r\n        to_graph: cropToGraph, // Add flag to indicate if the crop should be processed for graph\r\n        stream_image: streamCropImage, // Add flag to indicate if the image should be sent\r\n        full_data: sendFullData, // Add flag to indicate if full data should be sent\r\n        pixel_ranges: pixelRanges // Add pixel ranges for wavelength filtering\r\n      }\r\n    };\r\n    \r\n    mqttClient.send(JSON.stringify(message));\r\n    setLastPublishedMessage(message);\r\n    setIsWaitingForCropResponse(true);\r\n  };\r\n\r\n  // Handle manual crop range input change\r\n  const handleCropRangeChange = (index, value) => {\r\n    const newCropRange = [...cropRange];\r\n    newCropRange[index] = parseInt(value) || 0;\r\n    \r\n    // Ensure min <= max\r\n    if (index === 0 && newCropRange[0] > newCropRange[2]) {\r\n      newCropRange[2] = newCropRange[0];\r\n    }\r\n    if (index === 1 && newCropRange[1] > newCropRange[3]) {\r\n      newCropRange[3] = newCropRange[1];\r\n    }\r\n    if (index === 2 && newCropRange[2] < newCropRange[0]) {\r\n      newCropRange[0] = newCropRange[2];\r\n    }\r\n    if (index === 3 && newCropRange[3] < newCropRange[1]) {\r\n      newCropRange[1] = newCropRange[3];\r\n    }\r\n    \r\n    setCropRange(newCropRange);\r\n    redrawCanvas();\r\n  };\r\n\r\n  // Toggle crop mode\r\n  const toggleCropMode = () => {\r\n    const newCropMode = !isCropMode;\r\n    setIsCropMode(newCropMode);\r\n    \r\n    if (!newCropMode) {\r\n      // Exiting crop mode, clean up and restart full frame streaming\r\n      setIsDrawingCrop(false);\r\n      stopCropStreaming();\r\n      \r\n      // Restart full frame streaming if camera is active\r\n      if (isCameraActive && mqttClient && mqttClient.readyState === WebSocket.OPEN) {\r\n        startStreaming(mqttClient);\r\n      }\r\n    } else {\r\n      // Entering crop mode, stop full frame streaming\r\n      if (intervalRef.current) {\r\n        clearInterval(intervalRef.current);\r\n        intervalRef.current = null;\r\n      }\r\n      // Stop line drawing if active\r\n      setIsDrawing(false);\r\n    }\r\n    \r\n    redrawCanvas();\r\n  };\r\n\r\n  // Reset crop\r\n  const resetCrop = () => {\r\n    setCropStart(null);\r\n    setCropEnd(null);\r\n    setCropRange([0, 0, 0, 0]);\r\n    setCropPreviewImage(null);\r\n    stopCropStreaming();\r\n    redrawCanvas();\r\n  };\r\n\r\n  // Render crop controls - modified to add \"full data\" checkbox\r\n  const renderCropControls = () => {\r\n    return (\r\n      <div style={floatingComponentStyles.cropControls}>\r\n        <h4 style={floatingComponentStyles.cropTitle}>Crop Frame Settings</h4>\r\n        \r\n        <div style={floatingComponentStyles.cropInputGroup}>\r\n          <label style={floatingComponentStyles.cropLabel}>X Min:</label>\r\n          <input \r\n            type=\"number\" \r\n            value={cropRange[0]} \r\n            onChange={(e) => handleCropRangeChange(0, e.target.value)}\r\n            style={floatingComponentStyles.cropInput}\r\n            disabled={!isCameraActive}\r\n          />\r\n          \r\n          <label style={floatingComponentStyles.cropLabel}>Y Min:</label>\r\n          <input \r\n            type=\"number\" \r\n            value={cropRange[1]} \r\n            onChange={(e) => handleCropRangeChange(1, e.target.value)}\r\n            style={floatingComponentStyles.cropInput}\r\n            disabled={!isCameraActive}\r\n          />\r\n        </div>\r\n        \r\n        <div style={floatingComponentStyles.cropInputGroup}>\r\n          <label style={floatingComponentStyles.cropLabel}>X Max:</label>\r\n          <input \r\n            type=\"number\" \r\n            value={cropRange[2]} \r\n            onChange={(e) => handleCropRangeChange(2, e.target.value)}\r\n            style={floatingComponentStyles.cropInput}\r\n            disabled={!isCameraActive}\r\n          />\r\n          \r\n          <label style={floatingComponentStyles.cropLabel}>Y Max:</label>\r\n          <input \r\n            type=\"number\" \r\n            value={cropRange[3]} \r\n            onChange={(e) => handleCropRangeChange(3, e.target.value)}\r\n            style={floatingComponentStyles.cropInput}\r\n            disabled={!isCameraActive}\r\n          />\r\n        </div>\r\n        \r\n        <div style={floatingComponentStyles.cropInputGroup}>\r\n          <label style={floatingComponentStyles.cropLabel}>Interval (ms):</label>\r\n          <input \r\n            type=\"number\" \r\n            value={cropInterval} \r\n            onChange={(e) => setCropInterval(parseInt(e.target.value) || 0)}\r\n            style={floatingComponentStyles.cropInput}\r\n            min=\"0\"\r\n            step=\"100\"\r\n            disabled={!isCameraActive}\r\n          />\r\n          <div style={floatingComponentStyles.cropHint}>\r\n            0 = single capture\r\n          </div>\r\n        </div>\r\n        \r\n        <div style={floatingComponentStyles.cropButtonGroup}>\r\n          <button\r\n            style={buttonVariants.smallSecondary}\r\n            onClick={toggleCropMode}\r\n            disabled={!isCameraActive}\r\n          >\r\n            {isCropMode ? 'Exit Crop Mode' : 'Enter Crop Mode'}\r\n          </button>\r\n          \r\n          <button\r\n            style={buttonVariants.smallSecondary}\r\n            onClick={resetCrop}\r\n            disabled={!isCameraActive || cropRange.every(val => val === 0)}\r\n          >\r\n            Reset Crop\r\n          </button>\r\n        </div>\r\n        \r\n        <div style={floatingComponentStyles.checkboxGroup}>\r\n          <label style={floatingComponentStyles.checkboxLabel}>\r\n            <input\r\n              type=\"checkbox\"\r\n              checked={streamCropImage}\r\n              onChange={(e) => setStreamCropImage(e.target.checked)}\r\n              style={floatingComponentStyles.checkbox}\r\n              disabled={!isCameraActive}\r\n            />\r\n            Stream Image\r\n          </label>\r\n          \r\n          <label style={floatingComponentStyles.checkboxLabel}>\r\n            <input\r\n              type=\"checkbox\"\r\n              checked={cropToGraph}\r\n              onChange={(e) => setCropToGraph(e.target.checked)}\r\n              style={floatingComponentStyles.checkbox}\r\n              disabled={!isCameraActive}\r\n            />\r\n            To Graph\r\n          </label>\r\n          \r\n          <label style={floatingComponentStyles.checkboxLabel}>\r\n            <input\r\n              type=\"checkbox\"\r\n              checked={sendFullData}\r\n              onChange={(e) => setSendFullData(e.target.checked)}\r\n              style={floatingComponentStyles.checkbox}\r\n              disabled={!isCameraActive}\r\n            />\r\n            Full Data\r\n          </label>\r\n        </div>\r\n        \r\n        <div style={floatingComponentStyles.cropButtonGroup}>\r\n          {!isCropStreaming ? (\r\n            <button\r\n              style={buttonVariants.smallPrimary}\r\n              onClick={startCropStreaming}\r\n              disabled={!isCameraActive || cropRange.every(val => val === 0) || (!streamCropImage && !cropToGraph)}\r\n            >\r\n              {cropInterval > 0 ? 'Start Streaming' : 'Capture Frame'}\r\n            </button>\r\n          ) : (\r\n            <button\r\n              style={{...buttonVariants.smallPrimary, backgroundColor: 'rgba(255, 50, 50, 0.7)'}}\r\n              onClick={stopCropStreaming}\r\n            >\r\n              Stop Streaming\r\n            </button>\r\n          )}\r\n        </div>\r\n      </div>\r\n    );\r\n  };\r\n\r\n  // Render crop preview\r\n  const renderCropPreview = () => {\r\n    return (\r\n      <div style={floatingComponentStyles.cropPreviewContainer}>\r\n        <h4 style={floatingComponentStyles.cropTitle}>Crop Preview</h4>\r\n        {cropPreviewImage ? (\r\n          <img \r\n            src={cropPreviewImage}\r\n            alt=\"Cropped preview\"\r\n            style={floatingComponentStyles.cropPreviewImage}\r\n          />\r\n        ) : (\r\n          <div style={floatingComponentStyles.cropPreviewPlaceholder}>\r\n            No crop preview available\r\n          </div>\r\n        )}\r\n      </div>\r\n    );\r\n  };\r\n\r\n  // Function to render the configuration menu\r\n  const renderConfigMenu = () => {\r\n    // Handler for input changes within the config menu\r\n    const handleConfigChange = (section, key, value) => {\r\n      setPendingConfig(prev => {\r\n        const newConfig = JSON.parse(JSON.stringify(prev)); // Deep copy\r\n        if (section === 'roi') {\r\n          // ROI is an array [x, y, w, h]\r\n          const roiIndex = {'x': 0, 'y': 1, 'w': 2, 'h': 3}[key];\r\n          newConfig.processing.roi[roiIndex] = parseInt(value) || 0;\r\n        } else {\r\n          newConfig[section][key] = value;\r\n        }\r\n        \r\n        // Trigger redraw immediately after ROI change\r\n        if (section === 'roi') {\r\n          requestAnimationFrame(redrawCanvas);\r\n        }\r\n        return newConfig;\r\n      });\r\n    };\r\n    \r\n    // Handler to send config update\r\n    const applyConfigChanges = () => {\r\n      if (pendingConfig) {\r\n        sendCameraConfigUpdate(pendingConfig);\r\n      }\r\n    };\r\n\r\n    if (!pendingConfig) {\r\n      return <div>Loading configuration...</div>; // Or some loading indicator\r\n    }\r\n    \r\n    const roi = pendingConfig.processing.roi || [0, 0, 0, 0];\r\n    \r\n    return (\r\n      <div style={floatingComponentStyles.configMenuContainer}>\r\n        <h4>Camera Configuration</h4>\r\n        \r\n        {/* Exposure Settings */}\r\n        <div style={floatingComponentStyles.configRow}>\r\n          <label style={floatingComponentStyles.configLabel}>Exposure Time (μs):</label>\r\n          <input \r\n            type=\"number\"\r\n            value={pendingConfig.camera.exposure_time || ''}\r\n            onChange={(e) => handleConfigChange('camera', 'exposure_time', e.target.value)}\r\n            style={floatingComponentStyles.configInput}\r\n            disabled={pendingConfig.camera.exposure_mode !== 'manual'}\r\n          />\r\n        </div>\r\n        <div style={floatingComponentStyles.configRow}>\r\n          <label style={floatingComponentStyles.configLabel}>Exposure Mode:</label>\r\n          <select\r\n            value={pendingConfig.camera.exposure_mode || 'auto'}\r\n            onChange={(e) => handleConfigChange('camera', 'exposure_mode', e.target.value)}\r\n            style={floatingComponentStyles.configInput}\r\n          >\r\n            <option value=\"auto\">Auto</option>\r\n            <option value=\"manual\">Manual</option>\r\n          </select>\r\n        </div>\r\n        \r\n        {/* ISO Setting */}\r\n        <div style={floatingComponentStyles.configRow}>\r\n          <label style={floatingComponentStyles.configLabel}>ISO:</label>\r\n          <input \r\n            type=\"number\"\r\n            value={pendingConfig.camera.iso || ''} // Handle null case\r\n            onChange={(e) => handleConfigChange('camera', 'iso', e.target.value ? parseInt(e.target.value) : null)} // Send null if empty\r\n            style={floatingComponentStyles.configInput}\r\n            min=\"100\" // Example range, adjust as needed\r\n            max=\"1600\"\r\n            step=\"100\"\r\n          />\r\n        </div>\r\n        \r\n        <button \r\n          style={{...buttonVariants.smallPrimary, marginTop: '10px'}}\r\n          onClick={applyConfigChanges}\r\n        >\r\n          Apply Configuration\r\n        </button>\r\n      </div>\r\n    );\r\n  };\r\n  \r\n  // Function to send camera configuration update via MQTT\r\n  const sendCameraConfigUpdate = (configToSend) => {\r\n    if (mqttClient && mqttClient.readyState === WebSocket.OPEN) {\r\n      const message = {\r\n        topic: `${mqttTopic}/request/set_config`, // Assuming this is the topic the backend listens on\r\n        payload: configToSend\r\n      };\r\n      console.log(\"Sending config update:\", message);\r\n      mqttClient.send(JSON.stringify(message));\r\n      setLastPublishedMessage(message);\r\n      // Optional: Maybe reset pendingConfig or wait for confirmation?\r\n    } else {\r\n      console.error('Cannot send config: WebSocket not connected');\r\n    }\r\n  };\r\n\r\n  // Centralized drawing function\r\n  const redrawCanvas = () => {\r\n    if (!canvasRef.current || !imageRef.current) return;\r\n\r\n    const canvas = canvasRef.current;\r\n    const ctx = canvas.getContext('2d');\r\n    const image = imageRef.current;\r\n\r\n    // Clear canvas\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n    // Draw image\r\n    ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\r\n\r\n    // Draw line if we have valid coordinates\r\n    if (currentLine && currentLine.start && currentLine.end) {\r\n      ctx.beginPath();\r\n      ctx.moveTo(currentLine.start.x, currentLine.start.y);\r\n      ctx.lineTo(currentLine.end.x, currentLine.end.y);\r\n      ctx.strokeStyle = 'red';\r\n      ctx.lineWidth = 1;\r\n      ctx.stroke();\r\n    }\r\n    \r\n    // Draw crop rectangle if in crop mode and we have valid coordinates\r\n    if (isCropMode && cropRange && cropRange.some(val => val !== 0)) {\r\n      const [x_min, y_min, x_max, y_max] = cropRange;\r\n      \r\n      // Draw rectangle\r\n      ctx.beginPath();\r\n      ctx.rect(x_min, y_min, x_max - x_min, y_max - y_min);\r\n      \r\n      // Use green while drawing, yellow when set\r\n      if (isDrawingCrop) {\r\n        ctx.strokeStyle = 'green';\r\n        ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';\r\n      } else {\r\n        ctx.strokeStyle = 'yellow';\r\n        ctx.fillStyle = 'rgba(255, 255, 0, 0.1)';\r\n      }\r\n      \r\n      ctx.lineWidth = 2;\r\n      ctx.stroke();\r\n      \r\n      // Semi-transparent fill\r\n      ctx.fill();\r\n      \r\n      // Draw corner markers\r\n      const markerSize = 5;\r\n      ctx.fillStyle = isDrawingCrop ? 'green' : 'yellow';\r\n      \r\n      // Top-left\r\n      ctx.fillRect(x_min - markerSize, y_min - markerSize, markerSize * 2, markerSize * 2);\r\n      // Top-right\r\n      ctx.fillRect(x_max - markerSize, y_min - markerSize, markerSize * 2, markerSize * 2);\r\n      // Bottom-left\r\n      ctx.fillRect(x_min - markerSize, y_max - markerSize, markerSize * 2, markerSize * 2);\r\n      // Bottom-right\r\n      ctx.fillRect(x_max - markerSize, y_max - markerSize, markerSize * 2, markerSize * 2);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div style={floatingComponentStyles.container}>\r\n      <h3 style={floatingComponentStyles.title}>Spectrometer Feed</h3>\r\n      \r\n      {/* MQTT Topic input */}\r\n      <div style={floatingComponentStyles.mqttInputs}>\r\n        <label style={floatingComponentStyles.inputLabel}>MQTT Topic:</label>\r\n        <input \r\n          type=\"text\"\r\n          value={mqttTopic}\r\n          onChange={(e) => setMqttTopic(e.target.value)}\r\n          style={floatingComponentStyles.input}\r\n          disabled={isCameraActive}\r\n          placeholder=\"e.g. spectrometer_1\"\r\n        />\r\n      </div>\r\n      \r\n      {/* Polling interval */}\r\n      <div style={floatingComponentStyles.mqttInputs}>\r\n        <label style={floatingComponentStyles.inputLabel}>Poll Rate:</label>\r\n        <input \r\n          type=\"range\"\r\n          min=\"100\"\r\n          max=\"2000\"\r\n          step=\"100\"\r\n          value={pollingInterval}\r\n          onChange={(e) => setPollingInterval(parseInt(e.target.value))}\r\n          style={floatingComponentStyles.slider}\r\n          disabled={!isCameraActive}\r\n        />\r\n        <span style={floatingComponentStyles.value}>{pollingInterval}ms</span>\r\n      </div>\r\n      \r\n      {/* Camera view with line drawing capability */}\r\n      <div \r\n        ref={cameraContainerRef}\r\n        style={floatingComponentStyles.cameraView}\r\n        onMouseDown={isCameraActive ? (isCropMode ? startCropDrawing : startLineDrawing) : undefined}\r\n        onMouseMove={isCameraActive ? (isCropMode ? updateCropDrawing : updateLineDrawing) : undefined}\r\n        onMouseUp={isCameraActive ? (isCropMode ? finishCropDrawing : finishLineDrawing) : undefined}\r\n        onMouseLeave={isCameraActive ? (isCropMode ? finishCropDrawing : finishLineDrawing) : undefined}\r\n      >\r\n        {!isCameraActive && (\r\n          <div style={{ position: 'absolute', top: '50%', left: '50%', transform: 'translate(-50%, -50%)', color: '#999' }}>\r\n            Device feed will appear here when connected\r\n          </div>\r\n        )}\r\n        \r\n        <canvas \r\n          ref={canvasRef}\r\n          style={{\r\n            ...floatingComponentStyles.canvas,\r\n            aspectRatio: `${cameraSize.width} / ${cameraSize.height}`,\r\n            cursor: isCameraActive ? (isCropMode ? 'crosshair' : 'crosshair') : 'default'\r\n          }}\r\n          width={cameraSize.width}\r\n          height={cameraSize.height}\r\n        />\r\n        \r\n        {/* Drawing mode indicators */}\r\n        {isCameraActive && !isLineDrawn && !isDrawing && !isCropMode && (\r\n          <div style={floatingComponentStyles.overlayText}>\r\n            Click and drag to draw a line\r\n          </div>\r\n        )}\r\n        \r\n        {isCameraActive && isCropMode && !isDrawingCrop && (\r\n          <div style={floatingComponentStyles.overlayText}>\r\n            Click and drag to define crop region\r\n          </div>\r\n        )}\r\n        \r\n        {/* Drawing indicators */}\r\n        {isDrawing && (\r\n          <div style={floatingComponentStyles.overlayText}>\r\n            Drawing line...\r\n          </div>\r\n        )}\r\n        \r\n        {isDrawingCrop && (\r\n          <div style={floatingComponentStyles.overlayText}>\r\n            Drawing crop region...\r\n          </div>\r\n        )}\r\n        \r\n        {/* Connection status indicator */}\r\n        <div style={floatingComponentStyles.connectionStatusOverlay}>\r\n          <div style={{...floatingComponentStyles.statusIndicator, backgroundColor: isMqttConnected ? '#0f0' : '#f00' }}></div>\r\n          {isMqttConnected ? 'Connected' : 'Disconnected'}\r\n        </div>\r\n        \r\n        {/* Resize info overlay */}\r\n        {showResizeInfo && (\r\n          <div style={floatingComponentStyles.resizeInfo}>\r\n            {cameraSize.width} × {cameraSize.height}\r\n          </div>\r\n        )}\r\n        \r\n        {/* Resize handle */}\r\n        <div \r\n          style={floatingComponentStyles.resizeHandle}\r\n          onMouseDown={handleResizeStart}\r\n          title=\"Resize camera view\"\r\n        >\r\n          <svg width=\"12\" height=\"12\" viewBox=\"0 0 12 12\">\r\n            <path \r\n              d=\"M9,3 L3,9 M11,5 L5,11 M11,8 L8,11\" \r\n              stroke=\"white\" \r\n              strokeWidth=\"1.5\"\r\n              strokeLinecap=\"round\"\r\n            />\r\n          </svg>\r\n        </div>\r\n      </div>\r\n      \r\n      {/* Camera controls */}\r\n      {renderCameraControls()}\r\n      \r\n      {/* Add button to toggle config menu */}\r\n      <button \r\n        style={{...buttonVariants.smallSecondary, marginTop: '8px'}}\r\n        onClick={() => {\r\n          // Initialize default config if none exists\r\n          if (!pendingConfig) {\r\n            setPendingConfig({\r\n              camera: { \r\n                exposure_time: 10000, \r\n                exposure_mode: 'auto', \r\n                iso: 100,\r\n                resolution: [cameraSize.width, cameraSize.height]\r\n              },\r\n              processing: { \r\n                roi: [0, 0, cameraSize.width, cameraSize.height] \r\n              }\r\n            });\r\n          }\r\n          setShowConfigMenu(!showConfigMenu);\r\n        }}\r\n      >\r\n        {showConfigMenu ? 'Hide Config' : 'Show Config'}\r\n      </button>\r\n\r\n      {/* Configuration Menu (conditional rendering) */}\r\n      {showConfigMenu && renderConfigMenu()}\r\n      \r\n      {/* Line adjustment controls */}\r\n      {isLineDrawn && (\r\n        <div style={floatingComponentStyles.lineControls}>\r\n          <div style={floatingComponentStyles.controlRow}>\r\n            <label style={floatingComponentStyles.controlLabel}>Y Offset:</label>\r\n            <input \r\n              type=\"range\"\r\n              min=\"-50\"\r\n              max=\"50\"\r\n              value={lineYOffset}\r\n              onChange={handleLineYOffsetChange}\r\n              style={floatingComponentStyles.slider}\r\n            />\r\n            <span style={floatingComponentStyles.value}>{lineYOffset}px</span>\r\n          </div>\r\n          \r\n          <div style={floatingComponentStyles.controlRow}>\r\n            <label style={floatingComponentStyles.controlLabel}>X Offset:</label>\r\n            <input \r\n              type=\"range\"\r\n              min=\"-50\"\r\n              max=\"50\"\r\n              value={lineXOffset}\r\n              onChange={handleLineXOffsetChange}\r\n              style={floatingComponentStyles.slider}\r\n            />\r\n            <span style={floatingComponentStyles.value}>{lineXOffset}px</span>\r\n          </div>\r\n        </div>\r\n      )}\r\n      \r\n      {/* Crop controls and preview */}\r\n      <div style={floatingComponentStyles.cropSection}>\r\n        {renderCropControls()}\r\n        {renderCropPreview()}\r\n      </div>\r\n      \r\n      {/* Debug panel */}\r\n      {debugMode && (\r\n        <div style={floatingComponentStyles.debugPanel}>\r\n          <div style={{display: 'flex', justifyContent: 'space-between', marginBottom: '5px'}}>\r\n            <strong>MQTT Debug:</strong>\r\n            <button \r\n              onClick={() => setDebugMode(false)}\r\n              style={floatingComponentStyles.debugHideButton}\r\n            >\r\n              Hide\r\n            </button>\r\n          </div>\r\n          <div style={{margin: '4px 0'}}>Status: {isMqttConnected ? '✅ Connected' : '❌ Disconnected'}</div>\r\n          <div style={{margin: '4px 0'}}>Topic ID: <span style={{color: '#4CAF50'}}>{mqttTopic}</span></div>\r\n          <div style={{margin: '4px 0'}}>WebSocket Connection: <span style={{color: '#4CAF50'}}>{WS_URL}</span></div>\r\n          <div style={{margin: '4px 0'}}>MQTT Broker: {mqttSettings.protocol}://{mqttSettings.host}:{mqttSettings.port} (via WebSocket server)</div>\r\n          \r\n          {/* Display request waiting state */}\r\n          <div style={{margin: '4px 0'}}>\r\n            Waiting for full frame: <span style={{color: isWaitingForResponse ? '#f44336' : '#4CAF50'}}>\r\n              {isWaitingForResponse ? 'Yes' : 'No'}\r\n            </span>\r\n          </div>\r\n          <div style={{margin: '4px 0'}}>\r\n            Waiting for crop frame: <span style={{color: isWaitingForCropResponse ? '#f44336' : '#4CAF50'}}>\r\n              {isWaitingForCropResponse ? 'Yes' : 'No'}\r\n            </span>\r\n          </div>\r\n          \r\n          {/* Display aspect ratio and resolution information */}\r\n          <div style={floatingComponentStyles.debugInfoRow}>\r\n            <div>\r\n              <strong>Display:</strong> {cameraSize.width}x{cameraSize.height}\r\n            </div>\r\n            <div>\r\n              <strong>Aspect Ratio:</strong> {imageAspectRatio.toFixed(2)}\r\n            </div>\r\n            <div>\r\n              <strong>Resolution:</strong> {cameraResolution}\r\n            </div>\r\n          </div>\r\n          \r\n          <div style={floatingComponentStyles.debugMessageBlock}>\r\n            <div><strong>Last published:</strong></div>\r\n            <pre style={floatingComponentStyles.debugPre}>\r\n              {lastPublishedMessage ? JSON.stringify(lastPublishedMessage, null, 2) : 'None'}\r\n            </pre>\r\n          </div>\r\n          <div style={floatingComponentStyles.debugMessageBlock}>\r\n            <div><strong>Last received:</strong></div>\r\n            <pre style={floatingComponentStyles.debugPre}>\r\n              {lastReceivedMessage ? \r\n                (lastReceivedMessage.payload && typeof lastReceivedMessage.payload === 'object' && lastReceivedMessage.payload.image ? \r\n                  `${JSON.stringify({...lastReceivedMessage, payload: {...lastReceivedMessage.payload, image: '[Image data truncated]'}}, null, 2)}` : \r\n                  JSON.stringify(lastReceivedMessage, null, 2)\r\n                ) : 'None'}\r\n            </pre>\r\n          </div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n});\r\n\r\n// Add custom styles for crop features to floating component styles\r\nconst cropStyles = {\r\n  cropSection: {\r\n    display: 'flex',\r\n    flexDirection: 'row',\r\n    justifyContent: 'space-between',\r\n    marginTop: '15px',\r\n    gap: '15px',\r\n  },\r\n  cropControls: {\r\n    flex: '1',\r\n    padding: '10px',\r\n    backgroundColor: 'rgba(0, 0, 0, 0.05)',\r\n    borderRadius: '5px',\r\n    border: '1px solid rgba(0, 0, 0, 0.1)',\r\n  },\r\n  cropPreviewContainer: {\r\n    flex: '1',\r\n    padding: '10px',\r\n    backgroundColor: 'rgba(0, 0, 0, 0.05)',\r\n    borderRadius: '5px',\r\n    border: '1px solid rgba(0, 0, 0, 0.1)',\r\n    display: 'flex',\r\n    flexDirection: 'column',\r\n    alignItems: 'center',\r\n  },\r\n  cropTitle: {\r\n    margin: '0 0 10px 0',\r\n    fontSize: '14px',\r\n    fontWeight: 'bold',\r\n  },\r\n  cropInputGroup: {\r\n    display: 'flex',\r\n    alignItems: 'center',\r\n    marginBottom: '8px',\r\n    flexWrap: 'wrap',\r\n  },\r\n  cropLabel: {\r\n    width: '60px',\r\n    fontSize: '12px',\r\n  },\r\n  cropInput: {\r\n    width: '60px',\r\n    padding: '4px',\r\n    marginRight: '10px',\r\n    border: '1px solid #ccc',\r\n    borderRadius: '3px',\r\n  },\r\n  cropButtonGroup: {\r\n    display: 'flex',\r\n    justifyContent: 'space-between',\r\n    marginTop: '10px',\r\n    gap: '8px',\r\n  },\r\n  cropHint: {\r\n    fontSize: '11px',\r\n    color: '#666',\r\n    marginLeft: '5px',\r\n  },\r\n  cropPreviewImage: {\r\n    maxWidth: '100%',\r\n    maxHeight: '200px',\r\n    borderRadius: '3px',\r\n    border: '1px solid rgba(0, 0, 0, 0.2)',\r\n  },\r\n  cropPreviewPlaceholder: {\r\n    width: '100%',\r\n    height: '150px',\r\n    display: 'flex',\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    color: '#999',\r\n    fontSize: '12px',\r\n    border: '1px dashed #ccc',\r\n    borderRadius: '3px',\r\n  },\r\n  toGraphLabel: {\r\n    display: 'flex',\r\n    alignItems: 'center',\r\n    gap: '4px',\r\n    fontSize: '12px',\r\n    color: '#fff',\r\n    marginLeft: '8px'\r\n  },\r\n  toGraphCheckbox: {\r\n    margin: 0\r\n  },\r\n  checkboxGroup: {\r\n    display: 'flex',\r\n    alignItems: 'center',\r\n    justifyContent: 'space-between',\r\n    marginBottom: '10px'\r\n  },\r\n  checkboxLabel: {\r\n    display: 'flex',\r\n    alignItems: 'center',\r\n    gap: '4px',\r\n    fontSize: '12px',\r\n    color: '#fff',\r\n    cursor: 'pointer'\r\n  },\r\n  checkbox: {\r\n    margin: 0,\r\n    cursor: 'pointer'\r\n  },\r\n};\r\n\r\n// Add the crop styles to the floatingComponentStyles object\r\nObject.assign(floatingComponentStyles, cropStyles);\r\n\r\n// Add display name for debugging\r\nMQTTCameraComponent.displayName = 'MQTTCameraComponent';\r\n\r\nexport default MQTTCameraComponent; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}