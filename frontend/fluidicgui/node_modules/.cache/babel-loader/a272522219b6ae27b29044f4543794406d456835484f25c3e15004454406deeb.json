{"ast":null,"code":"/**\r\n * Utility functions for simulation component\r\n */\n\nimport { convertToHardwareValuesPump } from './pumpCalculations';\nexport const setOfMainLineNodes = ['connector', 'outlet', 'thermostat', \"led\", \"detector\", \"USBSpectrometer\", \"MQTTSpectrometer\"];\nexport const setOfSecondaryLineNodes = ['pump'];\n/**\r\n * Find the outlet node in the graph\r\n * @param {Array} nodes - Array of graph nodes\r\n * @returns {Object|null} The outlet node or null if not found\r\n */\nexport const findOutletNode = nodes => {\n  const outletNode = nodes.filter(node => node !== undefined).find(node => node.type === 'outlet');\n  if (!outletNode) {\n    console.error('No outlet node found');\n    return null;\n  }\n  return outletNode;\n};\n\n/**\r\n * Find the only node in the graph of a given type, if there is more than one, it will return the first one it finds\r\n * @param {Array} nodes - Array of graph nodes\r\n * @param {string} type - Type of the node to find\r\n * @returns {Object|null} The node or null if not found\r\n */\nexport const findOnlyNode = (nodes, type) => {\n  const onlyNode = nodes.find(node => node.type === type);\n  if (!onlyNode) {\n    console.error(`No ${type} node found`);\n    return null;\n  }\n  return onlyNode;\n};\n\n/**\r\n * Find the node furthest from the outlet in the graph (actually can search for furthest node in main line from any node)\r\n * @param {Object} outletNode - The outlet node\r\n * @param {Array} nodes - Array of graph nodes\r\n * @param {Array} links - Array of graph links\r\n * @returns {Object} The furthest node from outlet\r\n */\nexport const findFurthestNode = (outletNode, nodes, links) => {\n  const visited = new Set();\n  const queue = [[outletNode, 0]];\n  let furthestNode = outletNode;\n  let maxDistance = 0;\n  while (queue.length > 0) {\n    const [currentNode, distance] = queue.shift();\n    if (distance > maxDistance && !['pump', 'droplet'].includes(currentNode.type)) {\n      furthestNode = currentNode;\n      maxDistance = distance;\n    }\n    visited.add(currentNode.id);\n    const neighbors = links.filter(link => link.source === currentNode.id || link.target === currentNode.id).map(link => link.source === currentNode.id ? link.target : link.source).filter(nodeId => !visited.has(nodeId)).map(nodeId => nodes.find(n => n.id === nodeId));\n    for (const neighbor of neighbors) {\n      queue.push([neighbor, distance + 1]);\n    }\n  }\n  return furthestNode;\n};\n\n/**\r\n * Order nodes by their distance from the outlet\r\n * @param {Object} outletNode - The outlet node\r\n * @param {Array} nodes - Array of graph nodes\r\n * @param {Array} links - Array of graph links\r\n * @returns {Array} Ordered array of nodes with their distances\r\n */\nexport const orderNodesByDistance = (outletNode, nodes, links) => {\n  const visited = new Set();\n  const queue = [[outletNode, 0]];\n  const orderedNodes = [];\n  while (queue.length > 0) {\n    const [currentNode, distance] = queue.shift();\n    //console.log('currentNode: ', currentNode);\n    if (!visited.has(currentNode.id)) {\n      visited.add(currentNode.id);\n      orderedNodes.push({\n        node: currentNode,\n        distance\n      });\n      const neighbors = links.filter(link => link.target === currentNode.id).map(link => link.source === currentNode.id ? link.target : link.source).filter(nodeId => !visited.has(nodeId)).map(nodeId => nodes.find(n => n.id === nodeId)).filter(node => node !== undefined);\n      //console.log('neighbors: ', neighbors);\n      for (const neighbor of neighbors) {\n        queue.push([neighbor, distance + 1]);\n      }\n    }\n  }\n  return orderedNodes.sort((a, b) => a.distance - b.distance);\n};\n\n/**\r\n * Calculate the volume of an edge\r\n * @param {Object} edge - Edge object with diameter and length properties\r\n * @returns {number} Volume of the edge in μL\r\n */\nexport const calculateEdgeVolume = edge => {\n  // Ensure properties exist or use default values\n  const diameter = edge.diameter || 1;\n  const length = edge.length || 100;\n\n  // Log warning if properties are missing\n  if (!edge.diameter || !edge.length) {\n    console.warn('Edge missing properties:', edge);\n  }\n  const radius = diameter / 2;\n  const volume = Math.PI * radius * radius * length;\n  return volume;\n};\n\n/**\r\n * Get the volume between two nodes in the graph\r\n * @param {string} startNodeId - ID of the start node\r\n * @param {string} endNodeId - ID of the end node\r\n * @param {Array} nodes - Array of graph nodes\r\n * @param {Array} links - Array of graph links\r\n * @returns {number|null} Volume between nodes or null if path not found\r\n */\nexport const getVolumeBetweenNodes = (startNodeId, endNodeId, nodes, links) => {\n  const startNode = nodes.find(node => node.id === startNodeId);\n  const endNode = nodes.find(node => node.id === endNodeId);\n  if (!startNode || !endNode) {\n    console.error(`One or both nodes not found: ${startNodeId}, ${endNodeId}`);\n    return null;\n  }\n  const outletNode = findOutletNode(nodes);\n  const orderedNodes = orderNodesByDistance(outletNode, nodes, links);\n  const startIndex = orderedNodes.findIndex(({\n    node\n  }) => node.id === startNodeId);\n  const endIndex = orderedNodes.findIndex(({\n    node\n  }) => node.id === endNodeId);\n  if (startIndex === -1 || endIndex === -1) {\n    console.error(\"One or both nodes not found in ordered nodes\");\n    return null;\n  }\n  let nodesOfInterest = orderedNodes.slice(Math.min(startIndex, endIndex), Math.max(startIndex, endIndex) + 1);\n  nodesOfInterest = nodesOfInterest.filter(({\n    node\n  }) => setOfMainLineNodes.includes(node.type));\n  let volume = 0;\n  for (let i = 0; i < nodesOfInterest.length - 1; i++) {\n    const currentNode = nodesOfInterest[i].node;\n    const nextNode = nodesOfInterest[i + 1].node;\n    const edge = links.find(link => link.source === currentNode.id && link.target === nextNode.id || link.target === currentNode.id && link.source === nextNode.id);\n    if (edge) {\n      const edgeVolume = calculateEdgeVolume(edge);\n      volume += edgeVolume;\n    } else {\n      console.error(`Edge not found between nodes ${currentNode.id} and ${nextNode.id}`);\n      return null;\n    }\n  }\n  return volume;\n};\n\n/**\r\n * Find the pump connected to a connector node\r\n * @param {string} connectorId - ID of the connector node\r\n * @param {Array} nodes - Array of graph nodes\r\n * @param {Array} links - Array of graph links\r\n * @returns {Object|null} Connected pump node or null if not found\r\n */\nexport const findConnectedPump = (connectorId, nodes, links) => {\n  const pump = links.find(link => link.target === connectorId && nodes.find(node => node.id === link.source).type === 'pump');\n  return pump ? nodes.find(node => node.id === pump.source) : null;\n};\n\n/**\r\n * Get pump speed at a specific time from event list\r\n * @param {string} pumpId - ID of the pump\r\n * @param {Array} eventList - List of pump events\r\n * @param {number} timePassed - Current time\r\n * @returns {number} Current pump speed\r\n */\nexport const getPumpSpeed = (pumpId, eventList, timePassed) => {\n  let lastSpeed = 0;\n  eventList.forEach(event => {\n    if (event.target === pumpId && event.time < timePassed) {\n      lastSpeed = event.value;\n    }\n  });\n  return lastSpeed;\n};\n\n/**\r\n * Get all pumps between two volumetric positions\r\n * @param {number} frontVolumetricPosition - Front position\r\n * @param {number} rearVolumetricPosition - Rear position\r\n * @param {Array} nodes - Array of graph nodes\r\n * @returns {Array} Array of pump nodes between positions\r\n */\nexport const getPumpsBetweenPositions = (frontVolumetricPosition, rearVolumetricPosition, nodes, links) => {\n  const connectorsBetweenPositions = nodes.filter(node => node.type === 'connector' && node.volumetricPosition >= rearVolumetricPosition && node.volumetricPosition <= frontVolumetricPosition);\n  const pumpsBetweenPositions = connectorsBetweenPositions.map(connector => findConnectedPump(connector.id, nodes, links)).filter(pump => pump !== null);\n  return pumpsBetweenPositions;\n};\n\n/**\r\n * Clean and sort event list by removing redundant events\r\n * @param {Array} eventList - List of events to clean and sort\r\n * @returns {Array} Cleaned and sorted event list\r\n */\nexport const cleanAndSortEventList = eventList => {\n  const uniqueIds = [...new Set(eventList.map(event => event.target))];\n  const idEvents = uniqueIds.map(id => eventList.filter(event => event.target === id));\n\n  // Process events for each ID to remove meaningless ones\n  idEvents.forEach((events, index) => {\n    let filteredEvents = [];\n    let prevEvent = null;\n    for (let i = 0; i < events.length; i++) {\n      const currentEvent = events[i];\n\n      // Skip if same value as previous event\n      if (prevEvent && prevEvent.value === currentEvent.value) {\n        continue;\n      }\n      filteredEvents.push(currentEvent);\n      prevEvent = currentEvent;\n    }\n    idEvents[index] = filteredEvents;\n  });\n\n  // Additional filtering passes\n  idEvents.forEach((events, index) => {\n    let filteredEvents = [];\n    let prevEvent = null;\n    for (let i = 0; i < events.length; i++) {\n      const currentEvent = events[i];\n      const nextEvent = events[i + 1];\n\n      // Skip if next event has same time and value as previous\n      if (nextEvent && nextEvent.time === currentEvent.time && prevEvent && nextEvent.value === prevEvent.value) {\n        continue;\n      }\n      filteredEvents.push(currentEvent);\n      prevEvent = currentEvent;\n    }\n    idEvents[index] = filteredEvents;\n  });\n  return idEvents;\n};\n\n/**\r\n * Get pump speed at a specific time\r\n * @param {string} pumpId - ID of the pump\r\n * @param {Array} pumpEvents - List of pump events\r\n * @param {number} currentTime - Current time\r\n * @returns {number} Current pump speed\r\n */\nexport const getPumpSpeedAtTime = (pumpId, pumpEvents, currentTime) => {\n  const relevantEvents = pumpEvents.filter(event => event.target === pumpId && event.time <= currentTime).sort((a, b) => b.time - a.time);\n  return relevantEvents.length > 0 ? relevantEvents[0].value : 0;\n};\n\n/**\r\n * Send events to devices via WebSocket\r\n * @param {Array} pumpEvents - List of pump events\r\n * @param {WebSocket} ws - WebSocket connection\r\n * @param {Array} nodes - Array of graph nodes\r\n * @param {Function} convertToHardwareValues - Function to convert values to hardware format\r\n * @returns {void}\r\n */\nexport const sendEventsToDevices = (pumpEvents, ws, nodes) => {\n  if (!ws || ws.readyState !== WebSocket.OPEN) {\n    console.error('WebSocket is not connected');\n    return;\n  }\n  if (!pumpEvents || !Array.isArray(pumpEvents) || pumpEvents.length === 0) {\n    console.error('No pump events to send');\n    return;\n  }\n  console.log('Sending events to devices:', pumpEvents);\n\n  // Group events by device\n  const deviceEvents = new Map();\n  pumpEvents.forEach(event => {\n    var _node$data;\n    const node = nodes.find(n => n.id === event.target);\n    if (!node || !((_node$data = node.data) !== null && _node$data !== void 0 && _node$data.MQTTname)) {\n      console.error('No MQTTname found for node:', node);\n      return;\n    }\n    if (!deviceEvents.has(node.data.MQTTname)) {\n      deviceEvents.set(node.data.MQTTname, []);\n    }\n    const hardwareValues = convertToHardwareValuesPump({\n      volume: 0,\n      speed: event.value\n    }, node.data.properties);\n    deviceEvents.get(node.data.MQTTname).push([hardwareValues.delayMicroseconds, Math.round(event.time * 1000000)]);\n  });\n  let deviceEntries = Array.from(deviceEvents.entries());\n  console.log('Device events:', deviceEntries);\n  deviceEntries.forEach(([deviceName, events]) => {\n    for (let i = events.length - 1; i > 0; i--) {\n      events[i][1] = events[i][1] - events[i - 1][1];\n    }\n  });\n  deviceEntries.forEach(([deviceName, events], deviceIndex) => {\n    const chunks = [];\n    for (let i = 0; i < events.length; i += 5) {\n      chunks.push(events.slice(i, i + 5));\n    }\n    const sendChunks = async () => {\n      if (chunks.length > 0) {\n        try {\n          const firstMessage = {\n            topic: `${deviceName}/new_program`,\n            payload: chunks[0]\n          };\n          console.log('Sending new program to device:', deviceName, firstMessage);\n          ws.send(JSON.stringify(firstMessage));\n          const delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n          for (let i = 1; i < chunks.length; i++) {\n            await delay(2);\n            const message = {\n              topic: `${deviceName}/continue_program`,\n              payload: chunks[i]\n            };\n            console.log('Sending continue program to device:', deviceName, message);\n            ws.send(JSON.stringify(message));\n          }\n          await delay(2);\n          const runMessage = {\n            topic: `${deviceName}/${deviceIndex === 0 ? 'run_master' : 'run_slave'}`,\n            payload: \"run\"\n          };\n          console.log('Sending run command to device:', deviceName, runMessage);\n          ws.send(JSON.stringify(runMessage));\n        } catch (error) {\n          console.error('Error sending messages to device:', deviceName, error);\n        }\n      }\n    };\n    sendChunks().catch(error => {\n      console.error('Error in sendChunks:', error);\n    });\n  });\n};\n\n/**\r\n * Divide droplets into blocks based on thermostat volumes\r\n * @param {Array} droplets - Array of droplet objects\r\n * @param {Array} thermostatVolumes - Array of thermostat volume objects\r\n * @param {Array} nodes - Array of graph nodes\r\n * @param {Array} links - Array of graph links\r\n * @returns {Array} Array of blocks containing droplets\r\n */\nexport const divideDropletsIntoBlocks = (droplets, thermostatVolumes, nodes, links) => {\n  if (thermostatVolumes.length === 0) {\n    return [{\n      droplets: droplets,\n      thermostatId: null,\n      totalVolume: droplets.reduce((acc, droplet) => acc + droplet.actualVolume, 0),\n      temperature: null,\n      time: null\n    }];\n  }\n  const outletNode = findOutletNode(nodes);\n  const furthestNode = findFurthestNode(outletNode, nodes, links);\n  const volumeToFurthestNode = getVolumeBetweenNodes(thermostatVolumes[0].endThermostatId, furthestNode.id, nodes, links);\n  if (!droplets.length || !thermostatVolumes.length) return [];\n  const blocks = [];\n  let currentBlock = {\n    droplets: [],\n    thermostatId: thermostatVolumes[0].endThermostatId,\n    totalVolume: 0,\n    temperature: null,\n    time: null\n  };\n\n  // Helper to finalize a block and start a new one\n  const finalizeBlock = (thermostatId, temperature, time) => {\n    if (currentBlock.droplets.length > 0) {\n      // Add volumeToFurthestNode to the surfixVolume of the last droplet in the block\n      const lastDroplet = currentBlock.droplets[currentBlock.droplets.length - 1];\n      const surfixParam = lastDroplet.parameters.find(p => p.name === 'surfixVolume');\n      if (surfixParam) {\n        surfixParam.value = Math.max(volumeToFurthestNode, surfixParam.value);\n      } else {\n        lastDroplet.parameters.push({\n          name: 'surfixVolume',\n          value: volumeToFurthestNode\n        });\n      }\n      blocks.push({\n        ...currentBlock\n      });\n    }\n    currentBlock = {\n      droplets: [],\n      thermostatId: thermostatId,\n      totalVolume: 0,\n      temperature: temperature,\n      time: time\n    };\n  };\n\n  // Process droplets in order\n  for (let i = 0; i < droplets.length; i++) {\n    var _droplet$parameters$f, _droplet$parameters$f2, _droplet$parameters$f3, _droplet$parameters$f4, _droplet$parameters$f5;\n    const droplet = droplets[i];\n    const temperature = (_droplet$parameters$f = droplet.parameters.find(p => p.name === 'temperature')) === null || _droplet$parameters$f === void 0 ? void 0 : _droplet$parameters$f.value;\n    const time = (_droplet$parameters$f2 = droplet.parameters.find(p => p.name === 'time')) === null || _droplet$parameters$f2 === void 0 ? void 0 : _droplet$parameters$f2.value;\n\n    // Start new block if temperature or time changes, or if volume limit exceeded\n    const relevantVolume = thermostatVolumes.find(tv => tv.startThermostatId === currentBlock.thermostatId || tv.endThermostatId === currentBlock.thermostatId);\n    let dropletVolume = (_droplet$parameters$f3 = droplet.parameters.find(p => p.name === 'volume')) === null || _droplet$parameters$f3 === void 0 ? void 0 : _droplet$parameters$f3.value;\n    dropletVolume += (_droplet$parameters$f4 = droplet.parameters.find(p => p.name === 'prefixVolume')) === null || _droplet$parameters$f4 === void 0 ? void 0 : _droplet$parameters$f4.value;\n    if (currentBlock.temperature !== temperature || currentBlock.time !== time || relevantVolume && currentBlock.totalVolume + dropletVolume > relevantVolume.volume) {\n      finalizeBlock(thermostatVolumes[0].endThermostatId, temperature, time);\n    }\n    dropletVolume += (_droplet$parameters$f5 = droplet.parameters.find(p => p.name === 'surfixVolume')) === null || _droplet$parameters$f5 === void 0 ? void 0 : _droplet$parameters$f5.value;\n    // Add droplet to current block\n    currentBlock.droplets.push(droplet);\n    currentBlock.totalVolume += dropletVolume;\n    currentBlock.temperature = temperature;\n    currentBlock.time = time;\n  }\n\n  // Finalize last block\n  finalizeBlock(null, null, null);\n  return blocks;\n};\n\n/**\r\n * Print droplet front positions and speeds for debugging\r\n * @param {Array} droplets - Array of droplet objects\r\n */\nexport const printDropletFrontPositionsAndSpeeds = droplets => {\n  droplets.forEach(droplet => {\n    console.log(`Droplet ID: ${droplet.id}, ` + `Front Volumetric Position: ${droplet.frontVolumetricPosition}, ` + `Front time to next node: ${droplet.frontTimeToReachNextNode}, ` + `Front Volumetric Distance to next node: ${droplet.frontVolumetricDistanceToNextNode}, ` + `Rear Volumetric Position: ${droplet.rearVolumetricPosition}, ` + `Rear time to next node: ${droplet.rearTimeToReachNextNode}, ` + `Rear Volumetric Distance to next node: ${droplet.rearVolumetricDistanceToNextNode}, ` + `frontNextNodeID: ${droplet.frontNextNodeID}, ` + `rearNextNodeID: ${droplet.rearNextNodeID}`);\n  });\n};","map":{"version":3,"names":["convertToHardwareValuesPump","setOfMainLineNodes","setOfSecondaryLineNodes","findOutletNode","nodes","outletNode","filter","node","undefined","find","type","console","error","findOnlyNode","onlyNode","findFurthestNode","links","visited","Set","queue","furthestNode","maxDistance","length","currentNode","distance","shift","includes","add","id","neighbors","link","source","target","map","nodeId","has","n","neighbor","push","orderNodesByDistance","orderedNodes","sort","a","b","calculateEdgeVolume","edge","diameter","warn","radius","volume","Math","PI","getVolumeBetweenNodes","startNodeId","endNodeId","startNode","endNode","startIndex","findIndex","endIndex","nodesOfInterest","slice","min","max","i","nextNode","edgeVolume","findConnectedPump","connectorId","pump","getPumpSpeed","pumpId","eventList","timePassed","lastSpeed","forEach","event","time","value","getPumpsBetweenPositions","frontVolumetricPosition","rearVolumetricPosition","connectorsBetweenPositions","volumetricPosition","pumpsBetweenPositions","connector","cleanAndSortEventList","uniqueIds","idEvents","events","index","filteredEvents","prevEvent","currentEvent","nextEvent","getPumpSpeedAtTime","pumpEvents","currentTime","relevantEvents","sendEventsToDevices","ws","readyState","WebSocket","OPEN","Array","isArray","log","deviceEvents","Map","_node$data","data","MQTTname","set","hardwareValues","speed","properties","get","delayMicroseconds","round","deviceEntries","from","entries","deviceName","deviceIndex","chunks","sendChunks","firstMessage","topic","payload","send","JSON","stringify","delay","ms","Promise","resolve","setTimeout","message","runMessage","catch","divideDropletsIntoBlocks","droplets","thermostatVolumes","thermostatId","totalVolume","reduce","acc","droplet","actualVolume","temperature","volumeToFurthestNode","endThermostatId","blocks","currentBlock","finalizeBlock","lastDroplet","surfixParam","parameters","p","name","_droplet$parameters$f","_droplet$parameters$f2","_droplet$parameters$f3","_droplet$parameters$f4","_droplet$parameters$f5","relevantVolume","tv","startThermostatId","dropletVolume","printDropletFrontPositionsAndSpeeds","frontTimeToReachNextNode","frontVolumetricDistanceToNextNode","rearTimeToReachNextNode","rearVolumetricDistanceToNextNode","frontNextNodeID","rearNextNodeID"],"sources":["E:/flow chemistry/fluidicGUI/frontend/fluidicgui/src/utils/simulationUtils.js"],"sourcesContent":["/**\r\n * Utility functions for simulation component\r\n */\r\n\r\nimport { convertToHardwareValuesPump } from './pumpCalculations';\r\n\r\nexport const setOfMainLineNodes = ['connector', 'outlet', 'thermostat', \"led\", \"detector\", \"USBSpectrometer\", \"MQTTSpectrometer\"];\r\nexport const setOfSecondaryLineNodes = ['pump'];\r\n/**\r\n * Find the outlet node in the graph\r\n * @param {Array} nodes - Array of graph nodes\r\n * @returns {Object|null} The outlet node or null if not found\r\n */\r\nexport const findOutletNode = (nodes) => {\r\n  const outletNode = nodes.filter(node => node !== undefined).find(node => node.type === 'outlet');\r\n  if (!outletNode) {\r\n    console.error('No outlet node found');\r\n    return null;\r\n  }\r\n  return outletNode;\r\n};\r\n\r\n/**\r\n * Find the only node in the graph of a given type, if there is more than one, it will return the first one it finds\r\n * @param {Array} nodes - Array of graph nodes\r\n * @param {string} type - Type of the node to find\r\n * @returns {Object|null} The node or null if not found\r\n */\r\nexport const findOnlyNode = (nodes, type) => {\r\n    const onlyNode = nodes.find(node => node.type === type);\r\n    if (!onlyNode) {\r\n      console.error(`No ${type} node found`);\r\n      return null;\r\n    }\r\n    return onlyNode;\r\n  };\r\n\r\n/**\r\n * Find the node furthest from the outlet in the graph (actually can search for furthest node in main line from any node)\r\n * @param {Object} outletNode - The outlet node\r\n * @param {Array} nodes - Array of graph nodes\r\n * @param {Array} links - Array of graph links\r\n * @returns {Object} The furthest node from outlet\r\n */\r\nexport const findFurthestNode = (outletNode, nodes, links) => {\r\n  const visited = new Set();\r\n  const queue = [[outletNode, 0]];\r\n  let furthestNode = outletNode;\r\n  let maxDistance = 0;\r\n\r\n  while (queue.length > 0) {\r\n    const [currentNode, distance] = queue.shift();\r\n    \r\n    if (distance > maxDistance && !['pump', 'droplet'].includes(currentNode.type)) {\r\n      furthestNode = currentNode;\r\n      maxDistance = distance;\r\n    }\r\n\r\n    visited.add(currentNode.id);\r\n\r\n    const neighbors = links\r\n      .filter(link => link.source === currentNode.id || link.target === currentNode.id)\r\n      .map(link => link.source === currentNode.id ? link.target : link.source)\r\n      .filter(nodeId => !visited.has(nodeId))\r\n      .map(nodeId => nodes.find(n => n.id === nodeId));\r\n\r\n    for (const neighbor of neighbors) {\r\n      queue.push([neighbor, distance + 1]);\r\n    }\r\n  }\r\n  return furthestNode;\r\n};\r\n\r\n/**\r\n * Order nodes by their distance from the outlet\r\n * @param {Object} outletNode - The outlet node\r\n * @param {Array} nodes - Array of graph nodes\r\n * @param {Array} links - Array of graph links\r\n * @returns {Array} Ordered array of nodes with their distances\r\n */\r\nexport const orderNodesByDistance = (outletNode, nodes, links) => {\r\n  const visited = new Set();\r\n  const queue = [[outletNode, 0]];\r\n  const orderedNodes = [];\r\n\r\n  while (queue.length > 0) {\r\n    const [currentNode, distance] = queue.shift();\r\n    //console.log('currentNode: ', currentNode);\r\n    if (!visited.has(currentNode.id)) {\r\n      visited.add(currentNode.id);\r\n      orderedNodes.push({ node: currentNode, distance });\r\n      const neighbors = links\r\n        .filter(link => link.target === currentNode.id)\r\n        .map(link => link.source === currentNode.id ? link.target : link.source)\r\n        .filter(nodeId => !visited.has(nodeId))\r\n        .map(nodeId => nodes.find(n => n.id === nodeId))\r\n        .filter(node => node !== undefined);\r\n      //console.log('neighbors: ', neighbors);\r\n      for (const neighbor of neighbors) {\r\n\r\n        queue.push([neighbor, distance + 1]);\r\n        \r\n      }\r\n    }\r\n  }\r\n  return orderedNodes.sort((a, b) => a.distance - b.distance);\r\n};\r\n\r\n/**\r\n * Calculate the volume of an edge\r\n * @param {Object} edge - Edge object with diameter and length properties\r\n * @returns {number} Volume of the edge in μL\r\n */\r\nexport const calculateEdgeVolume = (edge) => {\r\n  // Ensure properties exist or use default values\r\n  const diameter = edge.diameter || 1;\r\n  const length = edge.length || 100;\r\n  \r\n  // Log warning if properties are missing\r\n  if (!edge.diameter || !edge.length) {\r\n    console.warn('Edge missing properties:', edge);\r\n  }\r\n  \r\n  const radius = diameter / 2;\r\n  const volume = Math.PI * radius * radius * length;\r\n  return volume;\r\n};\r\n\r\n/**\r\n * Get the volume between two nodes in the graph\r\n * @param {string} startNodeId - ID of the start node\r\n * @param {string} endNodeId - ID of the end node\r\n * @param {Array} nodes - Array of graph nodes\r\n * @param {Array} links - Array of graph links\r\n * @returns {number|null} Volume between nodes or null if path not found\r\n */\r\nexport const getVolumeBetweenNodes = (startNodeId, endNodeId, nodes, links) => {\r\n  const startNode = nodes.find(node => node.id === startNodeId);\r\n  const endNode = nodes.find(node => node.id === endNodeId);\r\n  if (!startNode || !endNode) {\r\n    console.error(`One or both nodes not found: ${startNodeId}, ${endNodeId}`);\r\n    return null;\r\n  }\r\n\r\n  const outletNode = findOutletNode(nodes);\r\n  const orderedNodes = orderNodesByDistance(outletNode, nodes, links);\r\n  const startIndex = orderedNodes.findIndex(({node}) => node.id === startNodeId);\r\n  const endIndex = orderedNodes.findIndex(({node}) => node.id === endNodeId);\r\n\r\n  if (startIndex === -1 || endIndex === -1) {\r\n    console.error(\"One or both nodes not found in ordered nodes\");\r\n    return null;\r\n  }\r\n\r\n  \r\n  let nodesOfInterest = orderedNodes.slice(\r\n    Math.min(startIndex, endIndex),\r\n    Math.max(startIndex, endIndex) + 1\r\n  );\r\n\r\n  nodesOfInterest = nodesOfInterest.filter(({node}) => \r\n    setOfMainLineNodes.includes(node.type)\r\n  );\r\n\r\n  let volume = 0;\r\n  for (let i = 0; i < nodesOfInterest.length - 1; i++) {\r\n    const currentNode = nodesOfInterest[i].node;\r\n    const nextNode = nodesOfInterest[i + 1].node;\r\n\r\n    const edge = links.find(link => \r\n      (link.source === currentNode.id && link.target === nextNode.id) ||\r\n      (link.target === currentNode.id && link.source === nextNode.id)\r\n    );\r\n    if (edge) {\r\n      const edgeVolume = calculateEdgeVolume(edge);\r\n      volume += edgeVolume;\r\n    } else {\r\n      console.error(`Edge not found between nodes ${currentNode.id} and ${nextNode.id}`);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  return volume;\r\n};\r\n\r\n/**\r\n * Find the pump connected to a connector node\r\n * @param {string} connectorId - ID of the connector node\r\n * @param {Array} nodes - Array of graph nodes\r\n * @param {Array} links - Array of graph links\r\n * @returns {Object|null} Connected pump node or null if not found\r\n */\r\nexport const findConnectedPump = (connectorId, nodes, links) => {\r\n  const pump = links.find(link => \r\n    link.target === connectorId && \r\n    nodes.find(node => node.id === link.source).type === 'pump'\r\n  );\r\n\r\n  return pump ? nodes.find(node => node.id === pump.source) : null;\r\n};\r\n\r\n/**\r\n * Get pump speed at a specific time from event list\r\n * @param {string} pumpId - ID of the pump\r\n * @param {Array} eventList - List of pump events\r\n * @param {number} timePassed - Current time\r\n * @returns {number} Current pump speed\r\n */\r\nexport const getPumpSpeed = (pumpId, eventList, timePassed) => {\r\n  let lastSpeed = 0;\r\n  eventList.forEach(event => {\r\n    if (event.target === pumpId && event.time < timePassed) {\r\n      lastSpeed = event.value;\r\n    }\r\n  });\r\n  return lastSpeed;\r\n};\r\n\r\n/**\r\n * Get all pumps between two volumetric positions\r\n * @param {number} frontVolumetricPosition - Front position\r\n * @param {number} rearVolumetricPosition - Rear position\r\n * @param {Array} nodes - Array of graph nodes\r\n * @returns {Array} Array of pump nodes between positions\r\n */\r\nexport const getPumpsBetweenPositions = (frontVolumetricPosition, rearVolumetricPosition, nodes, links) => {\r\n  const connectorsBetweenPositions = nodes.filter(node => \r\n    node.type === 'connector' && \r\n    node.volumetricPosition >= rearVolumetricPosition && \r\n    node.volumetricPosition <= frontVolumetricPosition\r\n  );\r\n\r\n  const pumpsBetweenPositions = connectorsBetweenPositions.map(connector => \r\n    findConnectedPump(connector.id, nodes, links)\r\n  ).filter(pump => pump !== null);\r\n\r\n  return pumpsBetweenPositions;\r\n};\r\n\r\n/**\r\n * Clean and sort event list by removing redundant events\r\n * @param {Array} eventList - List of events to clean and sort\r\n * @returns {Array} Cleaned and sorted event list\r\n */\r\nexport const cleanAndSortEventList = (eventList) => {\r\n  const uniqueIds = [...new Set(eventList.map(event => event.target))];\r\n  const idEvents = uniqueIds.map(id => eventList.filter(event => event.target === id));\r\n\r\n  // Process events for each ID to remove meaningless ones\r\n  idEvents.forEach((events, index) => {\r\n    let filteredEvents = [];\r\n    let prevEvent = null;\r\n\r\n    for (let i = 0; i < events.length; i++) {\r\n      const currentEvent = events[i];\r\n      \r\n      // Skip if same value as previous event\r\n      if (prevEvent && prevEvent.value === currentEvent.value) {\r\n        continue;\r\n      }\r\n\r\n      filteredEvents.push(currentEvent);\r\n      prevEvent = currentEvent;\r\n    }\r\n\r\n    idEvents[index] = filteredEvents;\r\n  });\r\n\r\n  // Additional filtering passes\r\n  idEvents.forEach((events, index) => {\r\n    let filteredEvents = [];\r\n    let prevEvent = null;\r\n\r\n    for (let i = 0; i < events.length; i++) {\r\n      const currentEvent = events[i];\r\n      const nextEvent = events[i + 1];\r\n\r\n      // Skip if next event has same time and value as previous\r\n      if (nextEvent && \r\n          nextEvent.time === currentEvent.time && \r\n          prevEvent && \r\n          nextEvent.value === prevEvent.value) {\r\n        continue;\r\n      }\r\n\r\n      filteredEvents.push(currentEvent);\r\n      prevEvent = currentEvent;\r\n    }\r\n\r\n    idEvents[index] = filteredEvents;\r\n  });\r\n\r\n  return idEvents;\r\n};\r\n\r\n/**\r\n * Get pump speed at a specific time\r\n * @param {string} pumpId - ID of the pump\r\n * @param {Array} pumpEvents - List of pump events\r\n * @param {number} currentTime - Current time\r\n * @returns {number} Current pump speed\r\n */\r\nexport const getPumpSpeedAtTime = (pumpId, pumpEvents, currentTime) => {\r\n  const relevantEvents = pumpEvents\r\n    .filter(event => event.target === pumpId && event.time <= currentTime)\r\n    .sort((a, b) => b.time - a.time);\r\n  \r\n  return relevantEvents.length > 0 ? relevantEvents[0].value : 0;\r\n};\r\n\r\n/**\r\n * Send events to devices via WebSocket\r\n * @param {Array} pumpEvents - List of pump events\r\n * @param {WebSocket} ws - WebSocket connection\r\n * @param {Array} nodes - Array of graph nodes\r\n * @param {Function} convertToHardwareValues - Function to convert values to hardware format\r\n * @returns {void}\r\n */\r\nexport const sendEventsToDevices = (pumpEvents, ws, nodes) => {\r\n  if (!ws || ws.readyState !== WebSocket.OPEN) {\r\n    console.error('WebSocket is not connected');\r\n    return;\r\n  }\r\n\r\n  if (!pumpEvents || !Array.isArray(pumpEvents) || pumpEvents.length === 0) {\r\n    console.error('No pump events to send');\r\n    return;\r\n  }\r\n\r\n  console.log('Sending events to devices:', pumpEvents);\r\n\r\n  // Group events by device\r\n  const deviceEvents = new Map();\r\n\r\n  pumpEvents.forEach(event => {\r\n    const node = nodes.find(n => n.id === event.target);\r\n    if (!node || !node.data?.MQTTname) {\r\n      console.error('No MQTTname found for node:', node);\r\n      return;\r\n    }\r\n\r\n    if (!deviceEvents.has(node.data.MQTTname)) {\r\n      deviceEvents.set(node.data.MQTTname, []);\r\n    }\r\n\r\n    const hardwareValues = convertToHardwareValuesPump(\r\n      { volume: 0, speed: event.value },\r\n      node.data.properties\r\n    );\r\n\r\n    deviceEvents.get(node.data.MQTTname).push([\r\n      hardwareValues.delayMicroseconds,\r\n      Math.round(event.time * 1000000)\r\n    ]);\r\n  });\r\n\r\n  let deviceEntries = Array.from(deviceEvents.entries());\r\n  console.log('Device events:', deviceEntries);\r\n\r\n  deviceEntries.forEach(([deviceName, events]) => {\r\n    for (let i = events.length - 1; i > 0; i--) {\r\n      events[i][1] = events[i][1] - events[i - 1][1];\r\n    }\r\n  });\r\n  \r\n  deviceEntries.forEach(([deviceName, events], deviceIndex) => {\r\n    const chunks = [];\r\n    for (let i = 0; i < events.length; i += 5) {\r\n      chunks.push(events.slice(i, i + 5));\r\n    }\r\n\r\n    const sendChunks = async () => {\r\n      if (chunks.length > 0) {\r\n        try {\r\n          const firstMessage = {\r\n            topic: `${deviceName}/new_program`,\r\n            payload: chunks[0]\r\n          };\r\n          console.log('Sending new program to device:', deviceName, firstMessage);\r\n          ws.send(JSON.stringify(firstMessage));\r\n\r\n          const delay = ms => new Promise(resolve => setTimeout(resolve, ms));\r\n\r\n          for (let i = 1; i < chunks.length; i++) {\r\n            await delay(2);\r\n            const message = {\r\n              topic: `${deviceName}/continue_program`,\r\n              payload: chunks[i]\r\n            };\r\n            console.log('Sending continue program to device:', deviceName, message);\r\n            ws.send(JSON.stringify(message));\r\n          }\r\n\r\n          await delay(2);\r\n\r\n          const runMessage = {\r\n            topic: `${deviceName}/${deviceIndex === 0 ? 'run_master' : 'run_slave'}`,\r\n            payload: \"run\"\r\n          };\r\n          console.log('Sending run command to device:', deviceName, runMessage);\r\n          ws.send(JSON.stringify(runMessage));\r\n        } catch (error) {\r\n          console.error('Error sending messages to device:', deviceName, error);\r\n        }\r\n      }\r\n    };\r\n\r\n    sendChunks().catch(error => {\r\n      console.error('Error in sendChunks:', error);\r\n    });\r\n  });\r\n};\r\n\r\n/**\r\n * Divide droplets into blocks based on thermostat volumes\r\n * @param {Array} droplets - Array of droplet objects\r\n * @param {Array} thermostatVolumes - Array of thermostat volume objects\r\n * @param {Array} nodes - Array of graph nodes\r\n * @param {Array} links - Array of graph links\r\n * @returns {Array} Array of blocks containing droplets\r\n */\r\nexport const divideDropletsIntoBlocks = (droplets, thermostatVolumes, nodes, links) => {\r\n  if (thermostatVolumes.length === 0) {\r\n    return [{\r\n      droplets: droplets,\r\n      thermostatId: null,\r\n      totalVolume: droplets.reduce((acc, droplet) => acc + droplet.actualVolume, 0),\r\n      temperature: null,\r\n      time: null\r\n    }];\r\n  }\r\n\r\n  const outletNode = findOutletNode(nodes);\r\n  const furthestNode = findFurthestNode(outletNode, nodes, links);\r\n  const volumeToFurthestNode = getVolumeBetweenNodes(\r\n    thermostatVolumes[0].endThermostatId, \r\n    furthestNode.id,\r\n    nodes,\r\n    links\r\n  );\r\n  \r\n  if (!droplets.length || !thermostatVolumes.length) return [];\r\n\r\n  const blocks = [];\r\n  let currentBlock = {\r\n    droplets: [],\r\n    thermostatId: thermostatVolumes[0].endThermostatId,\r\n    totalVolume: 0,\r\n    temperature: null,\r\n    time: null\r\n  };\r\n\r\n  // Helper to finalize a block and start a new one\r\n  const finalizeBlock = (thermostatId, temperature, time) => {\r\n    if (currentBlock.droplets.length > 0) {\r\n      // Add volumeToFurthestNode to the surfixVolume of the last droplet in the block\r\n      const lastDroplet = currentBlock.droplets[currentBlock.droplets.length - 1];\r\n      const surfixParam = lastDroplet.parameters.find(p => p.name === 'surfixVolume');\r\n      if (surfixParam) {\r\n        surfixParam.value = Math.max(volumeToFurthestNode, surfixParam.value);\r\n      } else {\r\n        lastDroplet.parameters.push({\r\n          name: 'surfixVolume',\r\n          value: volumeToFurthestNode\r\n        });\r\n      }\r\n      \r\n      blocks.push({ ...currentBlock });\r\n    }\r\n    currentBlock = {\r\n      droplets: [],\r\n      thermostatId: thermostatId,\r\n      totalVolume: 0,\r\n      temperature: temperature,\r\n      time: time\r\n    };\r\n  };\r\n\r\n  // Process droplets in order\r\n  for (let i = 0; i < droplets.length; i++) {\r\n    const droplet = droplets[i];\r\n    const temperature = droplet.parameters.find(p => p.name === 'temperature')?.value;\r\n    const time = droplet.parameters.find(p => p.name === 'time')?.value;\r\n\r\n    // Start new block if temperature or time changes, or if volume limit exceeded\r\n    const relevantVolume = thermostatVolumes.find(tv => \r\n      tv.startThermostatId === currentBlock.thermostatId || \r\n      tv.endThermostatId === currentBlock.thermostatId\r\n    );\r\n\r\n    let dropletVolume = droplet.parameters.find(p => p.name === 'volume')?.value;\r\n    dropletVolume += droplet.parameters.find(p => p.name === 'prefixVolume')?.value;\r\n\r\n    if (\r\n      currentBlock.temperature !== temperature ||\r\n      currentBlock.time !== time ||\r\n      (relevantVolume && currentBlock.totalVolume + dropletVolume > relevantVolume.volume)\r\n    ) {\r\n      finalizeBlock(thermostatVolumes[0].endThermostatId, temperature, time);\r\n    }\r\n    dropletVolume += droplet.parameters.find(p => p.name === 'surfixVolume')?.value;\r\n    // Add droplet to current block\r\n    currentBlock.droplets.push(droplet);\r\n    currentBlock.totalVolume += dropletVolume;\r\n    currentBlock.temperature = temperature;\r\n    currentBlock.time = time;\r\n  }\r\n\r\n  // Finalize last block\r\n  finalizeBlock(null, null, null);\r\n\r\n  return blocks;\r\n};\r\n\r\n/**\r\n * Print droplet front positions and speeds for debugging\r\n * @param {Array} droplets - Array of droplet objects\r\n */\r\nexport const printDropletFrontPositionsAndSpeeds = (droplets) => {\r\n  droplets.forEach(droplet => {\r\n    console.log(\r\n      `Droplet ID: ${droplet.id}, ` +\r\n      `Front Volumetric Position: ${droplet.frontVolumetricPosition}, ` +\r\n      `Front time to next node: ${droplet.frontTimeToReachNextNode}, ` +\r\n      `Front Volumetric Distance to next node: ${droplet.frontVolumetricDistanceToNextNode}, ` +\r\n      `Rear Volumetric Position: ${droplet.rearVolumetricPosition}, ` +\r\n      `Rear time to next node: ${droplet.rearTimeToReachNextNode}, ` +\r\n      `Rear Volumetric Distance to next node: ${droplet.rearVolumetricDistanceToNextNode}, ` +\r\n      `frontNextNodeID: ${droplet.frontNextNodeID}, ` +\r\n      `rearNextNodeID: ${droplet.rearNextNodeID}`\r\n    );\r\n  });\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}